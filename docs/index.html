<!DOCTYPE html>

<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="apple-touch-fullscreen" content="yes">
    <meta name="mobile-web-app-capable" content="yes">
    <title>CAC Utili-Track</title>

<!-- Leaflet CSS -->
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/leaflet/1.9.4/leaflet.min.css" />
<!-- Font Awesome for icons -->
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.1/css/all.min.css" />
<!-- Google Fonts -->
<link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700;800;900&family=Space+Grotesk:wght@300;400;500;600;700&display=swap">

<style>
    :root {
        /* Premium Color Palette */
        --bg-primary: #0a0a0f;
        --bg-secondary: #12121a;
        --bg-tertiary: #1a1a25;
        --bg-glass: rgba(18, 18, 26, 0.85);
        --bg-glass-light: rgba(255, 255, 255, 0.05);
        
        --text-primary: #ffffff;
        --text-secondary: #a0a0b8;
        --text-tertiary: #6b6b80;
        
        --border-color: rgba(255, 255, 255, 0.1);
        --border-active: rgba(255, 255, 255, 0.2);
        
        /* Premium Shadows */
        --shadow-sm: 0 2px 8px rgba(0, 0, 0, 0.3);
        --shadow-md: 0 4px 16px rgba(0, 0, 0, 0.4);
        --shadow-lg: 0 8px 32px rgba(0, 0, 0, 0.5);
        --shadow-xl: 0 12px 48px rgba(0, 0, 0, 0.6);
        --shadow-glow: 0 0 40px rgba(102, 126, 234, 0.5);
        
        /* Utility Colors - Premium Vibrant */
        --water-color: #00b4d8;
        --gas-color: #ffd60a;
        --electric-color: #ff006e;
        --sewer-color: #a8763e;
        --telecom-color: #b565d8;
        
        /* UI Accent Colors */
        --danger-color: #ff0054;
        --success-color: #00f5a0;
        --warning-color: #ffd60a;
        --info-color: #00b4d8;
        
        /* Premium Gradients */
        --gradient-primary: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        --gradient-danger: linear-gradient(135deg, #ff0054 0%, #ff006e 100%);
        --gradient-success: linear-gradient(135deg, #00f5a0 0%, #00d084 100%);
        --gradient-premium: linear-gradient(180deg, #0a0a0f 0%, #1a1a25 100%);
        --gradient-glass: linear-gradient(135deg, rgba(255,255,255,0.1) 0%, rgba(255,255,255,0.05) 100%);
        --gradient-gold: linear-gradient(135deg, #ffd700 0%, #ffed4e 50%, #ffd700 100%);
        
        /* Spacing */
        --spacing-xs: 4px;
        --spacing-sm: 8px;
        --spacing-md: 16px;
        --spacing-lg: 24px;
        --spacing-xl: 32px;
        --spacing-2xl: 48px;
        
        /* Border Radius */
        --radius-sm: 8px;
        --radius-md: 12px;
        --radius-lg: 16px;
        --radius-xl: 24px;
        --radius-2xl: 32px;
        --radius-full: 9999px;
        
        /* Transitions */
        --transition-fast: 150ms cubic-bezier(0.4, 0, 0.2, 1);
        --transition-normal: 300ms cubic-bezier(0.4, 0, 0.2, 1);
        --transition-slow: 500ms cubic-bezier(0.4, 0, 0.2, 1);
        --transition-spring: 500ms cubic-bezier(0.34, 1.56, 0.64, 1);
        --transition-bounce: 600ms cubic-bezier(0.68, -0.55, 0.265, 1.55);
    }
    
    /* Light Mode */
    [data-theme="light"] {
        --bg-primary: #ffffff;
        --bg-secondary: #f8f9fa;
        --bg-tertiary: #e9ecef;
        --bg-glass: rgba(255, 255, 255, 0.85);
        --bg-glass-light: rgba(0, 0, 0, 0.05);
        --text-primary: #1a1d21;
        --text-secondary: #6c757d;
        --text-tertiary: #adb5bd;
        --border-color: rgba(0, 0, 0, 0.1);
        --border-active: rgba(0, 0, 0, 0.2);
        --gradient-premium: linear-gradient(180deg, #ffffff 0%, #f8f9fa 100%);
    }
    
    * {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
        -webkit-tap-highlight-color: transparent;
        -webkit-touch-callout: none;
        -webkit-user-select: none;
        -moz-user-select: none;
        -ms-user-select: none;
        user-select: none;
    }
    
    html, body {
        height: 100%;
        width: 100%;
        overflow: hidden;
        font-family: 'Inter', -apple-system, sans-serif;
        background-color: var(--bg-primary);
        color: var(--text-primary);
        touch-action: manipulation;
        -webkit-text-size-adjust: 100%;
        overscroll-behavior: none;
    }
    
    /* Prevent all zooming */
    input, select, textarea {
        font-size: 16px !important;
        touch-action: manipulation;
    }
    
    /* App Container */
    .app-container {
        position: relative;
        width: 100%;
        height: 100vh;
        height: 100dvh;
        overflow: hidden;
        background: var(--bg-primary);
    }
    
    /* Map Container */
    #map {
        width: 100%;
        height: 100%;
        z-index: 1;
        background: var(--bg-primary);
    }
    
    /* Ultra Premium Complex Splash Screen */
    .splash-screen {
        position: fixed;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        background: radial-gradient(circle at 30% 20%, #1a0d2e 0%, #0f0c1a 30%, #000000 100%);
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        z-index: 10000;
        opacity: 1;
        transition: opacity 1.5s cubic-bezier(0.4, 0, 0.2, 1);
        overflow: hidden;
    }
    
    /* Animated Background Layers */
    .splash-screen::before {
        content: '';
        position: absolute;
        inset: 0;
        background: 
            radial-gradient(circle at 80% 30%, rgba(102, 126, 234, 0.15) 0%, transparent 40%),
            radial-gradient(circle at 20% 80%, rgba(255, 0, 110, 0.1) 0%, transparent 40%),
            radial-gradient(circle at 60% 70%, rgba(0, 245, 160, 0.08) 0%, transparent 30%);
        animation: backgroundFlow 12s ease-in-out infinite;
    }
    
    .splash-screen::after {
        content: '';
        position: absolute;
        inset: 0;
        background: url("data:image/svg+xml,%3Csvg width='40' height='40' viewBox='0 0 40 40' xmlns='http://www.w3.org/2000/svg'%3E%3Cg fill='rgba(255,255,255,0.02)' fill-opacity='1'%3E%3Cpath d='M20 20c0 11.046-8.954 20-20 20s-20-8.954-20-20 8.954-20 20-20 20 8.954 20 20zm-2 0c0-9.941-8.059-18-18-18s-18 8.059-18 18 8.059 18 18 18 18-8.059 18-18z'/%3E%3C/g%3E%3C/svg%3E");
        animation: patternMove 40s linear infinite;
    }
    
    @keyframes backgroundFlow {
        0%, 100% { 
            transform: scale(1) rotate(0deg);
            opacity: 1;
        }
        33% { 
            transform: scale(1.1) rotate(120deg);
            opacity: 0.8;
        }
        66% { 
            transform: scale(0.9) rotate(240deg);
            opacity: 0.6;
        }
    }
    
    @keyframes patternMove {
        0% { transform: translate(0, 0); }
        100% { transform: translate(40px, 40px); }
    }
    
    .splash-screen.hide {
        opacity: 0;
        pointer-events: none;
        transform: scale(1.1);
    }
    
    /* Floating Particles */
    .splash-particles {
        position: absolute;
        inset: 0;
        pointer-events: none;
        overflow: hidden;
    }
    
    .particle {
        position: absolute;
        width: 3px;
        height: 3px;
        background: rgba(255, 255, 255, 0.4);
        border-radius: 50%;
        opacity: 0;
        animation: none;
        box-shadow: 0 0 6px rgba(255, 255, 255, 0.3);
        transition: opacity 0.5s ease-in-out;
    }
    
    .particle:nth-child(1) { left: 10%; animation-delay: 0s; }
    .particle:nth-child(2) { left: 20%; animation-delay: 2s; }
    .particle:nth-child(3) { left: 30%; animation-delay: 4s; }
    .particle:nth-child(4) { left: 40%; animation-delay: 6s; }
    .particle:nth-child(5) { left: 50%; animation-delay: 8s; }
    .particle:nth-child(6) { left: 60%; animation-delay: 10s; }
    .particle:nth-child(7) { left: 70%; animation-delay: 12s; }
    .particle:nth-child(8) { left: 80%; animation-delay: 14s; }
    .particle:nth-child(9) { left: 90%; animation-delay: 1s; }
    .particle:nth-child(10) { left: 15%; animation-delay: 3s; }
    
    @keyframes particleFloat {
        0% {
            transform: translateY(100vh) scale(0);
            opacity: 0;
        }
        10% {
            opacity: 1;
            transform: translateY(90vh) scale(1);
        }
        90% {
            opacity: 1;
            transform: translateY(-10vh) scale(1);
        }
        100% {
            transform: translateY(-20vh) scale(0);
            opacity: 0;
        }
    }
    
    /* Ultra Premium Animated Logo */
    .splash-logo-container {
        position: relative;
        width: 280px;
        height: 280px;
        margin-bottom: var(--spacing-2xl);
        animation: logoEntrance 2s ease-out;
    }
    
    @keyframes logoEntrance {
        0% {
            transform: scale(0) rotate(180deg);
            opacity: 0;
        }
        70% {
            transform: scale(1.1) rotate(-10deg);
            opacity: 1;
        }
        100% {
            transform: scale(1) rotate(0deg);
            opacity: 1;
        }
    }
    
    .splash-logo {
        position: absolute;
        inset: 0;
        animation: logoFloat 4s ease-in-out infinite;
    }
    
    @keyframes logoFloat {
        0%, 100% { 
            transform: translateY(0) scale(1) rotateZ(0deg);
            filter: drop-shadow(0 10px 30px rgba(102, 126, 234, 0.3));
        }
        50% { 
            transform: translateY(-15px) scale(1.02) rotateZ(1deg);
            filter: drop-shadow(0 20px 50px rgba(102, 126, 234, 0.6));
        }
    }
    
    /* Outer Rotating Rings */
    .logo-outer-ring {
        position: absolute;
        inset: -20px;
        border: 1px solid transparent;
        background: conic-gradient(from 0deg, 
            transparent 0deg, 
            rgba(102, 126, 234, 0.3) 45deg,
            transparent 90deg,
            rgba(255, 0, 110, 0.3) 135deg,
            transparent 180deg,
            rgba(0, 245, 160, 0.3) 225deg,
            transparent 270deg,
            rgba(255, 214, 10, 0.3) 315deg,
            transparent 360deg
        );
        border-radius: 50%;
        mask: radial-gradient(circle, transparent 85%, black 87%, black 100%);
        -webkit-mask: radial-gradient(circle, transparent 85%, black 87%, black 100%);
        animation: outerRingRotate 8s linear infinite;
    }
    
    .logo-inner-ring {
        position: absolute;
        inset: -10px;
        border: 1px solid transparent;
        background: conic-gradient(from 180deg,
            transparent 0deg,
            rgba(181, 101, 216, 0.4) 60deg,
            transparent 120deg,
            rgba(0, 180, 216, 0.4) 240deg,
            transparent 300deg
        );
        border-radius: 50%;
        mask: radial-gradient(circle, transparent 80%, black 82%, black 100%);
        -webkit-mask: radial-gradient(circle, transparent 80%, black 82%, black 100%);
        animation: innerRingRotate 6s linear infinite reverse;
    }
    
    @keyframes outerRingRotate {
        from { transform: rotate(0deg); }
        to { transform: rotate(360deg); }
    }
    
    @keyframes innerRingRotate {
        from { transform: rotate(0deg); }
        to { transform: rotate(360deg); }
    }
    
    .logo-hexagon {
        width: 280px;
        height: 280px;
        position: relative;
        filter: drop-shadow(0 0 60px rgba(102, 126, 234, 0.8));
    }
    
    .hex-inner {
        width: 100%;
        height: 100%;
        position: relative;
        transform: rotate(30deg);
        overflow: hidden;
        border-radius: 25%;
        background: linear-gradient(45deg, 
            rgba(0, 0, 0, 0.9) 0%, 
            rgba(26, 13, 46, 0.95) 50%, 
            rgba(0, 0, 0, 0.9) 100%);
    }
    
    .hex-inner::before {
        content: '';
        position: absolute;
        inset: -100%;
        background: conic-gradient(from 0deg, 
            #667eea, #764ba2, #ff006e, #ffd60a, 
            #00f5a0, #00b4d8, #b565d8, #667eea);
        animation: gradientRotate 4s linear infinite;
        filter: blur(1px);
    }
    
    @keyframes gradientRotate {
        from { transform: rotate(0deg) scale(1); }
        to { transform: rotate(360deg) scale(1.1); }
    }
    
    .hex-inner::after {
        content: '';
        position: absolute;
        inset: 4px;
        background: radial-gradient(circle at center,
            rgba(0, 0, 0, 0.95) 0%,
            rgba(26, 13, 46, 0.98) 70%,
            rgba(0, 0, 0, 1) 100%);
        border-radius: 25%;
        backdrop-filter: blur(10px);
    }
    
    .logo-content {
        position: absolute;
        inset: 0;
        display: flex;
        align-items: center;
        justify-content: center;
        z-index: 2;
    }
    
    .logo-grid {
        display: grid;
        grid-template-columns: repeat(3, 1fr);
        gap: 12px;
        transform: rotate(-30deg);
        animation: gridPulse 3s ease-in-out infinite;
    }
    
    @keyframes gridPulse {
        0%, 100% { transform: rotate(-30deg) scale(1); }
        50% { transform: rotate(-30deg) scale(1.05); }
    }
    
    .logo-dot {
        width: 20px;
        height: 20px;
        border-radius: 50%;
        position: relative;
        overflow: hidden;
        animation: dotPulse 2.5s ease-in-out infinite;
    }
    
    .logo-dot::before {
        content: '';
        position: absolute;
        inset: -2px;
        border-radius: 50%;
        background: conic-gradient(from 0deg, currentColor, transparent, currentColor);
        animation: dotRotate 3s linear infinite;
    }
    
    .logo-dot::after {
        content: '';
        position: absolute;
        inset: 2px;
        border-radius: 50%;
        background: rgba(0, 0, 0, 0.8);
    }
    
    @keyframes dotRotate {
        from { transform: rotate(0deg); }
        to { transform: rotate(360deg); }
    }
    
    .logo-dot:nth-child(1) { 
        background: var(--water-color); 
        animation-delay: 0s; 
        color: var(--water-color);
    }
    .logo-dot:nth-child(2) { 
        background: var(--gas-color); 
        animation-delay: 0.15s; 
        color: var(--gas-color);
    }
    .logo-dot:nth-child(3) { 
        background: var(--electric-color); 
        animation-delay: 0.3s; 
        color: var(--electric-color);
    }
    .logo-dot:nth-child(4) { 
        background: var(--sewer-color); 
        animation-delay: 0.45s; 
        color: var(--sewer-color);
    }
    .logo-dot:nth-child(5) { 
        background: linear-gradient(45deg, #667eea, #764ba2); 
        animation-delay: 0.6s; 
        color: #667eea;
    }
    .logo-dot:nth-child(6) { 
        background: var(--telecom-color); 
        animation-delay: 0.75s; 
        color: var(--telecom-color);
    }
    .logo-dot:nth-child(7) { 
        background: var(--success-color); 
        animation-delay: 0.9s; 
        color: var(--success-color);
    }
    .logo-dot:nth-child(8) { 
        background: var(--warning-color); 
        animation-delay: 1.05s; 
        color: var(--warning-color);
    }
    .logo-dot:nth-child(9) { 
        background: var(--info-color); 
        animation-delay: 1.2s; 
        color: var(--info-color);
    }
    
    @keyframes dotPulse {
        0%, 100% { 
            transform: scale(1); 
            opacity: 0.8;
            filter: brightness(1);
        }
        50% { 
            transform: scale(1.3); 
            opacity: 1;
            filter: brightness(1.2) saturate(1.3);
        }
    }
    
    /* Enhanced Typography */
    .splash-title {
        font-family: 'Space Grotesk', sans-serif;
        font-size: 42px;
        font-weight: 900;
        background: linear-gradient(135deg, 
            #ffffff 0%, 
            #667eea 25%, 
            #ff006e 50%, 
            #00f5a0 75%, 
            #ffffff 100%);
        background-size: 300% 100%;
        -webkit-background-clip: text;
        background-clip: text;
        -webkit-text-fill-color: transparent;
        letter-spacing: -2px;
        animation: titleShimmer 4s ease-in-out infinite, titleFloat 3s ease-in-out infinite;
        margin-bottom: var(--spacing-md);
        text-shadow: 0 0 30px rgba(102, 126, 234, 0.5);
        position: relative;
    }
    
    .splash-title::before {
        content: 'CAC UTILI-TRACK';
        position: absolute;
        inset: 0;
        background: linear-gradient(135deg, 
            transparent 0%, 
            rgba(255, 255, 255, 0.1) 50%, 
            transparent 100%);
        background-size: 200% 100%;
        -webkit-background-clip: text;
        background-clip: text;
        -webkit-text-fill-color: transparent;
        animation: titleGlow 2s ease-in-out infinite;
        z-index: 1;
    }
    
    @keyframes titleShimmer {
        0%, 100% { background-position: 300% center; }
        50% { background-position: 0% center; }
    }
    
    @keyframes titleFloat {
        0%, 100% { transform: translateY(0px); }
        50% { transform: translateY(-5px); }
    }
    
    @keyframes titleGlow {
        0%, 100% { 
            background-position: 200% center;
            opacity: 0;
        }
        50% { 
            background-position: 0% center;
            opacity: 1;
        }
    }
    
    .splash-subtitle {
        font-size: 16px;
        font-weight: 600;
        color: transparent;
        background: linear-gradient(90deg, 
            rgba(255, 255, 255, 0.4) 0%,
            rgba(102, 126, 234, 0.8) 50%,
            rgba(255, 255, 255, 0.4) 100%);
        background-size: 200% 100%;
        -webkit-background-clip: text;
        background-clip: text;
        letter-spacing: 4px;
        text-transform: uppercase;
        opacity: 0;
        animation: 
            fadeInUp 1.5s ease-out 1s forwards,
            subtitleShimmer 3s ease-in-out 1.5s infinite;
        position: relative;
    }
    
    @keyframes fadeInUp {
        from { 
            opacity: 0; 
            transform: translateY(30px) scale(0.9); 
        }
        to { 
            opacity: 1; 
            transform: translateY(0) scale(1); 
        }
    }
    
    @keyframes subtitleShimmer {
        0%, 100% { background-position: 200% center; }
        50% { background-position: 0% center; }
    }
    
    /* Ultra Premium Progress System */
    .splash-loader {
        position: absolute;
        bottom: 60px;
        width: 320px;
        height: 6px;
        background: rgba(255, 255, 255, 0.05);
        border-radius: var(--radius-full);
        overflow: hidden;
        border: 1px solid rgba(255, 255, 255, 0.1);
        box-shadow: 
            inset 0 1px 3px rgba(0, 0, 0, 0.3),
            0 0 20px rgba(102, 126, 234, 0.2);
    }
    
    .splash-loader::before {
        content: '';
        position: absolute;
        inset: 0;
        background: linear-gradient(90deg, 
            transparent 0%, 
            rgba(102, 126, 234, 0.8) 10%,
            rgba(255, 0, 110, 0.9) 30%,
            rgba(0, 245, 160, 0.8) 50%,
            rgba(255, 214, 10, 0.9) 70%,
            rgba(181, 101, 216, 0.8) 90%,
            transparent 100%);
        transform: translateX(-100%);
        animation: loadProgress 3s ease-out forwards;
        border-radius: inherit;
        filter: blur(0.5px);
    }
    
    .splash-loader::after {
        content: '';
        position: absolute;
        inset: 0;
        background: linear-gradient(90deg, 
            transparent 0%, 
            rgba(255, 255, 255, 0.6) 50%, 
            transparent 100%);
        width: 100px;
        transform: translateX(-100px);
        animation: loadShimmer 3s ease-out 0.5s forwards;
        border-radius: inherit;
        filter: blur(1px);
    }
    
    @keyframes loadProgress {
        0% { 
            transform: translateX(-100%); 
            filter: blur(2px);
        }
        100% { 
            transform: translateX(0); 
            filter: blur(0px);
        }
    }
    
    @keyframes loadShimmer {
        0% { transform: translateX(-100px); }
        100% { transform: translateX(320px); }
    }
    
    /* Progress Percentage */
    .splash-progress {
        position: absolute;
        bottom: 20px;
        font-size: 12px;
        font-weight: 600;
        color: rgba(255, 255, 255, 0.6);
        letter-spacing: 2px;
        opacity: 0;
        animation: fadeInUp 0.5s ease-out 2s forwards;
    }
    
    /* Premium Top Bar */
    .top-bar {
        position: absolute;
        top: env(safe-area-inset-top, 0);
        left: 0;
        right: 0;
        padding: var(--spacing-md);
        z-index: 100;
        pointer-events: none;
    }
    
    .top-bar > * {
        pointer-events: auto;
    }
    
    /* Utility Selector - Premium Glass Design */
    .utility-selector {
        display: flex;
        gap: 2px;
        justify-content: center;
        margin: 0 auto;
        background: var(--bg-glass);
        backdrop-filter: blur(20px) saturate(180%);
        -webkit-backdrop-filter: blur(20px) saturate(180%);
        border-radius: var(--radius-2xl);
        padding: 6px;
        box-shadow: var(--shadow-lg), inset 0 1px 0 var(--border-color);
        max-width: fit-content;
        border: 1px solid var(--border-color);
        position: relative;
    }
    
    .utility-selector::before {
        content: '';
        position: absolute;
        inset: -1px;
        background: var(--gradient-primary);
        border-radius: inherit;
        opacity: 0;
        filter: blur(20px);
        transition: opacity var(--transition-normal);
        z-index: -1;
    }
    
    .utility-selector:hover::before {
        opacity: 0.3;
    }
    
    .utility-btn {
        width: 48px;
        height: 48px;
        border: none;
        background: transparent;
        border-radius: var(--radius-xl);
        display: flex;
        align-items: center;
        justify-content: center;
        cursor: pointer;
        transition: all var(--transition-normal);
        position: relative;
        overflow: hidden;
    }
    
    .utility-btn::before {
        content: '';
        position: absolute;
        inset: 0;
        background: radial-gradient(circle at center, currentColor, transparent);
        opacity: 0;
        transition: opacity var(--transition-fast);
    }
    
    .utility-btn.active::before {
        opacity: 0.2;
    }
    
    .utility-btn::after {
        content: '';
        position: absolute;
        inset: -50%;
        background: radial-gradient(circle at center, currentColor, transparent);
        opacity: 0;
        transform: scale(0);
        transition: all var(--transition-spring);
    }
    
    .utility-btn.active::after {
        opacity: 0.1;
        transform: scale(1);
    }
    
    .utility-btn:active {
        transform: scale(0.92);
    }
    
    .utility-btn i {
        font-size: 22px;
        color: var(--text-tertiary);
        position: relative;
        z-index: 1;
        transition: all var(--transition-normal);
    }
    
    .utility-btn.active i {
        color: currentColor;
        transform: scale(1.15);
        filter: drop-shadow(0 0 8px currentColor);
    }
    
    .utility-btn.water { color: var(--water-color); }
    .utility-btn.gas { color: var(--gas-color); }
    .utility-btn.electric { color: var(--electric-color); }
    .utility-btn.sewer { color: var(--sewer-color); }
    .utility-btn.telecom { color: var(--telecom-color); }
    
    /* Premium Bottom Controls */
    .bottom-controls {
        position: absolute;
        bottom: calc(env(safe-area-inset-bottom, 0) + var(--spacing-md));
        left: var(--spacing-md);
        right: var(--spacing-md);
        display: flex;
        justify-content: space-between;
        align-items: flex-end;
        z-index: 100;
        pointer-events: none;
        gap: var(--spacing-md);
    }
    
    .bottom-controls > * {
        pointer-events: auto;
    }
    
    /* Control Groups */
    .control-group {
        display: flex;
        flex-direction: column;
        gap: var(--spacing-sm);
    }
    
    .control-group.center {
        position: relative;
    }
    
    /* Premium Control Buttons */
    .control-btn {
        width: 56px;
        height: 56px;
        border: none;
        background: var(--bg-glass);
        backdrop-filter: blur(20px) saturate(180%);
        -webkit-backdrop-filter: blur(20px) saturate(180%);
        border-radius: var(--radius-lg);
        display: flex;
        align-items: center;
        justify-content: center;
        cursor: pointer;
        box-shadow: var(--shadow-lg);
        transition: all var(--transition-normal);
        position: relative;
        overflow: hidden;
        border: 1px solid var(--border-color);
    }
    
    .control-btn::before {
        content: '';
        position: absolute;
        inset: 0;
        background: var(--gradient-glass);
        opacity: 0;
        transition: opacity var(--transition-normal);
    }
    
    .control-btn:hover::before {
        opacity: 1;
    }
    
    .control-btn:active {
        transform: scale(0.92);
        box-shadow: var(--shadow-md);
    }
    
    .control-btn:hover {
        transform: translateY(-2px);
        box-shadow: var(--shadow-xl);
    }
    
    .control-btn::after {
        content: '';
        position: absolute;
        inset: -2px;
        background: inherit;
        border-radius: inherit;
        opacity: 0;
        filter: blur(10px);
        transition: opacity var(--transition-normal);
        z-index: -1;
    }
    
    .control-btn.active::after {
        opacity: 0.3;
    }
    
    .control-btn.active {
        background: var(--gradient-primary);
        border-color: transparent;
    }
    
    .control-btn i {
        font-size: 24px;
        color: var(--text-primary);
        transition: all var(--transition-normal);
        z-index: 1;
    }
    
    .control-btn.active i {
        color: white;
        filter: drop-shadow(0 2px 4px rgba(0, 0, 0, 0.3));
    }
    
    /* Main Action Button Group */
    .main-action-group {
        display: flex;
        flex-direction: column;
        align-items: center;
        gap: var(--spacing-sm);
        position: relative;
    }
    
    /* Line Type Toggle - Premium Floating Design */
    .line-type-toggle {
        display: flex;
        background: var(--bg-glass);
        backdrop-filter: blur(20px) saturate(180%);
        -webkit-backdrop-filter: blur(20px) saturate(180%);
        border-radius: var(--radius-full);
        padding: 4px;
        box-shadow: var(--shadow-lg);
        border: 1px solid var(--border-color);
        order: 2;
        margin-top: var(--spacing-xs);
    }
    
    .line-type-btn {
        padding: var(--spacing-sm) var(--spacing-md);
        border: none;
        background: transparent;
        border-radius: var(--radius-full);
        font-size: 13px;
        font-weight: 600;
        color: var(--text-secondary);
        cursor: pointer;
        transition: all var(--transition-normal);
        white-space: nowrap;
        position: relative;
    }
    
    .line-type-btn.active {
        background: var(--gradient-primary);
        color: white;
        box-shadow: var(--shadow-md);
    }
    
    /* Main Draw Button - Premium Animated */
    .main-action-btn {
        width: 72px;
        height: 72px;
        border: none;
        background: var(--gradient-primary);
        border-radius: var(--radius-2xl);
        display: flex;
        align-items: center;
        justify-content: center;
        cursor: pointer;
        box-shadow: var(--shadow-xl), 0 0 40px rgba(102, 126, 234, 0.3);
        transition: all var(--transition-spring);
        position: relative;
        overflow: hidden;
        order: 1;
    }
    
    .main-action-btn::before {
        content: '';
        position: absolute;
        inset: -2px;
        background: var(--gradient-primary);
        border-radius: inherit;
        opacity: 0;
        filter: blur(15px);
        transition: opacity var(--transition-normal);
    }
    
    .main-action-btn:hover::before {
        opacity: 0.5;
    }
    
    .main-action-btn:active {
        transform: scale(0.92);
        box-shadow: var(--shadow-lg);
    }
    
    .main-action-btn.active {
        animation: drawPulse 2s ease-in-out infinite;
    }
    
    @keyframes drawPulse {
        0%, 100% { 
            box-shadow: var(--shadow-xl), 0 0 40px rgba(102, 126, 234, 0.3);
        }
        50% { 
            box-shadow: var(--shadow-xl), 0 0 60px rgba(102, 126, 234, 0.6);
        }
    }
    
    .main-action-btn i {
        font-size: 32px;
        color: white;
        z-index: 1;
    }
    
    /* Excavation Button - Premium Danger Style */
    .excavation-btn {
        background: var(--gradient-danger) !important;
        position: relative;
        overflow: visible !important;
    }
    
    .excavation-btn::after {
        content: '';
        position: absolute;
        inset: -20px;
        background: var(--gradient-danger);
        border-radius: 50%;
        opacity: 0;
        filter: blur(20px);
        animation: none;
        transition: all var(--transition-normal);
        z-index: -1;
    }
    
    .excavation-btn.active::after {
        animation: excavationPulse 2s ease-in-out infinite;
    }
    
    @keyframes excavationPulse {
        0%, 100% { 
            opacity: 0;
            transform: scale(0.8);
        }
        50% { 
            opacity: 0.5;
            transform: scale(1.2);
        }
    }
    
    .excavation-btn i {
        color: white !important;
    }
    
    /* Right Side Controls */
    .right-controls {
        display: flex;
        flex-direction: column;
        gap: var(--spacing-sm);
        position: absolute;
        right: var(--spacing-md);
        top: 50%;
        transform: translateY(-50%);
        z-index: 100;
    }
    
    /* Measurement Tools */
    .measurement-tools {
        display: flex;
        flex-direction: column;
        gap: var(--spacing-sm);
        position: absolute;
        left: var(--spacing-md);
        top: 50%;
        transform: translateY(-50%);
        z-index: 100;
    }
    
    .measurement-btn {
        width: 52px;
        height: 52px;
        background: var(--bg-glass);
        backdrop-filter: blur(20px) saturate(180%);
        -webkit-backdrop-filter: blur(20px) saturate(180%);
        border: 1px solid var(--border-color);
        border-radius: var(--radius-lg);
        display: flex;
        align-items: center;
        justify-content: center;
        cursor: pointer;
        box-shadow: var(--shadow-md);
        transition: all var(--transition-normal);
    }
    
    .measurement-btn.active {
        background: var(--gradient-primary);
        border-color: transparent;
    }
    
    .measurement-btn i {
        font-size: 22px;
        color: var(--text-primary);
    }
    
    .measurement-btn.active i {
        color: white;
    }
    
    /* Simple Zoom-Responsive User Location Marker */
    .user-location-marker {
        pointer-events: none;
        z-index: 1000;
        transform-origin: center center;
        transition: transform 0.3s ease-out;
    }
    
    .location-container {
        position: relative;
        width: 48px;
        height: 48px;
        display: flex;
        align-items: center;
        justify-content: center;
    }
    
    /* Accuracy Ring */
    .location-accuracy {
        position: absolute;
        inset: -16px;
        border-radius: 50%;
        background: radial-gradient(circle at center, 
            rgba(0, 245, 160, 0.15) 0%, 
            rgba(0, 245, 160, 0.05) 60%,
            transparent 100%);
        border: 1px solid rgba(0, 245, 160, 0.2);
        animation: accuracyPulse 4s ease-in-out infinite;
    }
    
    @keyframes accuracyPulse {
        0%, 100% { 
            transform: scale(0.8); 
            opacity: 0.6; 
        }
        50% { 
            transform: scale(1.2); 
            opacity: 0.3; 
        }
    }
    
    /* Arrow-Style Location Marker */
    .location-arrow {
        position: relative;
        width: 32px;
        height: 32px;
        transform-origin: center center;
        transition: transform 0.3s cubic-bezier(0.4, 0, 0.2, 1);
        z-index: 2;
    }
    
    .location-arrow::before {
        content: '';
        position: absolute;
        top: 0;
        left: 50%;
        transform: translateX(-50%);
        width: 0;
        height: 0;
        border-left: 12px solid transparent;
        border-right: 12px solid transparent;
        border-bottom: 28px solid #ffffff;
        filter: drop-shadow(0 2px 8px rgba(0, 0, 0, 0.4));
        z-index: 1;
    }
    
    .location-arrow::after {
        content: '';
        position: absolute;
        top: 2px;
        left: 50%;
        transform: translateX(-50%);
        width: 0;
        height: 0;
        border-left: 10px solid transparent;
        border-right: 10px solid transparent;
        border-bottom: 24px solid rgba(0, 245, 160, 1);
        z-index: 2;
    }
    
    /* User Center Dot */
    .location-center {
        position: absolute;
        bottom: 4px;
        left: 50%;
        transform: translateX(-50%);
        width: 8px;
        height: 8px;
        border-radius: 50%;
        background: #ffffff;
        border: 2px solid rgba(0, 245, 160, 1);
        box-shadow: 0 0 12px rgba(0, 245, 160, 0.6);
        z-index: 3;
    }
    
    /* Drawing UI - Premium Floating */
    .drawing-ui {
        position: absolute;
        top: calc(env(safe-area-inset-top, 0) + 80px);
        left: 50%;
        transform: translateX(-50%);
        background: var(--bg-glass);
        backdrop-filter: blur(30px) saturate(180%);
        -webkit-backdrop-filter: blur(30px) saturate(180%);
        border-radius: var(--radius-xl);
        padding: var(--spacing-lg);
        box-shadow: var(--shadow-xl);
        z-index: 200;
        display: none;
        text-align: center;
        min-width: 280px;
        border: 1px solid var(--border-color);
    }
    
    .drawing-ui.active {
        display: block;
        animation: slideInDown var(--transition-bounce) ease-out;
    }
    
    @keyframes slideInDown {
        from {
            opacity: 0;
            transform: translate(-50%, -30px);
        }
        to {
            opacity: 1;
            transform: translate(-50%, 0);
        }
    }
    
    .drawing-ui h3 {
        font-size: 18px;
        font-weight: 700;
        margin-bottom: var(--spacing-sm);
        background: var(--gradient-primary);
        -webkit-background-clip: text;
        background-clip: text;
        -webkit-text-fill-color: transparent;
    }
    
    .drawing-ui p {
        font-size: 14px;
        color: var(--text-secondary);
        margin-bottom: var(--spacing-lg);
        font-weight: 500;
    }
    
    .drawing-actions {
        display: flex;
        gap: var(--spacing-sm);
        justify-content: center;
    }
    
    .drawing-btn {
        padding: var(--spacing-sm) var(--spacing-lg);
        border: none;
        border-radius: var(--radius-md);
        font-size: 14px;
        font-weight: 600;
        cursor: pointer;
        transition: all var(--transition-normal);
    }
    
    .drawing-btn.primary {
        background: var(--gradient-primary);
        color: white;
        box-shadow: var(--shadow-md);
    }
    
    .drawing-btn.secondary {
        background: var(--bg-glass-light);
        color: var(--text-primary);
        border: 1px solid var(--border-color);
    }
    
    .drawing-btn:active {
        transform: scale(0.95);
    }
    
    /* Refine Mode Overlay */
    .refine-overlay {
        position: absolute;
        top: calc(env(safe-area-inset-top, 0) + 80px);
        left: 50%;
        transform: translateX(-50%);
        background: var(--bg-glass);
        backdrop-filter: blur(30px) saturate(180%);
        -webkit-backdrop-filter: blur(30px) saturate(180%);
        border-radius: var(--radius-xl);
        padding: var(--spacing-md) var(--spacing-lg);
        box-shadow: var(--shadow-xl);
        z-index: 250;
        display: none;
        text-align: center;
        border: 1px solid var(--border-color);
    }
    
    .refine-overlay.active {
        display: block;
        animation: slideInDown var(--transition-bounce) ease-out;
    }
    
    .refine-overlay span {
        font-size: 14px;
        font-weight: 600;
        color: var(--text-primary);
        margin-right: var(--spacing-md);
    }
    
    /* Utility Info Modal - Premium Glass */
    .info-modal {
        position: fixed;
        bottom: 0;
        left: 0;
        right: 0;
        background: var(--bg-glass);
        backdrop-filter: blur(30px) saturate(180%);
        -webkit-backdrop-filter: blur(30px) saturate(180%);
        border-radius: var(--radius-2xl) var(--radius-2xl) 0 0;
        box-shadow: var(--shadow-xl);
        z-index: 300;
        transform: translateY(100%);
        transition: transform var(--transition-spring);
        max-height: 85vh;
        overflow: hidden;
        display: flex;
        flex-direction: column;
        border: 1px solid var(--border-color);
    }
    
    .info-modal.active {
        transform: translateY(0);
    }
    
    .modal-handle {
        width: 48px;
        height: 5px;
        background: var(--text-tertiary);
        border-radius: var(--radius-full);
        margin: var(--spacing-sm) auto;
        opacity: 0.5;
    }
    
    .modal-header {
        padding: 0 var(--spacing-lg) var(--spacing-md);
        border-bottom: 1px solid var(--border-color);
        display: flex;
        align-items: center;
        justify-content: space-between;
    }
    
    .modal-title {
        display: flex;
        align-items: center;
        gap: var(--spacing-sm);
        font-size: 20px;
        font-weight: 700;
    }
    
    .modal-title i {
        font-size: 24px;
        filter: drop-shadow(0 0 8px currentColor);
    }
    
    .modal-close {
        width: 40px;
        height: 40px;
        border: none;
        background: var(--bg-glass-light);
        border-radius: var(--radius-full);
        display: flex;
        align-items: center;
        justify-content: center;
        cursor: pointer;
        transition: all var(--transition-normal);
    }
    
    .modal-close:active {
        transform: scale(0.9);
    }
    
    .modal-body {
        padding: var(--spacing-lg);
        overflow-y: auto;
        flex: 1;
    }
    
    .info-grid {
        display: grid;
        grid-template-columns: repeat(2, 1fr);
        gap: var(--spacing-lg);
        margin-bottom: var(--spacing-lg);
    }
    
    .info-item {
        display: flex;
        flex-direction: column;
        gap: var(--spacing-xs);
    }
    
    .info-label {
        font-size: 12px;
        font-weight: 600;
        color: var(--text-secondary);
        text-transform: uppercase;
        letter-spacing: 0.5px;
    }
    
    .info-value {
        font-size: 16px;
        font-weight: 600;
        color: var(--text-primary);
    }
    
    .modal-actions {
        display: flex;
        gap: var(--spacing-sm);
        padding-top: var(--spacing-lg);
        border-top: 1px solid var(--border-color);
    }
    
    .modal-btn {
        flex: 1;
        padding: var(--spacing-md);
        border: none;
        border-radius: var(--radius-md);
        font-size: 16px;
        font-weight: 600;
        cursor: pointer;
        transition: all var(--transition-normal);
        display: flex;
        align-items: center;
        justify-content: center;
        gap: var(--spacing-sm);
    }
    
    .modal-btn.primary {
        background: var(--gradient-primary);
        color: white;
        box-shadow: var(--shadow-md);
    }
    
    .modal-btn.danger {
        background: var(--gradient-danger);
        color: white;
        box-shadow: var(--shadow-md);
    }
    
    .modal-btn:active {
        transform: scale(0.95);
    }
    
    /* Edit Form */
    .edit-form {
        display: none;
    }
    
    .edit-form.active {
        display: block;
    }
    
    .form-group {
        margin-bottom: var(--spacing-lg);
    }
    
    .form-label {
        display: block;
        font-size: 14px;
        font-weight: 600;
        color: var(--text-secondary);
        margin-bottom: var(--spacing-sm);
    }
    
    .form-input {
        width: 100%;
        padding: var(--spacing-md);
        border: 2px solid var(--border-color);
        border-radius: var(--radius-md);
        background: var(--bg-glass-light);
        color: var(--text-primary);
        font-size: 16px;
        font-weight: 500;
        transition: all var(--transition-normal);
    }
    
    .form-input:focus {
        outline: none;
        border-color: #667eea;
        background: var(--bg-secondary);
        box-shadow: 0 0 0 4px rgba(102, 126, 234, 0.1);
    }
    
    .form-select {
        appearance: none;
        background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='12' height='12' viewBox='0 0 12 12'%3E%3Cpath fill='%236c757d' d='M6 9L1 4h10z'/%3E%3C/svg%3E");
        background-repeat: no-repeat;
        background-position: right 16px center;
        padding-right: 40px;
    }
    
    /* Enhanced Semi-Transparent Excavation Mode */
    .excavation-overlay {
        position: fixed;
        inset: 0;
        background: linear-gradient(
            135deg,
            rgba(255, 0, 84, 0.15) 0%,
            rgba(139, 0, 0, 0.20) 50%,
            rgba(0, 0, 0, 0.25) 100%
        );
        backdrop-filter: blur(1px) saturate(1.2) contrast(1.1);
        -webkit-backdrop-filter: blur(1px) saturate(1.2) contrast(1.1);
        z-index: 400;
        opacity: 0;
        pointer-events: none;
        transition: all var(--transition-slow);
    }
    
    .excavation-overlay.active {
        opacity: 1;
        pointer-events: auto;
    }
    
    /* Enhanced Radar Effect - More Subtle */
    .excavation-radar {
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        width: 400px;
        height: 400px;
        pointer-events: none;
        opacity: 0.6;
    }
    
    .radar-ring {
        position: absolute;
        inset: 0;
        border: 1px solid rgba(255, 0, 84, 0.8);
        border-radius: 50%;
        opacity: 0;
        animation: radarPing 4s ease-out infinite;
        box-shadow: 
            0 0 20px rgba(255, 0, 84, 0.3),
            inset 0 0 20px rgba(255, 0, 84, 0.1);
    }
    
    .radar-ring:nth-child(2) {
        animation-delay: 1.33s;
        border-color: rgba(255, 69, 0, 0.7);
        box-shadow: 
            0 0 20px rgba(255, 69, 0, 0.3),
            inset 0 0 20px rgba(255, 69, 0, 0.1);
    }
    
    .radar-ring:nth-child(3) {
        animation-delay: 2.66s;
        border-color: rgba(255, 140, 0, 0.6);
        box-shadow: 
            0 0 20px rgba(255, 140, 0, 0.3),
            inset 0 0 20px rgba(255, 140, 0, 0.1);
    }
    
    @keyframes radarPing {
        0% {
            transform: scale(0.3);
            opacity: 0;
        }
        30% {
            opacity: 0.8;
        }
        70% {
            opacity: 0.4;
        }
        100% {
            transform: scale(2.5);
            opacity: 0;
        }
    }
    
    /* Compact Header with Glass Effect */
    .excavation-header {
        position: absolute;
        top: calc(env(safe-area-inset-top, 0) + var(--spacing-md));
        left: var(--spacing-md);
        right: var(--spacing-md);
        padding: var(--spacing-md) var(--spacing-lg);
        background: rgba(255, 0, 84, 0.1);
        backdrop-filter: blur(20px) saturate(180%);
        -webkit-backdrop-filter: blur(20px) saturate(180%);
        border-radius: var(--radius-xl);
        border: 1px solid rgba(255, 0, 84, 0.3);
        box-shadow: 
            0 8px 32px rgba(255, 0, 84, 0.2),
            inset 0 1px 0 rgba(255, 255, 255, 0.1);
        color: white;
        text-align: center;
        z-index: 401;
        animation: excavationHeaderPulse 3s ease-in-out infinite;
        display: flex;
        align-items: center;
        justify-content: space-between;
    }
    
    .excavation-info {
        flex: 1;
        text-align: center;
    }
    
    .excavation-toggle {
        width: 40px;
        height: 40px;
        background: rgba(255, 255, 255, 0.1);
        border: 1px solid rgba(255, 255, 255, 0.2);
        border-radius: var(--radius-full);
        color: white;
        cursor: pointer;
        display: flex;
        align-items: center;
        justify-content: center;
        transition: all var(--transition-normal);
        font-size: 16px;
        flex-shrink: 0;
    }
    
    .excavation-toggle:hover {
        background: rgba(255, 255, 255, 0.15);
        transform: scale(1.05);
    }
    
    .excavation-toggle:active {
        transform: scale(0.95);
    }
    
    .excavation-toggle.alerts-hidden {
        background: rgba(255, 69, 0, 0.3);
        border-color: rgba(255, 69, 0, 0.5);
    }
    
    .excavation-toggle.alerts-hidden:hover {
        background: rgba(255, 69, 0, 0.4);
    }
    
    @keyframes excavationHeaderPulse {
        0%, 100% {
            box-shadow: 
                0 8px 32px rgba(255, 0, 84, 0.2),
                inset 0 1px 0 rgba(255, 255, 255, 0.1);
        }
        50% {
            box-shadow: 
                0 12px 48px rgba(255, 0, 84, 0.4),
                inset 0 1px 0 rgba(255, 255, 255, 0.2);
        }
    }
    
    .excavation-header h2 {
        font-size: 18px;
        font-weight: 800;
        margin-bottom: 4px;
        text-transform: uppercase;
        letter-spacing: 1px;
        text-shadow: 0 0 15px rgba(255, 0, 84, 0.8);
        background: linear-gradient(135deg, #ffffff 0%, #ff0054 50%, #ffffff 100%);
        background-size: 200% 100%;
        -webkit-background-clip: text;
        background-clip: text;
        -webkit-text-fill-color: transparent;
        animation: headerShimmer 3s ease-in-out infinite;
    }
    
    @keyframes headerShimmer {
        0%, 100% { background-position: 200% center; }
        50% { background-position: 0% center; }
    }
    
    .excavation-header p {
        font-size: 12px;
        opacity: 0.9;
        font-weight: 600;
        color: rgba(255, 255, 255, 0.8);
    }
    
    /* Enhanced Utility Visibility During Excavation */
    .utility-line.excavation-enhanced {
        filter: drop-shadow(0 0 12px currentColor) drop-shadow(0 3px 16px rgba(0, 0, 0, 0.8)) !important;
        animation: excavationUtilityPulse 2.5s ease-in-out infinite;
    }
    
    .excavation-overlay.active ~ .app-container .structure-marker {
        filter: drop-shadow(0 0 12px currentColor) drop-shadow(0 4px 16px rgba(0, 0, 0, 0.6));
        transform: scale(1.2);
        animation: excavationStructurePulse 1.5s ease-in-out infinite;
    }
    
    @keyframes excavationUtilityPulse {
        0%, 100% {
            filter: drop-shadow(0 0 12px currentColor) drop-shadow(0 3px 16px rgba(0, 0, 0, 0.8));
        }
        50% {
            filter: drop-shadow(0 0 20px currentColor) drop-shadow(0 5px 24px rgba(0, 0, 0, 0.9));
        }
    }
    
    @keyframes excavationStructurePulse {
        0%, 100% {
            filter: drop-shadow(0 0 12px currentColor) drop-shadow(0 4px 16px rgba(0, 0, 0, 0.6));
            transform: scale(1.2);
        }
        50% {
            filter: drop-shadow(0 0 20px currentColor) drop-shadow(0 6px 24px rgba(0, 0, 0, 0.8));
            transform: scale(1.3);
        }
    }
    
    /* Premium Grid-Based Proximity Alerts for Excavation Mode */
    .proximity-alerts {
        position: absolute;
        top: calc(env(safe-area-inset-top, 0) + 100px);
        left: var(--spacing-md);
        right: var(--spacing-md);
        bottom: calc(env(safe-area-inset-bottom, 0) + 120px);
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(180px, 1fr));
        gap: var(--spacing-sm);
        z-index: 402;
        overflow-y: auto;
        pointer-events: none;
        transition: all var(--transition-normal);
        padding: var(--spacing-sm);
    }
    
    .proximity-alerts.hidden {
        opacity: 0;
        transform: translateY(-20px);
        pointer-events: none;
    }
    
    .proximity-alerts > * {
        pointer-events: auto;
    }
    
    .proximity-alert {
        background: rgba(255, 255, 255, 1.0);
        border-radius: var(--radius-lg);
        box-shadow: 
            0 8px 32px rgba(0, 0, 0, 0.2),
            0 4px 16px rgba(0, 0, 0, 0.1),
            0 2px 8px rgba(0, 0, 0, 0.05);
        overflow: hidden;
        animation: alertSlideIn var(--transition-bounce) ease-out;
        position: relative;
        border: 2px solid transparent;
        transform-origin: top center;
        transition: all var(--transition-normal);
        min-height: 140px;
        max-height: 180px;
        backdrop-filter: none;
        -webkit-backdrop-filter: none;
    }
    
    .proximity-alert.water { 
        border-color: var(--water-color);
    }
    .proximity-alert.gas { 
        border-color: var(--gas-color);
    }
    .proximity-alert.electric { 
        border-color: var(--electric-color);
    }
    .proximity-alert.sewer { 
        border-color: var(--sewer-color);
    }
    .proximity-alert.telecom { 
        border-color: var(--telecom-color);
    }
    
    @keyframes alertSlideIn {
        from {
            opacity: 0;
            transform: translateY(-20px) scale(0.95);
        }
        to {
            opacity: 1;
            transform: translateY(0) scale(1);
        }
    }
    
    .alert-content {
        padding: var(--spacing-md);
        position: relative;
        height: 100%;
        display: flex;
        flex-direction: column;
    }
    
    .alert-header {
        display: flex;
        align-items: center;
        justify-content: space-between;
        margin-bottom: var(--spacing-sm);
    }
    
    .alert-icon-container {
        width: 36px;
        height: 36px;
        border-radius: var(--radius-md);
        display: flex;
        align-items: center;
        justify-content: center;
        flex-shrink: 0;
    }
    
    .alert-icon-container.water { 
        background: rgba(0, 180, 216, 0.1);
        color: var(--water-color);
    }
    .alert-icon-container.gas { 
        background: rgba(255, 214, 10, 0.1);
        color: var(--gas-color);
    }
    .alert-icon-container.electric { 
        background: rgba(255, 0, 110, 0.1);
        color: var(--electric-color);
    }
    .alert-icon-container.sewer { 
        background: rgba(168, 118, 62, 0.1);
        color: var(--sewer-color);
    }
    .alert-icon-container.telecom { 
        background: rgba(181, 101, 216, 0.1);
        color: var(--telecom-color);
    }
    
    .alert-icon-container i {
        font-size: 18px;
    }
    
    .alert-close {
        width: 24px;
        height: 24px;
        border: none;
        background: rgba(0, 0, 0, 0.05);
        border-radius: var(--radius-full);
        display: flex;
        align-items: center;
        justify-content: center;
        cursor: pointer;
        transition: all var(--transition-normal);
        color: #666;
        font-size: 12px;
    }
    
    .alert-close:hover {
        background: rgba(0, 0, 0, 0.1);
        color: #333;
        transform: scale(1.1);
    }
    
    .alert-close:active {
        transform: scale(0.9);
    }
    
    .alert-utility-info {
        text-align: center;
        margin-bottom: var(--spacing-sm);
    }
    
    .alert-utility-type {
        font-size: 16px;
        font-weight: 800;
        color: #1a1a1a;
        text-transform: uppercase;
        letter-spacing: 0.5px;
        margin: 0 0 2px 0;
        line-height: 1;
    }
    
    .alert-line-type {
        font-size: 11px;
        color: #666;
        font-weight: 600;
        margin: 0;
        text-transform: uppercase;
        letter-spacing: 0.5px;
    }
    
    .alert-distance-banner {
        text-align: center;
        margin-bottom: var(--spacing-sm);
        padding: var(--spacing-sm);
        border-radius: var(--radius-md);
        background: rgba(0, 0, 0, 0.03);
    }
    
    .distance-value {
        display: block;
        font-size: 20px;
        font-weight: 900;
        line-height: 1;
        color: #d32f2f;
        margin-bottom: 2px;
    }
    
    .distance-unit {
        font-size: 10px;
        font-weight: 700;
        letter-spacing: 1px;
        text-transform: uppercase;
        color: #666;
    }
    
    .alert-details {
        flex: 1;
        display: flex;
        flex-direction: column;
        gap: var(--spacing-xs);
    }
    
    .detail-item {
        display: flex;
        justify-content: space-between;
        align-items: center;
        padding: 4px 0;
        border-bottom: 1px solid rgba(0, 0, 0, 0.05);
    }
    
    .detail-item:last-child {
        border-bottom: none;
    }
    
    .detail-label {
        font-size: 10px;
        font-weight: 600;
        color: #666;
        text-transform: uppercase;
        letter-spacing: 0.5px;
    }
    
    .detail-value {
        font-size: 11px;
        font-weight: 700;
        color: #1a1a1a;
        text-align: right;
    }
    
    /* Exit Excavation Button */
    .exit-excavation {
        position: absolute;
        bottom: calc(env(safe-area-inset-bottom, 0) + var(--spacing-xl));
        left: 50%;
        transform: translateX(-50%);
        padding: var(--spacing-md) var(--spacing-xl);
        background: white;
        color: var(--danger-color);
        border: none;
        border-radius: var(--radius-full);
        font-size: 16px;
        font-weight: 700;
        cursor: pointer;
        box-shadow: var(--shadow-xl);
        transition: all var(--transition-spring);
        z-index: 403;
    }
    
    .exit-excavation:active {
        transform: translateX(-50%) scale(0.95);
    }
    
    /* Settings Panel - Premium Slide */
    .settings-panel {
        position: fixed;
        top: 0;
        right: -100%;
        bottom: 0;
        width: 85%;
        max-width: 380px;
        background: var(--bg-primary);
        box-shadow: -8px 0 32px var(--shadow-xl);
        z-index: 500;
        transition: right var(--transition-spring);
        overflow-y: auto;
        padding-top: env(safe-area-inset-top, 0);
    }
    
    .settings-panel.active {
        right: 0;
    }
    
    .settings-header {
        padding: var(--spacing-lg);
        border-bottom: 1px solid var(--border-color);
        display: flex;
        align-items: center;
        justify-content: space-between;
    }
    
    .settings-header h2 {
        font-size: 24px;
        font-weight: 800;
        background: var(--gradient-primary);
        -webkit-background-clip: text;
        background-clip: text;
        -webkit-text-fill-color: transparent;
    }
    
    .settings-section {
        padding: var(--spacing-lg);
        border-bottom: 1px solid var(--border-color);
    }
    
    .settings-section h3 {
        font-size: 12px;
        font-weight: 700;
        color: var(--text-secondary);
        margin-bottom: var(--spacing-lg);
        text-transform: uppercase;
        letter-spacing: 1px;
    }
    
    /* Premium Toggle Switch */
    .toggle-item {
        display: flex;
        align-items: center;
        justify-content: space-between;
        margin-bottom: var(--spacing-md);
    }
    
    .toggle-label {
        display: flex;
        align-items: center;
        gap: var(--spacing-sm);
        font-size: 14px;
        font-weight: 600;
    }
    
    .toggle-switch {
        position: relative;
        width: 56px;
        height: 32px;
        border: none;
        background: var(--bg-tertiary);
        border-radius: var(--radius-full);
        cursor: pointer;
        transition: all var(--transition-normal);
    }
    
    .toggle-switch.active {
        background: var(--gradient-success);
    }
    
    .toggle-switch::after {
        content: '';
        position: absolute;
        top: 4px;
        left: 4px;
        width: 24px;
        height: 24px;
        background: white;
        border-radius: var(--radius-full);
        transition: all var(--transition-spring);
        box-shadow: var(--shadow-sm);
    }
    
    .toggle-switch.active::after {
        transform: translateX(24px);
    }
    
    /* Map Style Selector */
    .map-styles {
        display: grid;
        grid-template-columns: repeat(2, 1fr);
        gap: var(--spacing-sm);
    }
    
    .map-style-btn {
        padding: var(--spacing-md);
        border: 2px solid var(--border-color);
        background: var(--bg-secondary);
        border-radius: var(--radius-md);
        cursor: pointer;
        transition: all var(--transition-normal);
        text-align: center;
        font-size: 14px;
        font-weight: 600;
    }
    
    .map-style-btn.active {
        border-color: transparent;
        background: var(--gradient-primary);
        color: white;
        box-shadow: var(--shadow-md);
    }
    
    /* Utility Line Styles */
    .utility-line {
        stroke-width: 6;
        stroke-linecap: round;
        stroke-linejoin: round;
        fill: none;
        cursor: pointer;
        filter: drop-shadow(0 2px 8px rgba(0, 0, 0, 0.3));
        transition: all var(--transition-normal), opacity 0.3s ease-in-out;
    }
    
    .utility-line:hover {
        filter: drop-shadow(0 4px 16px rgba(0, 0, 0, 0.4)) drop-shadow(0 0 12px currentColor);
        stroke-width: 8 !important;
    }
    
    .utility-line.main {
        stroke-width: 8;
        filter: drop-shadow(0 3px 12px rgba(0, 0, 0, 0.4));
    }
    
    .utility-line.main:hover {
        stroke-width: 10 !important;
    }
    
    .utility-line.service {
        stroke-width: 6;
        stroke-dasharray: 15, 5;
        filter: drop-shadow(0 2px 8px rgba(0, 0, 0, 0.3));
    }
    
    .utility-line.water { 
        stroke: var(--water-color); 
        filter: drop-shadow(0 2px 8px rgba(0, 0, 0, 0.3)) drop-shadow(0 0 8px rgba(0, 180, 216, 0.3));
    }
    .utility-line.gas { 
        stroke: var(--gas-color); 
        filter: drop-shadow(0 2px 8px rgba(0, 0, 0, 0.3)) drop-shadow(0 0 8px rgba(255, 214, 10, 0.3));
    }
    .utility-line.electric { 
        stroke: var(--electric-color); 
        filter: drop-shadow(0 2px 8px rgba(0, 0, 0, 0.3)) drop-shadow(0 0 8px rgba(255, 0, 110, 0.3));
    }
    .utility-line.sewer { 
        stroke: var(--sewer-color); 
        filter: drop-shadow(0 2px 8px rgba(0, 0, 0, 0.3)) drop-shadow(0 0 8px rgba(168, 118, 62, 0.3));
    }
    .utility-line.telecom { 
        stroke: var(--telecom-color); 
        filter: drop-shadow(0 2px 8px rgba(0, 0, 0, 0.3)) drop-shadow(0 0 8px rgba(181, 101, 216, 0.3));
    }
    
    .utility-line.drawing {
        opacity: 0.7;
        animation: drawingPulse 1.5s ease-in-out infinite;
    }
    
    .utility-line.highlighted {
        filter: drop-shadow(0 0 20px currentColor) drop-shadow(0 4px 16px rgba(0, 0, 0, 0.5));
        stroke-width: 12 !important;
        opacity: 1 !important;
        animation: highlightGlow 2s ease-in-out infinite;
    }
    
    @keyframes drawingPulse {
        0%, 100% { 
            opacity: 0.5; 
            stroke-width: 6;
            filter: drop-shadow(0 2px 8px rgba(0, 0, 0, 0.3));
        }
        50% { 
            opacity: 1; 
            stroke-width: 8;
            filter: drop-shadow(0 4px 12px rgba(0, 0, 0, 0.4)) drop-shadow(0 0 12px currentColor);
        }
    }
    
    @keyframes highlightGlow {
        0%, 100% { 
            filter: drop-shadow(0 0 20px currentColor) drop-shadow(0 4px 16px rgba(0, 0, 0, 0.5));
        }
        50% { 
            filter: drop-shadow(0 0 30px currentColor) drop-shadow(0 6px 20px rgba(0, 0, 0, 0.6));
        }
    }
    
    /* Connection Markers */
    .connection-marker {
        fill: white;
        stroke-width: 3;
        cursor: pointer;
        filter: drop-shadow(0 2px 8px rgba(0, 0, 0, 0.4));
        transition: opacity 0.3s ease-in-out;
    }
    
    .connection-marker.t-junction {
        r: 10;
    }
    
    .connection-marker.endpoint {
        r: 8;
    }
    
    .connection-marker.structure {
        r: 12;
    }
    
    .connection-marker.water { stroke: var(--water-color); }
    .connection-marker.gas { stroke: var(--gas-color); }
    .connection-marker.electric { stroke: var(--electric-color); }
    .connection-marker.sewer { stroke: var(--sewer-color); }
    .connection-marker.telecom { stroke: var(--telecom-color); }
    
    /* Refine Points - Enhanced for Leaflet CircleMarkers */
    .leaflet-interactive {
        cursor: pointer;
    }
    
    .leaflet-interactive[style*="cursor: move"] {
        cursor: move !important;
    }
    
    /* Ensure refine markers are always visible and interactive */
    .leaflet-zoom-animated .leaflet-interactive {
        pointer-events: auto !important;
    }
    
    /* Legacy CSS for any SVG-based refine points */
    /* Premium Refine Mode Styles - Completely Redesigned */
    .refine-marker {
        background: transparent !important;
        border: none !important;
        box-shadow: none !important;
    }
    
    .refine-point {
        width: 40px;
        height: 40px;
        background: linear-gradient(135deg, #ffffff 0%, #f0f8ff 100%);
        border: 4px solid #667eea;
        border-radius: 50%;
        cursor: move !important;
        box-shadow: 
            0 8px 32px rgba(102, 126, 234, 0.4), 
            0 0 0 2px rgba(255, 255, 255, 0.9),
            inset 0 2px 4px rgba(255, 255, 255, 0.5);
        transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
        position: relative;
        z-index: 10000 !important;
        display: flex !important;
        align-items: center;
        justify-content: center;
        font-weight: bold;
        color: #667eea;
        font-size: 16px;
        pointer-events: auto !important;
        user-select: none;
        animation: refinePointPulse 3s ease-in-out infinite;
    }
    
    .refine-point:before {
        content: '';
        position: absolute;
        inset: -6px;
        border-radius: 50%;
        background: conic-gradient(from 0deg, transparent, rgba(102, 126, 234, 0.3), transparent);
        animation: refinePointSpin 4s linear infinite;
        z-index: -1;
    }
    
    .refine-point.dragging {
        transform: scale(1.3) !important;
        border-color: #00f5a0;
        background: linear-gradient(135deg, #f0fff0 0%, #e6ffe6 100%);
        color: #00f5a0;
        box-shadow: 
            0 12px 48px rgba(0, 245, 160, 0.6), 
            0 0 0 3px rgba(255, 255, 255, 1),
            inset 0 2px 4px rgba(255, 255, 255, 0.7);
    }
    
    .refine-point.intermediate {
        animation: intermediateGlow 2s ease-in-out infinite;
        opacity: 0.8;
        border-width: 3px;
    }
    
    .refine-point.intermediate:hover {
        transform: scale(1.2) !important;
        opacity: 1;
        box-shadow: 
            0 6px 24px rgba(77, 148, 255, 0.6), 
            0 0 0 2px rgba(255, 255, 255, 1),
            inset 0 2px 4px rgba(255, 255, 255, 0.6);
    }
    
    @keyframes intermediateGlow {
        0%, 100% {
            box-shadow: 
                0 4px 16px rgba(77, 148, 255, 0.3), 
                0 0 0 1px rgba(255, 255, 255, 0.8),
                inset 0 2px 4px rgba(255, 255, 255, 0.4);
        }
        50% {
            box-shadow: 
                0 6px 20px rgba(77, 148, 255, 0.5), 
                0 0 0 2px rgba(255, 255, 255, 0.9),
                inset 0 2px 4px rgba(255, 255, 255, 0.5);
        }
    }
    
    @keyframes refinePointPulse {
        0%, 100% {
            transform: scale(1);
            opacity: 1;
        }
        50% {
            transform: scale(1.05);
            opacity: 0.95;
        }
    }
    
    @keyframes refinePointSpin {
        from { transform: rotate(0deg); }
        to { transform: rotate(360deg); }
    }
    
    /* Connection Dialog - Premium */
    .connection-dialog {
        position: fixed;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%) scale(0.9);
        background: var(--bg-glass);
        backdrop-filter: blur(30px) saturate(180%);
        -webkit-backdrop-filter: blur(30px) saturate(180%);
        border-radius: var(--radius-xl);
        padding: var(--spacing-xl);
        box-shadow: var(--shadow-xl);
        z-index: 600;
        min-width: 320px;
        opacity: 0;
        pointer-events: none;
        transition: all var(--transition-spring);
        border: 1px solid var(--border-color);
    }
    
    .connection-dialog.active {
        opacity: 1;
        transform: translate(-50%, -50%) scale(1);
        pointer-events: auto;
    }
    
    .connection-dialog h3 {
        font-size: 20px;
        font-weight: 700;
        margin-bottom: var(--spacing-md);
        text-align: center;
        background: var(--gradient-primary);
        -webkit-background-clip: text;
        background-clip: text;
        -webkit-text-fill-color: transparent;
    }
    
    .connection-dialog p {
        font-size: 14px;
        color: var(--text-secondary);
        margin-bottom: var(--spacing-lg);
        text-align: center;
        line-height: 1.5;
    }
    
    .connection-actions {
        display: flex;
        gap: var(--spacing-sm);
        justify-content: center;
    }
    
    /* Structure Markers - Premium Icons */
    .structure-marker {
        width: 48px;
        height: 48px;
        background: var(--bg-glass);
        backdrop-filter: blur(20px);
        border: 3px solid;
        border-radius: var(--radius-md);
        display: flex;
        align-items: center;
        justify-content: center;
        font-size: 20px;
        box-shadow: var(--shadow-lg);
        cursor: pointer;
        transition: all var(--transition-spring), opacity 0.3s ease-in-out;
    }
    
    .structure-marker.water { 
        border-color: var(--water-color); 
        color: var(--water-color); 
    }
    .structure-marker.gas { 
        border-color: var(--gas-color); 
        color: var(--gas-color); 
    }
    .structure-marker.electric { 
        border-color: var(--electric-color); 
        color: var(--electric-color); 
    }
    .structure-marker.sewer { 
        border-color: var(--sewer-color); 
        color: var(--sewer-color); 
    }
    .structure-marker.telecom { 
        border-color: var(--telecom-color); 
        color: var(--telecom-color); 
    }
    
    .structure-marker:hover {
        transform: scale(1.1);
        box-shadow: var(--shadow-xl), 0 0 20px currentColor;
    }
    
    /* Structure Container */
    .structure-container {
        position: absolute;
        right: var(--spacing-md);
        bottom: calc(env(safe-area-inset-bottom, 0) + 160px);
        z-index: 95;
    }
    
    /* Add Structure Button - Compact Premium Design */
    .add-structure-btn {
        position: relative;
        width: 48px;
        height: 48px;
        background: var(--gradient-success);
        border: none;
        border-radius: var(--radius-full);
        display: flex;
        align-items: center;
        justify-content: center;
        box-shadow: var(--shadow-lg), 0 0 20px rgba(0, 245, 160, 0.4);
        cursor: pointer;
        transition: all var(--transition-spring);
    }
    
    .add-structure-btn:hover {
        transform: translateY(-2px) scale(1.05);
        box-shadow: var(--shadow-xl), 0 0 25px rgba(0, 245, 160, 0.5);
    }
    
    .add-structure-btn:active {
        transform: scale(0.9);
    }
    
    .add-structure-btn i {
        font-size: 20px;
        color: white;
    }
    
    .add-structure-btn.active {
        background: var(--gradient-warning);
        animation: structurePlacementPulse 2s ease-in-out infinite;
    }
    
    @keyframes structurePlacementPulse {
        0%, 100% { 
            box-shadow: var(--shadow-lg), 0 0 20px rgba(255, 214, 10, 0.4);
        }
        50% { 
            box-shadow: var(--shadow-xl), 0 0 30px rgba(255, 214, 10, 0.7);
        }
    }
    
    /* Structure Menu - Compact Premium Grid */
    .structure-menu {
        position: absolute;
        bottom: 60px;
        right: 0;
        background: var(--bg-glass);
        backdrop-filter: blur(30px) saturate(180%);
        -webkit-backdrop-filter: blur(30px) saturate(180%);
        border-radius: var(--radius-xl);
        box-shadow: var(--shadow-xl);
        padding: var(--spacing-md);
        display: none;
        grid-template-columns: repeat(2, 1fr);
        gap: var(--spacing-sm);
        width: 280px;
        border: 1px solid var(--border-color);
        z-index: 1000;
        max-height: 350px;
        overflow-y: auto;
    }
    
    .structure-menu.active {
        display: grid !important;
        animation: menuPopIn var(--transition-bounce) ease-out;
    }
    
    @keyframes menuPopIn {
        from {
            opacity: 0;
            transform: scale(0.8) translateY(20px);
        }
        to {
            opacity: 1;
            transform: scale(1) translateY(0);
        }
    }
    
    .structure-type-btn {
        display: flex;
        flex-direction: column;
        align-items: center;
        gap: var(--spacing-xs);
        padding: var(--spacing-sm);
        background: var(--bg-glass-light);
        border: 1px solid var(--border-color);
        border-radius: var(--radius-md);
        cursor: pointer;
        transition: all var(--transition-normal);
        min-height: 60px;
    }
    
    .structure-type-btn:hover {
        background: var(--bg-tertiary);
        transform: translateY(-2px);
        box-shadow: var(--shadow-md);
    }
    
    .structure-type-btn:active {
        transform: scale(0.95);
    }
    
    .structure-type-btn i {
        font-size: 22px;
    }
    
    .structure-type-btn span {
        font-size: 10px;
        font-weight: 600;
        text-align: center;
        line-height: 1.2;
    }
    
    /* Toast Notifications - Premium */
    .toast-container {
        position: fixed;
        top: calc(env(safe-area-inset-top, 0) + var(--spacing-md));
        left: var(--spacing-md);
        right: var(--spacing-md);
        z-index: 1000;
        pointer-events: none;
    }
    
    .toast {
        background: var(--bg-glass);
        backdrop-filter: blur(30px) saturate(180%);
        -webkit-backdrop-filter: blur(30px) saturate(180%);
        border-radius: var(--radius-md);
        padding: var(--spacing-md) var(--spacing-lg);
        box-shadow: var(--shadow-xl);
        margin-bottom: var(--spacing-sm);
        display: flex;
        align-items: center;
        gap: var(--spacing-md);
        opacity: 0;
        transform: translateY(-20px) scale(0.9);
        transition: all var(--transition-spring);
        pointer-events: auto;
        border: 1px solid var(--border-color);
    }
    
    .toast.show {
        opacity: 1;
        transform: translateY(0) scale(1);
    }
    
    .toast i {
        font-size: 24px;
        filter: drop-shadow(0 0 8px currentColor);
    }
    
    .toast span {
        font-weight: 600;
        font-size: 14px;
    }
    
    .toast.success i { color: var(--success-color); }
    .toast.error i { color: var(--danger-color); }
    .toast.warning i { color: var(--warning-color); }
    .toast.info i { color: var(--info-color); }
    
    /* Measurement Display */
    .measurement-display {
        position: absolute;
        background: var(--bg-glass);
        backdrop-filter: blur(30px) saturate(180%);
        -webkit-backdrop-filter: blur(30px) saturate(180%);
        border-radius: var(--radius-md);
        padding: var(--spacing-sm) var(--spacing-md);
        box-shadow: var(--shadow-lg);
        font-size: 14px;
        font-weight: 700;
        pointer-events: none;
        z-index: 200;
        border: 1px solid var(--border-color);
        color: var(--text-primary);
    }
    
    /* Notes Section */
    .notes-section {
        margin-top: var(--spacing-lg);
        padding-top: var(--spacing-lg);
        border-top: 1px solid var(--border-color);
    }
    
    .notes-header {
        display: flex;
        align-items: center;
        justify-content: space-between;
        margin-bottom: var(--spacing-md);
    }
    
    .notes-title {
        font-size: 16px;
        font-weight: 600;
    }
    
    .add-note-btn {
        padding: var(--spacing-sm) var(--spacing-md);
        background: var(--bg-glass-light);
        border: 1px solid var(--border-color);
        border-radius: var(--radius-md);
        font-size: 14px;
        font-weight: 600;
        cursor: pointer;
        display: flex;
        align-items: center;
        gap: var(--spacing-xs);
        transition: all var(--transition-normal);
    }
    
    .add-note-btn:active {
        transform: scale(0.95);
    }
    
    .notes-list {
        display: flex;
        flex-direction: column;
        gap: var(--spacing-sm);
    }
    
    .note-item {
        background: var(--bg-glass-light);
        padding: var(--spacing-md);
        border-radius: var(--radius-md);
        position: relative;
        border: 1px solid var(--border-color);
    }
    
    .note-text {
        font-size: 14px;
        line-height: 1.5;
        margin-bottom: var(--spacing-xs);
    }
    
    .note-date {
        font-size: 12px;
        color: var(--text-tertiary);
    }
    
    .note-delete {
        position: absolute;
        top: var(--spacing-sm);
        right: var(--spacing-sm);
        width: 24px;
        height: 24px;
        background: transparent;
        border: none;
        cursor: pointer;
        color: var(--text-tertiary);
        transition: all var(--transition-normal);
    }
    
    .note-delete:hover {
        color: var(--danger-color);
    }
    
    /* Cloud Sync Status */
    .sync-status {
        position: fixed;
        bottom: calc(env(safe-area-inset-bottom, 0) + var(--spacing-md));
        left: 50%;
        transform: translateX(-50%);
        background: var(--bg-glass);
        backdrop-filter: blur(30px) saturate(180%);
        -webkit-backdrop-filter: blur(30px) saturate(180%);
        border-radius: var(--radius-full);
        padding: var(--spacing-sm) var(--spacing-lg);
        box-shadow: var(--shadow-md);
        font-size: 12px;
        font-weight: 600;
        display: flex;
        align-items: center;
        gap: var(--spacing-sm);
        opacity: 0;
        pointer-events: none;
        transition: all var(--transition-normal);
        border: 1px solid var(--border-color);
    }
    
    .sync-status.show {
        opacity: 1;
    }
    
    .sync-status i {
        font-size: 14px;
        color: var(--info-color);
        animation: syncSpin 2s linear infinite;
    }
    
    @keyframes syncSpin {
        from { transform: rotate(0deg); }
        to { transform: rotate(360deg); }
    }
    
    /* Note Input Modal */
    .note-input-modal {
        position: fixed;
        inset: 0;
        background: rgba(0, 0, 0, 0.8);
        display: flex;
        align-items: center;
        justify-content: center;
        z-index: 650;
        opacity: 0;
        pointer-events: none;
        transition: opacity var(--transition-normal);
        padding: var(--spacing-lg);
    }
    
    .note-input-modal.active {
        opacity: 1;
        pointer-events: auto;
    }
    
    .note-input-content {
        background: var(--bg-glass);
        backdrop-filter: blur(30px) saturate(180%);
        -webkit-backdrop-filter: blur(30px) saturate(180%);
        border-radius: var(--radius-xl);
        padding: var(--spacing-xl);
        box-shadow: var(--shadow-xl);
        width: 100%;
        max-width: 400px;
        border: 1px solid var(--border-color);
    }
    
    .note-input-header {
        font-size: 18px;
        font-weight: 700;
        margin-bottom: var(--spacing-lg);
        background: var(--gradient-primary);
        -webkit-background-clip: text;
        background-clip: text;
        -webkit-text-fill-color: transparent;
    }
    
    .note-textarea {
        width: 100%;
        min-height: 120px;
        padding: var(--spacing-md);
        border: 2px solid var(--border-color);
        border-radius: var(--radius-md);
        background: var(--bg-glass-light);
        color: var(--text-primary);
        font-size: 14px;
        font-family: inherit;
        resize: vertical;
        transition: all var(--transition-normal);
    }
    
    .note-textarea:focus {
        outline: none;
        border-color: #667eea;
        background: var(--bg-secondary);
    }
    
    .note-input-actions {
        display: flex;
        gap: var(--spacing-sm);
        margin-top: var(--spacing-lg);
    }
    
    /* Responsive adjustments */
    @media (min-width: 768px) {
        .bottom-controls {
            max-width: 640px;
            left: 50%;
            transform: translateX(-50%);
        }
        
        .proximity-alerts {
            grid-template-columns: repeat(auto-fit, minmax(160px, 1fr));
        }
        
        .structure-menu {
            width: 360px;
        }
    }
    
    @media (min-width: 1024px) {
        .proximity-alerts {
            grid-template-columns: repeat(auto-fit, minmax(140px, 1fr));
        }
    }
    
    @media (max-width: 480px) {
        .proximity-alerts {
            grid-template-columns: repeat(auto-fit, minmax(140px, 1fr));
        }
        
        .proximity-alert {
            min-height: 120px;
            max-height: 160px;
        }
        
        .alert-content {
            padding: 10px;
        }
        
        .alert-utility-type {
            font-size: 14px;
        }
        
        .distance-value {
            font-size: 18px;
        }
    }
    
    /* Prevent selection and zoom */
    * {
        -webkit-touch-callout: none;
        -webkit-user-select: none;
        -khtml-user-select: none;
        -moz-user-select: none;
        -ms-user-select: none;
        user-select: none;
        -webkit-tap-highlight-color: transparent;
    }
    
    input, textarea {
        -webkit-user-select: text;
        -khtml-user-select: text;
        -moz-user-select: text;
        -ms-user-select: text;
        user-select: text;
    }
    
    /* Enhanced touch interactions */
    button, .control-btn, .utility-btn {
        touch-action: manipulation;
        -webkit-tap-highlight-color: transparent;
    }
    
    /* Focus management for accessibility */
    button:focus-visible,
    .control-btn:focus-visible,
    .utility-btn:focus-visible {
        outline: 3px solid var(--info-color);
        outline-offset: 2px;
    }
    
    .form-input:focus-visible {
        outline: 3px solid var(--info-color);
        outline-offset: 2px;
    }
    
    /* Improve accessibility */
    @media (prefers-reduced-motion: reduce) {
        *, *::before, *::after {
            animation-duration: 0.01ms !important;
            animation-iteration-count: 1 !important;
            transition-duration: 0.01ms !important;
        }
    }
    
    /* High contrast mode support */
    @media (prefers-contrast: high) {
        :root {
            --border-color: rgba(255, 255, 255, 0.3);
            --text-secondary: #cccccc;
        }
    }
    
    /* Premium glassmorphism enhancement */
    @supports (backdrop-filter: blur(20px)) {
        .utility-selector,
        .control-btn,
        .info-modal,
        .settings-panel,
        .drawing-ui,
        .refine-overlay {
            backdrop-filter: blur(20px) saturate(180%);
            -webkit-backdrop-filter: blur(20px) saturate(180%);
        }
    }
</style>

</head>
<body>
    <!-- Ultra Premium Complex Splash Screen -->
    <div class="splash-screen" id="splash">
        <!-- Floating Particles Background -->
        <div class="splash-particles">
            <div class="particle"></div>
            <div class="particle"></div>
            <div class="particle"></div>
            <div class="particle"></div>
            <div class="particle"></div>
            <div class="particle"></div>
            <div class="particle"></div>
            <div class="particle"></div>
            <div class="particle"></div>
            <div class="particle"></div>
        </div>
        
        <!-- Premium Logo with Rotating Rings -->
        <div class="splash-logo-container">
            <div class="logo-outer-ring"></div>
            <div class="logo-inner-ring"></div>
            <div class="splash-logo">
                <div class="logo-hexagon">
                    <div class="hex-inner">
                        <div class="logo-content">
                            <div class="logo-grid">
                                <div class="logo-dot"></div>
                                <div class="logo-dot"></div>
                                <div class="logo-dot"></div>
                                <div class="logo-dot"></div>
                                <div class="logo-dot"></div>
                                <div class="logo-dot"></div>
                                <div class="logo-dot"></div>
                                <div class="logo-dot"></div>
                                <div class="logo-dot"></div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
        
        <!-- Enhanced Typography -->
        <h1 class="splash-title">CAC Utili-Track</h1>
        <p class="splash-subtitle">Professional Mapping System</p>
        
        <!-- Premium Progress System -->
        <div class="splash-loader"></div>
        <div class="splash-progress" id="splashProgress">0%</div>
    </div>

<!-- Main App Container -->
<div class="app-container">
    <!-- Map -->
    <div id="map"></div>

    <!-- Top Bar -->
    <div class="top-bar">
        <div class="utility-selector" role="toolbar" aria-label="Utility type selector">
            <button class="utility-btn water active" data-utility="water" aria-label="Select water utilities" aria-pressed="true">
                <i class="fas fa-tint" aria-hidden="true"></i>
            </button>
            <button class="utility-btn gas" data-utility="gas" aria-label="Select gas utilities" aria-pressed="false">
                <i class="fas fa-fire" aria-hidden="true"></i>
            </button>
            <button class="utility-btn electric" data-utility="electric" aria-label="Select electric utilities" aria-pressed="false">
                <i class="fas fa-bolt" aria-hidden="true"></i>
            </button>
            <button class="utility-btn sewer" data-utility="sewer" aria-label="Select sewer utilities" aria-pressed="false">
                <i class="fas fa-toilet" aria-hidden="true"></i>
            </button>
            <button class="utility-btn telecom" data-utility="telecom" aria-label="Select telecom utilities" aria-pressed="false">
                <i class="fas fa-phone" aria-hidden="true"></i>
            </button>
        </div>
    </div>

    <!-- Measurement Tools -->
    <div class="measurement-tools">
        <button class="measurement-btn" id="measureDistanceBtn" title="Measure Distance">
            <i class="fas fa-ruler"></i>
        </button>
        <button class="measurement-btn" id="measureAreaBtn" title="Measure Area">
            <i class="fas fa-vector-square"></i>
        </button>
    </div>

    <!-- Bottom Controls -->
    <div class="bottom-controls">
        <div class="control-group">
            <button class="control-btn" id="locateBtn">
                <i class="fas fa-location-crosshairs"></i>
            </button>
            <button class="control-btn" id="layersBtn">
                <i class="fas fa-layer-group"></i>
            </button>
        </div>

        <div class="control-group center">
            <div class="main-action-group">
                <button class="main-action-btn" id="drawBtn">
                    <i class="fas fa-pencil-alt"></i>
                </button>
                <div class="line-type-toggle">
                    <button class="line-type-btn active" data-type="service">Service</button>
                    <button class="line-type-btn" data-type="main">Main</button>
                </div>
            </div>
        </div>

        <div class="control-group">
            <button class="control-btn excavation-btn" id="excavationBtn">
                <i class="fas fa-hard-hat"></i>
            </button>
            <button class="control-btn" id="settingsBtn">
                <i class="fas fa-cog"></i>
            </button>
        </div>
    </div>

    <!-- Right Side Controls -->
    <div class="right-controls">
        <button class="control-btn" id="zoomInBtn">
            <i class="fas fa-plus"></i>
        </button>
        <button class="control-btn" id="zoomOutBtn">
            <i class="fas fa-minus"></i>
        </button>
    </div>

    <!-- Add Structure Button -->
    <div class="structure-container">
    <button class="add-structure-btn" id="addStructureBtn">
        <i class="fas fa-plus"></i>
        </button>
        <div class="structure-menu" id="structureMenu">
            <button class="structure-type-btn" data-structure="electricBox" data-utility="electric">
                <i class="fas fa-bolt"></i>
                <span>Elec Box</span>
            </button>
            <button class="structure-type-btn" data-structure="catchBasin" data-utility="sewer">
                <i class="fas fa-water"></i>
                <span>Catch Basin</span>
            </button>
            <button class="structure-type-btn" data-structure="sewerManhole" data-utility="sewer">
                <i class="fas fa-circle"></i>
                <span>Sewer MH</span>
            </button>
            <button class="structure-type-btn" data-structure="waterManhole" data-utility="water">
                <i class="fas fa-tint"></i>
                <span>Water MH</span>
            </button>
            <button class="structure-type-btn" data-structure="gasManhole" data-utility="gas">
                <i class="fas fa-fire"></i>
                <span>Gas MH</span>
            </button>
            <button class="structure-type-btn" data-structure="gasValve" data-utility="gas">
                <i class="fas fa-wrench"></i>
                <span>Gas Valve</span>
            </button>
            <button class="structure-type-btn" data-structure="hydrantValve" data-utility="water">
                <i class="fas fa-fire-extinguisher"></i>
                <span>Hydrant</span>
            </button>
            <button class="structure-type-btn" data-structure="telecomBox" data-utility="telecom">
                <i class="fas fa-network-wired"></i>
                <span>Telecom</span>
            </button>
        </div>
    </div>

    <!-- Drawing UI -->
    <div class="drawing-ui" id="drawingUI">
        <h3>Drawing Utility Line</h3>
        <p id="drawingStatus">Click points on the map</p>
        <div class="drawing-actions">
            <button class="drawing-btn secondary" id="cancelDrawBtn">Cancel</button>
            <button class="drawing-btn primary" id="finishDrawBtn" style="display: none;">Finish</button>
        </div>
    </div>

    <!-- Refine Mode Overlay -->
    <div class="refine-overlay" id="refineOverlay">
        <span>🎯 Drag points to refine location</span>
        <button class="drawing-btn primary" id="finishRefineBtn">
            <i class="fas fa-check"></i> Finish Refining
        </button>
    </div>

    <!-- Utility Info Modal -->
    <div class="info-modal" id="infoModal">
        <div class="modal-handle"></div>
        <div class="modal-header">
            <div class="modal-title">
                <i class="fas fa-tint" id="modalIcon"></i>
                <span id="modalTitle">Utility Information</span>
            </div>
            <button class="modal-close" id="closeModalBtn">
                <i class="fas fa-times"></i>
            </button>
        </div>
        <div class="modal-body">
            <!-- View Mode -->
            <div id="viewMode">
                <div class="info-grid">
                    <div class="info-item">
                        <span class="info-label">Type</span>
                        <span class="info-value" id="infoType">-</span>
                    </div>
                    <div class="info-item">
                        <span class="info-label">Line Type</span>
                        <span class="info-value" id="infoLineType">-</span>
                    </div>
                    <div class="info-item">
                        <span class="info-label">Size</span>
                        <span class="info-value" id="infoSize">-</span>
                    </div>
                    <div class="info-item">
                        <span class="info-label">Depth</span>
                        <span class="info-value" id="infoDepth">-</span>
                    </div>
                    <div class="info-item">
                        <span class="info-label">Material</span>
                        <span class="info-value" id="infoMaterial">-</span>
                    </div>
                    <div class="info-item">
                        <span class="info-label">Condition</span>
                        <span class="info-value" id="infoCondition">-</span>
                    </div>
                    <div class="info-item">
                        <span class="info-label">Distance from Curb</span>
                        <span class="info-value" id="infoCurbDistance">-</span>
                    </div>
                    <div class="info-item">
                        <span class="info-label">Date Added</span>
                        <span class="info-value" id="infoDate">-</span>
                    </div>
                </div>
                
                <!-- Notes Section -->
                <div class="notes-section">
                    <div class="notes-header">
                        <h3 class="notes-title">Notes</h3>
                        <button class="add-note-btn" id="addNoteBtn">
                            <i class="fas fa-plus"></i>
                            Add Note
                        </button>
                    </div>
                    <div class="notes-list" id="notesList"></div>
                </div>
                
                <div class="modal-actions">
                    <button class="modal-btn primary" id="editBtn">
                        <i class="fas fa-edit"></i>
                        Edit
                    </button>
                    <button class="modal-btn primary" id="refineBtn">
                        <i class="fas fa-crosshairs"></i>
                        Refine Location
                    </button>
                    <button class="modal-btn danger" id="deleteBtn">
                        <i class="fas fa-trash"></i>
                        Delete
                    </button>
                </div>
            </div>

            <!-- Edit Mode -->
            <div class="edit-form" id="editMode">
                <div class="form-group">
                    <label class="form-label">Size (inches)</label>
                    <input type="number" class="form-input" id="editSize" placeholder="e.g., 4">
                </div>
                <div class="form-group">
                    <label class="form-label">Depth (feet)</label>
                    <input type="number" class="form-input" id="editDepth" placeholder="e.g., 3">
                </div>
                <div class="form-group">
                    <label class="form-label">Material</label>
                    <select class="form-input form-select" id="editMaterial">
                        <option value="">Not specified</option>
                        <option value="PVC">PVC</option>
                        <option value="Cast Iron">Cast Iron</option>
                        <option value="Copper">Copper</option>
                        <option value="Steel">Steel</option>
                        <option value="HDPE">HDPE</option>
                        <option value="Concrete">Concrete</option>
                        <option value="Clay">Clay</option>
                    </select>
                </div>
                <div class="form-group">
                    <label class="form-label">Condition</label>
                    <select class="form-input form-select" id="editCondition">
                        <option value="">Not specified</option>
                        <option value="Excellent">Excellent</option>
                        <option value="Good">Good</option>
                        <option value="Fair">Fair</option>
                        <option value="Poor">Poor</option>
                        <option value="Critical">Critical</option>
                    </select>
                </div>
                <div class="form-group">
                    <label class="form-label">Distance from Curb (feet)</label>
                    <input type="number" class="form-input" id="editCurbDistance" placeholder="e.g., 6">
                </div>
                <div class="modal-actions">
                    <button class="modal-btn secondary" id="cancelEditBtn">
                        Cancel
                    </button>
                    <button class="modal-btn primary" id="saveEditBtn">
                        <i class="fas fa-save"></i>
                        Save
                    </button>
                </div>
            </div>
        </div>
    </div>

    <!-- Excavation Mode Overlay -->
    <div class="excavation-overlay" id="excavationOverlay">
        <div class="excavation-radar">
            <div class="radar-ring"></div>
            <div class="radar-ring"></div>
            <div class="radar-ring"></div>
        </div>
        <div class="excavation-header">
            <div class="excavation-info">
            <h2>EXCAVATION MODE ACTIVE</h2>
            <p>Monitoring utility proximity within 15 feet</p>
            </div>
            <button class="excavation-toggle" id="alertToggleBtn" title="Toggle proximity alerts">
                <i class="fas fa-eye"></i>
            </button>
        </div>
        <div class="proximity-alerts" id="proximityAlerts"></div>
        <button class="exit-excavation" id="exitExcavationBtn">Exit Excavation Mode</button>
    </div>

    <!-- Settings Panel -->
    <div class="settings-panel" id="settingsPanel">
        <div class="settings-header">
            <h2>Settings</h2>
            <button class="modal-close" id="closeSettingsBtn">
                <i class="fas fa-times"></i>
            </button>
        </div>
        
        <div class="settings-section">
            <h3>Appearance</h3>
            <div class="toggle-list">
                <div class="toggle-item">
                    <span class="toggle-label">
                        <i class="fas fa-moon"></i>
                        Dark Mode
                    </span>
                    <button class="toggle-switch active" id="darkModeToggle"></button>
                </div>
            </div>
        </div>

        <div class="settings-section">
            <h3>Map Style</h3>
            <div class="map-styles">
                <button class="map-style-btn active" data-style="streets">Streets</button>
                <button class="map-style-btn" data-style="satellite">Satellite</button>
                <button class="map-style-btn" data-style="terrain">Terrain</button>
                <button class="map-style-btn" data-style="dark">Dark</button>
            </div>
        </div>

        <div class="settings-section">
            <h3>Utility Visibility</h3>
            <div class="toggle-list">
                <div class="toggle-item">
                    <span class="toggle-label">
                        <i class="fas fa-tint" style="color: var(--water-color)"></i>
                        Water
                    </span>
                    <button class="toggle-switch active" data-utility="water"></button>
                </div>
                <div class="toggle-item">
                    <span class="toggle-label">
                        <i class="fas fa-fire" style="color: var(--gas-color)"></i>
                        Gas
                    </span>
                    <button class="toggle-switch active" data-utility="gas"></button>
                </div>
                <div class="toggle-item">
                    <span class="toggle-label">
                        <i class="fas fa-bolt" style="color: var(--electric-color)"></i>
                        Electric
                    </span>
                    <button class="toggle-switch active" data-utility="electric"></button>
                </div>
                <div class="toggle-item">
                    <span class="toggle-label">
                        <i class="fas fa-toilet" style="color: var(--sewer-color)"></i>
                        Sewer
                    </span>
                    <button class="toggle-switch active" data-utility="sewer"></button>
                </div>
                <div class="toggle-item">
                    <span class="toggle-label">
                        <i class="fas fa-phone" style="color: var(--telecom-color)"></i>
                        Telecom
                    </span>
                    <button class="toggle-switch active" data-utility="telecom"></button>
                </div>
            </div>
        </div>

        <div class="settings-section">
            <h3>Line Types</h3>
            <div class="toggle-list">
                <div class="toggle-item">
                    <span class="toggle-label">
                        <i class="fas fa-grip-lines"></i>
                        Main Lines
                    </span>
                    <button class="toggle-switch active" data-linetype="main"></button>
                </div>
                <div class="toggle-item">
                    <span class="toggle-label">
                        <i class="fas fa-code-branch"></i>
                        Service Lines
                    </span>
                    <button class="toggle-switch active" data-linetype="service"></button>
                </div>
            </div>
        </div>
        
        <div class="settings-section">
            <h3>Cloud Sync</h3>
            <div class="toggle-list">
                <div class="toggle-item">
                    <span class="toggle-label">
                        <i class="fas fa-cloud"></i>
                        Enable Cloud Sync
                    </span>
                    <button class="toggle-switch" id="cloudSyncToggle"></button>
                </div>
            </div>
            <p style="margin-top: var(--spacing-sm); font-size: 12px; color: var(--text-tertiary);">
                Sync your data across devices
            </p>
        </div>
    </div>

    <!-- Connection Dialog -->
    <div class="connection-dialog" id="connectionDialog">
        <h3>Connect Utilities?</h3>
        <p>The endpoints are close. Would you like to connect them?</p>
        <div class="connection-actions">
            <button class="drawing-btn secondary" id="noConnectBtn">No</button>
            <button class="drawing-btn primary" id="yesConnectBtn">Yes, Connect</button>
        </div>
    </div>

    <!-- Toast Container -->
    <div class="toast-container" id="toastContainer"></div>
    
    <!-- Sync Status -->
    <div class="sync-status" id="syncStatus">
        <i class="fas fa-sync"></i>
        <span>Syncing...</span>
    </div>
    
    <!-- Note Input Modal -->
    <div class="note-input-modal" id="noteInputModal">
        <div class="note-input-content">
            <h3 class="note-input-header">Add Note</h3>
            <textarea class="note-textarea" id="noteTextarea" placeholder="Enter your note..."></textarea>
            <div class="note-input-actions">
                <button class="modal-btn secondary" id="cancelNoteBtn">Cancel</button>
                <button class="modal-btn primary" id="saveNoteBtn">Save</button>
            </div>
        </div>
    </div>
</div>

<!-- Leaflet JS -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/leaflet/1.9.4/leaflet.min.js"></script>

<script>
    // Premium App State
    const AppState = {
        map: null,
        theme: 'dark',
        selectedUtility: 'water',
        lineType: 'service',
        isDrawing: false,
        drawingPoints: [],
        tempLine: null,
        utilities: [],
        structures: [],
        userLocation: null,
        userMarker: null,
        watchId: null,
        deviceOrientationHandler: null,
        lastAccuracy: null,
        lastHeading: undefined,
        proximityCheckTimeout: null,
        excavationMode: false,
        proximityAlerts: [],
        proximityAlertsVisible: true,
        selectedUtilityData: null,
        refineMode: false,
        refineMarkers: [],
        addingStructure: false,
        structureToAdd: null,
        measureMode: null,
        measurePoints: [],
        measureMarkers: [],
        measureLine: null,
        measurePolygon: null,
        layers: {
            utilities: {},
            structures: {},
            visibility: {
                water: true,
                gas: true,
                electric: true,
                sewer: true,
                telecom: true,
                main: true,
                service: true
            }
        },
        dismissedAlerts: new Map(),
        alertTimeouts: new Map(),
        connectionCandidate: null,
        mapStyles: {
            streets: 'https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png',
            satellite: 'https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}',
            terrain: 'https://{s}.tile.opentopomap.org/{z}/{x}/{y}.png',
            dark: 'https://{s}.basemaps.cartocdn.com/dark_all/{z}/{x}/{y}.png'
        },
        currentMapStyle: 'dark',
        cloudSync: {
            enabled: false,
            lastSync: null,
            apiUrl: 'https://api.cacutilitrack.com',
            userId: null,
            token: null
        },
        needsOrientationPermission: false,
        // Cached DOM elements for performance
        elements: {
            drawingUI: null,
            refineOverlay: null,
            infoModal: null,
            settingsPanel: null,
            proximityAlerts: null,
            toastContainer: null,
            syncStatus: null
        },
        // Cleanup functions for proper memory management
        cleanupFunctions: []
    };

    // Initialize App
    document.addEventListener('DOMContentLoaded', () => {
        initializeApp();
    });

    function initializeApp() {
        // Enhanced mobile detection and optimization
        const isIOS = /iPad|iPhone|iPod/.test(navigator.userAgent);
        const isAndroid = /Android/.test(navigator.userAgent);
        const isMobile = isIOS || isAndroid || window.innerWidth <= 768;
        
        if (isMobile) {
            document.body.style.height = '100vh';
            document.body.style.height = '100dvh'; // Use dynamic viewport height if supported
            document.body.style.position = 'fixed';
            document.body.style.overflow = 'hidden';
            
            // Prevent rubber band scrolling on iOS
            if (isIOS) {
                document.body.style.webkitOverflowScrolling = 'touch';
                document.addEventListener('touchmove', function(e) {
                    if (e.target.closest('.modal-body, .settings-panel, .proximity-alerts')) {
                        return; // Allow scrolling in specific containers
                    }
                    e.preventDefault();
                }, { passive: false });
            }
        }

                // Ultra Premium Splash Screen with Enhanced Progress
        let progress = 0;
        const progressElement = document.getElementById('splashProgress');
        const splashElement = document.getElementById('splash');
        
        // Create more sophisticated loading stages
        const loadingStages = [
            { stage: 'Initializing Core Systems', duration: 800, progressJump: 15 },
            { stage: 'Loading Premium Components', duration: 600, progressJump: 20 },
            { stage: 'Calibrating GPS Systems', duration: 700, progressJump: 25 },
            { stage: 'Optimizing Performance', duration: 500, progressJump: 25 },
            { stage: 'Finalizing Setup', duration: 400, progressJump: 15 }
        ];
        
        let currentStage = 0;
        
        // Animate particles with staggered timing
        setTimeout(() => {
            const particles = document.querySelectorAll('.particle');
            particles.forEach((particle, index) => {
                setTimeout(() => {
                    particle.style.opacity = '1';
                    particle.style.animation = `particleFloat ${15 + Math.random() * 10}s linear infinite`;
                }, index * 200);
            });
        }, 500);
        
        function updateProgress() {
            if (currentStage < loadingStages.length) {
                const stage = loadingStages[currentStage];
                
                // Smooth progress increment
                const increment = stage.progressJump / (stage.duration / 50);
                const targetProgress = Math.min(progress + stage.progressJump, 100);
                
                const progressInterval = setInterval(() => {
                    progress += increment;
                    
                    if (progress >= targetProgress || progress >= 100) {
                        progress = Math.min(targetProgress, 100);
                        clearInterval(progressInterval);
                        
                        if (progress >= 100) {
                            // Enhanced completion sequence
                            progressElement.textContent = 'READY';
                            progressElement.style.color = 'rgba(0, 245, 160, 0.9)';
                            progressElement.style.fontWeight = '800';
                            progressElement.style.transform = 'scale(1.1)';
                            
                            setTimeout(() => {
                                splashElement.style.transform = 'scale(1.05)';
                                splashElement.style.filter = 'blur(2px)';
                                setTimeout(() => {
                                    splashElement.classList.add('hide');
                                }, 300);
                            }, 800);
                        } else {
                            currentStage++;
                            setTimeout(updateProgress, 100);
                        }
                        return;
                    }
                    
                    // Update progress display with enhanced formatting
                    progressElement.textContent = `${Math.round(progress)}%`;
                    
                    // Add visual feedback at milestones
                    if (progress >= 25 && progress < 26) {
                        progressElement.style.color = 'rgba(102, 126, 234, 0.9)';
                    } else if (progress >= 50 && progress < 51) {
                        progressElement.style.color = 'rgba(255, 0, 110, 0.9)';
                    } else if (progress >= 75 && progress < 76) {
                        progressElement.style.color = 'rgba(255, 214, 10, 0.9)';
                    }
                    
                }, 50);
                
            }
        }
        
        // Start the enhanced loading sequence
        setTimeout(() => {
            updateProgress();
        }, 1000);

        // Initialize core systems
        initializeMap();
        initializeDOMCache();
        initializeEventListeners();

        // Enhanced theme management
        const savedTheme = localStorage.getItem('theme') || (window.matchMedia('(prefers-color-scheme: dark)').matches ? 'dark' : 'dark');
        setTheme(savedTheme);

        // Watch for system theme changes
        window.matchMedia('(prefers-color-scheme: dark)').addEventListener('change', (e) => {
            if (!localStorage.getItem('theme')) {
                setTheme(e.matches ? 'dark' : 'light');
            }
        });

        // Enhanced cloud sync
        const cloudSyncEnabled = localStorage.getItem('cloudSyncEnabled') === 'true';
        if (cloudSyncEnabled) {
            enableCloudSync();
        }

                // Load saved data with error handling
        try {
        loadUtilities();
        loadStructures();
        } catch (error) {
            console.error('Error loading data:', error);
            showToast('Error loading saved data', 'error');
        }

        // Apply initial zoom-based opacity
        setTimeout(() => {
            handleZoomChange();
        }, 1000);

        // Start location tracking with enhanced permissions
        requestLocationPermissions();

        // Enhanced touch event prevention - only prevent double-tap zoom and pull-to-refresh
        let touchStartY = 0;
        
        document.addEventListener('touchstart', function(event) {
            if (event.touches && event.touches[0]) {
                touchStartY = event.touches[0].clientY;
            }
        }, { passive: true });
        
        // Prevent pull-to-refresh only at top of page
        document.addEventListener('touchmove', function(event) {
            if (event.touches && event.touches[0]) {
                const touchY = event.touches[0].clientY;
                const touchDiff = touchY - touchStartY;
                
                // Only prevent if pulling down at top of page and not in scrollable areas
                if (touchDiff > 0 && window.scrollY === 0 && 
                    !event.target.closest('.modal-body, .settings-panel, .proximity-alerts, .notes-list')) {
                    event.preventDefault();
                }
            }
        }, { passive: false });
        
        // Enhanced keyboard handling for iOS
        if (isIOS) {
            const viewport = document.querySelector('meta[name=viewport]');
            document.addEventListener('focusin', function() {
                viewport.setAttribute('content', 'width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no');
            });
            
            document.addEventListener('focusout', function() {
                viewport.setAttribute('content', 'width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover');
            });
        }
        
        // Performance monitoring
        if ('performance' in window && 'PerformanceObserver' in window) {
            const observer = new PerformanceObserver((list) => {
                for (const entry of list.getEntries()) {
                    if (entry.entryType === 'paint' && entry.name === 'first-contentful-paint') {
                        console.log('First Contentful Paint:', entry.startTime);
                    }
                }
            });
            observer.observe({ entryTypes: ['paint'] });
        }
    }
    
    async function requestLocationPermissions() {
        if (!navigator.geolocation) {
            showToast('Geolocation not supported', 'error');
            return;
        }
        
        try {
            // Check current permission state
            if ('permissions' in navigator) {
                const permission = await navigator.permissions.query({name: 'geolocation'});
                if (permission.state === 'denied') {
                    showToast('Location access denied. Please enable in settings.', 'warning');
                    return;
                }
            }

        // Start location tracking
        startLocationTracking();

        } catch (error) {
            console.error('Permission error:', error);
            // Fallback to direct geolocation request
            startLocationTracking();
        }
    }

    function initializeDOMCache() {
        // Cache frequently accessed DOM elements for performance
        AppState.elements.drawingUI = document.getElementById('drawingUI');
        AppState.elements.refineOverlay = document.getElementById('refineOverlay');
        AppState.elements.infoModal = document.getElementById('infoModal');
        AppState.elements.settingsPanel = document.getElementById('settingsPanel');
        AppState.elements.proximityAlerts = document.getElementById('proximityAlerts');
        AppState.elements.toastContainer = document.getElementById('toastContainer');
        AppState.elements.syncStatus = document.getElementById('syncStatus');
    }

    function initializeMap() {
        // Create map
        AppState.map = L.map('map', {
            center: [40.7128, -74.0060], // Default to NYC
            zoom: 16,
            zoomControl: false,
            attributionControl: false,
            doubleClickZoom: false,
            touchZoom: true,
            scrollWheelZoom: true,
            boxZoom: false,
            keyboard: false,
            tap: false
        });

        // Add tile layer
        L.tileLayer(AppState.mapStyles[AppState.currentMapStyle], {
            maxZoom: 22,
            maxNativeZoom: 19
        }).addTo(AppState.map);

        // Initialize utility layers
        const utilityTypes = ['water', 'gas', 'electric', 'sewer', 'telecom'];
        utilityTypes.forEach(type => {
            AppState.layers.utilities[type] = L.layerGroup().addTo(AppState.map);
            AppState.layers.structures[type] = L.layerGroup().addTo(AppState.map);
        });

        // Map events
        AppState.map.on('click', handleMapClick);
        AppState.map.on('contextmenu', e => e.preventDefault());
        AppState.map.on('zoomend', handleZoomChange);
        AppState.map.on('zoom', handleZoomChange); // For smooth transitions during zoom
    }

    function initializeEventListeners() {
        // Prevent all context menus
        document.addEventListener('contextmenu', e => e.preventDefault());

        // Utility selection
        document.querySelectorAll('.utility-btn').forEach(btn => {
            btn.addEventListener('click', (e) => {
                e.preventDefault();
                document.querySelectorAll('.utility-btn').forEach(b => {
                    b.classList.remove('active');
                    b.setAttribute('aria-pressed', 'false');
                });
                btn.classList.add('active');
                btn.setAttribute('aria-pressed', 'true');
                AppState.selectedUtility = btn.dataset.utility;
                hapticFeedback(30);
            });
        });

        // Line type selection
        document.querySelectorAll('.line-type-btn').forEach(btn => {
            btn.addEventListener('click', (e) => {
                e.preventDefault();
                document.querySelectorAll('.line-type-btn').forEach(b => b.classList.remove('active'));
                btn.classList.add('active');
                AppState.lineType = btn.dataset.type;
                hapticFeedback(30);
            });
        });

        // Control buttons
        document.getElementById('drawBtn').addEventListener('click', startDrawing);
        document.getElementById('locateBtn').addEventListener('click', centerOnLocation);
        document.getElementById('layersBtn').addEventListener('click', toggleLayersPanel);
        document.getElementById('excavationBtn').addEventListener('click', toggleExcavationMode);
        document.getElementById('settingsBtn').addEventListener('click', openSettings);
        document.getElementById('zoomInBtn').addEventListener('click', () => {
            AppState.map.zoomIn();
            hapticFeedback(20);
        });
        document.getElementById('zoomOutBtn').addEventListener('click', () => {
            AppState.map.zoomOut();
            hapticFeedback(20);
        });

        // Measurement tools
        document.getElementById('measureDistanceBtn').addEventListener('click', () => toggleMeasureMode('distance'));
        document.getElementById('measureAreaBtn').addEventListener('click', () => toggleMeasureMode('area'));

        // Structure button
        document.getElementById('addStructureBtn').addEventListener('click', toggleStructureMenu);
        document.querySelectorAll('.structure-type-btn').forEach(btn => {
            btn.addEventListener('click', (e) => {
                e.stopPropagation();
                startAddingStructure(btn.dataset.structure, btn.dataset.utility);
            });
        });

        // Drawing controls
        document.getElementById('cancelDrawBtn').addEventListener('click', cancelDrawing);
        document.getElementById('finishDrawBtn').addEventListener('click', finishDrawing);

        // Refine controls
        document.getElementById('finishRefineBtn').addEventListener('click', (e) => {
            e.preventDefault();
            e.stopPropagation();
            finishRefining();
        });

        // Modal controls
        document.getElementById('closeModalBtn').addEventListener('click', closeInfoModal);
        document.getElementById('editBtn').addEventListener('click', enterEditMode);
        document.getElementById('refineBtn').addEventListener('click', (e) => {
            console.log('🔧 Refine button clicked');
            startRefineLocation();
        });
        document.getElementById('deleteBtn').addEventListener('click', deleteUtility);

        // Edit form controls
        document.getElementById('cancelEditBtn').addEventListener('click', exitEditMode);
        document.getElementById('saveEditBtn').addEventListener('click', saveEdit);

        // Notes
        document.getElementById('addNoteBtn').addEventListener('click', showNoteInput);
        
        // Note input modal
        document.getElementById('cancelNoteBtn').addEventListener('click', hideNoteInput);
        document.getElementById('saveNoteBtn').addEventListener('click', saveNote);

        // Excavation mode
        document.getElementById('exitExcavationBtn').addEventListener('click', exitExcavationMode);
        document.getElementById('alertToggleBtn').addEventListener('click', toggleProximityAlerts);

        // Settings
        document.getElementById('closeSettingsBtn').addEventListener('click', closeSettings);
        document.getElementById('darkModeToggle').addEventListener('click', toggleDarkMode);
        document.getElementById('cloudSyncToggle').addEventListener('click', toggleCloudSync);

        // Map style buttons
        document.querySelectorAll('.map-style-btn').forEach(btn => {
            btn.addEventListener('click', () => changeMapStyle(btn.dataset.style));
        });

        // Visibility toggles
        document.querySelectorAll('.toggle-switch[data-utility]').forEach(toggle => {
            toggle.addEventListener('click', () => toggleUtilityVisibility(toggle));
        });

        document.querySelectorAll('.toggle-switch[data-linetype]').forEach(toggle => {
            toggle.addEventListener('click', () => toggleLineTypeVisibility(toggle));
        });

        // Connection dialog
        document.getElementById('noConnectBtn').addEventListener('click', () => {
            closeConnectionDialog(false);
        });
        document.getElementById('yesConnectBtn').addEventListener('click', () => {
            closeConnectionDialog(true);
        });

        // Close menus on outside click and cancel structure placement
        document.addEventListener('click', (e) => {
            if (!e.target.closest('.structure-container')) {
                document.getElementById('structureMenu').classList.remove('active');
            }
        });

        // Add escape key handler to cancel structure placement
        document.addEventListener('keydown', (e) => {
            if (e.key === 'Escape') {
                if (AppState.addingStructure) {
                    cancelStructurePlacement();
                }
            }
        });

        // Enhanced gesture prevention for iOS/Safari
        const preventGestures = (e) => e.preventDefault();
        document.addEventListener('gesturestart', preventGestures);
        document.addEventListener('gesturechange', preventGestures);
        document.addEventListener('gestureend', preventGestures);
        
        // Store cleanup functions for proper app shutdown
        AppState.cleanupFunctions = [
            () => {
                document.removeEventListener('gesturestart', preventGestures);
                document.removeEventListener('gesturechange', preventGestures);
                document.removeEventListener('gestureend', preventGestures);
            }
        ];
    }

    // Haptic Feedback
    function hapticFeedback(duration = 50) {
        if ('vibrate' in navigator) {
            navigator.vibrate(duration);
        }
    }

    // Location tracking
    function startLocationTracking() {
        if (!navigator.geolocation) {
            showToast('Geolocation not supported', 'error');
            return;
        }

        // Get initial position
        navigator.geolocation.getCurrentPosition(
            position => updateUserLocation(position),
            error => showToast('Location access denied', 'error'),
            { enableHighAccuracy: true }
        );

        // Watch position
        AppState.watchId = navigator.geolocation.watchPosition(
            position => updateUserLocation(position),
            error => {
                console.error('Location error:', error);
                let message = 'Location error';
                switch(error.code) {
                    case error.PERMISSION_DENIED:
                        message = 'Location access denied by user';
                        break;
                    case error.POSITION_UNAVAILABLE:
                        message = 'Location information unavailable';
                        break;
                    case error.TIMEOUT:
                        message = 'Location request timed out';
                        break;
                }
                showToast(message, 'warning');
            },
            {
                enableHighAccuracy: true,
                timeout: 10000,
                maximumAge: 60000
            }
        );

        // Watch device orientation
        if (window.DeviceOrientationEvent) {
            if (typeof DeviceOrientationEvent.requestPermission === 'function') {
                AppState.needsOrientationPermission = true;
            } else {
                window.addEventListener('deviceorientation', handleDeviceOrientation);
            }
        }
    }

    function handleDeviceOrientation(event) {
        let heading = 0;
        
        if (event.webkitCompassHeading !== undefined) {
            // iOS - webkitCompassHeading gives heading relative to magnetic north
            heading = event.webkitCompassHeading;
        } else if (event.alpha !== null) {
            // Android - alpha gives rotation around z-axis
            if (event.absolute) {
                heading = event.alpha;
            } else {
                // If not absolute, we need to adjust for device orientation
                heading = 360 - event.alpha;
            }
        }
        
        updateDirectionIndicator(heading);
    }

    function updateUserLocation(position) {
        const { latitude, longitude, accuracy } = position.coords;
        const newLocation = [latitude, longitude];
        
        // Debounce location updates to prevent jittering
        if (AppState.userLocation) {
            const distance = calculateDistance(AppState.userLocation, newLocation);
            // Only update if moved more than 2 meters or accuracy significantly improved
            if (distance < 0.000018 && (!AppState.lastAccuracy || Math.abs(accuracy - AppState.lastAccuracy) < 5)) {
                return;
            }
        }
        
        AppState.userLocation = newLocation;
        AppState.lastAccuracy = accuracy;

        if (!AppState.userMarker) {
            // Create simple arrow-style user location marker
            const userIcon = L.divIcon({
                className: 'user-location-marker',
                html: `
                    <div class="location-container">
                        <div class="location-accuracy"></div>
                        <div class="location-arrow">
                            <div class="location-center"></div>
                        </div>
                    </div>
                `,
                iconSize: [48, 48],
                iconAnchor: [24, 24]
            });

            AppState.userMarker = L.marker([latitude, longitude], {
                icon: userIcon,
                zIndexOffset: 1000
            }).addTo(AppState.map);
            
            // Apply current zoom scale to new marker - prevent bouncing
            setTimeout(() => {
                applyUserMarkerScale();
            }, 50);
            
            // Initialize direction indicator if orientation is available
            if (window.DeviceOrientationEvent && !AppState.needsOrientationPermission) {
                // Add a small delay to ensure the marker is rendered
                setTimeout(() => {
                    // Try to get initial orientation
                    if (window.orientation !== undefined) {
                        updateDirectionIndicator(window.orientation);
                    }
                }, 100);
            }
        } else {
            // Smooth location updates
            AppState.userMarker.setLatLng([latitude, longitude]);
        }

        // Update accuracy circle with smooth transitions
        updateAccuracyIndicator(accuracy);

        // Debounced proximity check in excavation mode
        if (AppState.excavationMode) {
            clearTimeout(AppState.proximityCheckTimeout);
            AppState.proximityCheckTimeout = setTimeout(checkProximity, 500);
        }
    }

    function calculateDistance(point1, point2) {
        const lat1 = point1[0];
        const lng1 = point1[1];
        const lat2 = point2[0];
        const lng2 = point2[1];
        
        return Math.sqrt(Math.pow(lat2 - lat1, 2) + Math.pow(lng2 - lng1, 2));
    }

    function applyUserMarkerScale() {
        if (!AppState.userMarker) return;
        
        const currentZoom = AppState.map.getZoom();
        const scale = calculateZoomScale(currentZoom);
        const markerElement = AppState.userMarker.getElement();
        if (markerElement) {
            // Preserve any existing direction rotation while applying scale
            const currentTransform = markerElement.style.transform || '';
            const rotateMatch = currentTransform.match(/rotate\([^)]+\)/);
            const rotateTransform = rotateMatch ? rotateMatch[0] : '';
            markerElement.style.transform = `scale(${scale}) ${rotateTransform}`.trim();
        }
    }

    function updateAccuracyIndicator(accuracy) {
        const accuracyElement = document.querySelector('.location-accuracy');
        if (accuracyElement && accuracy) {
            // Scale based on accuracy: better accuracy = smaller circle
            const scale = Math.min(3, Math.max(0.3, accuracy / 10));
            accuracyElement.style.transform = `scale(${scale})`;
            
            // Adjust opacity based on accuracy - better accuracy = more opaque
            const opacity = Math.min(0.8, Math.max(0.1, 1 - (accuracy / 50)));
            accuracyElement.style.opacity = opacity;
            
            // Change color based on accuracy quality
            if (accuracy <= 5) {
                accuracyElement.style.borderColor = 'rgba(0, 245, 160, 0.3)';
            } else if (accuracy <= 15) {
                accuracyElement.style.borderColor = 'rgba(154, 245, 0, 0.3)';
            } else if (accuracy <= 30) {
                accuracyElement.style.borderColor = 'rgba(255, 214, 10, 0.3)';
            } else {
                accuracyElement.style.borderColor = 'rgba(255, 69, 0, 0.3)';
            }
        }
    }

    function updateDirectionIndicator(heading) {
        if (heading === null || heading === undefined) return;
        
        // Normalize heading to 0-360 range
        const normalizedHeading = ((heading % 360) + 360) % 360;
        
        // Debounce direction updates to prevent jittering
        if (AppState.lastHeading !== undefined) {
            const headingDifference = Math.abs(normalizedHeading - AppState.lastHeading);
            const minDifference = Math.min(headingDifference, 360 - headingDifference);
            
            // Only update if heading changed by more than 3 degrees
            if (minDifference < 3) {
                return;
            }
        }
        
        AppState.lastHeading = normalizedHeading;
        
        // Apply rotation to marker element to preserve scale transform
        if (AppState.userMarker) {
            const markerElement = AppState.userMarker.getElement();
            if (markerElement) {
                // Preserve any existing scale while applying rotation
                const currentTransform = markerElement.style.transform || '';
                const scaleMatch = currentTransform.match(/scale\([^)]+\)/);
                const scaleTransform = scaleMatch ? scaleMatch[0] : 'scale(1)';
                markerElement.style.transform = `${scaleTransform} rotate(${normalizedHeading}deg)`;
                
                // Optional: Add visual feedback that compass is working
                const container = markerElement.querySelector('.location-container');
                if (container) {
                    container.setAttribute('data-heading', normalizedHeading.toFixed(0));
                }
            }
        }
    }

    async function centerOnLocation() {
        // Request orientation permission if needed (iOS 13+)
        if (AppState.needsOrientationPermission) {
            try {
                const permission = await DeviceOrientationEvent.requestPermission();
                if (permission === 'granted') {
                    window.addEventListener('deviceorientation', handleDeviceOrientation);
                    AppState.needsOrientationPermission = false;
                }
            } catch (error) {
                console.error('Orientation permission denied');
            }
        }

        if (AppState.userLocation) {
            AppState.map.setView(AppState.userLocation, 18);
            showToast('Centered on your location', 'info');
            hapticFeedback(50);
        } else {
            showToast('Location not available', 'error');
        }
    }

    // Drawing functions
    function startDrawing() {
        if (AppState.measureMode) {
            toggleMeasureMode(null);
        }
        
        // Cancel structure placement if active
        if (AppState.addingStructure) {
            cancelStructurePlacement();
        }
        
        AppState.isDrawing = true;
        AppState.drawingPoints = [];
        document.getElementById('drawingUI').classList.add('active');
        document.getElementById('drawBtn').classList.add('active');
        updateDrawingStatus();
        hapticFeedback(50);
    }

    function handleMapClick(e) {
        if (AppState.isDrawing) {
            addDrawingPoint(e.latlng);
        } else if (AppState.refineMode) {
            // Ignore map clicks during refine mode - only marker dragging allowed
            return;
        } else if (AppState.addingStructure) {
            addStructure(e.latlng);
        } else if (AppState.measureMode) {
            addMeasurePoint(e.latlng);
        }
    }

    // Enhanced zoom-based visibility and scaling system
    function handleZoomChange() {
        const currentZoom = AppState.map.getZoom();
        const opacity = calculateZoomOpacity(currentZoom);
        const scale = calculateZoomScale(currentZoom);
        
        console.log(`🔍 Zoom: ${currentZoom}, Opacity: ${opacity.toFixed(2)}, Scale: ${scale.toFixed(2)}`);
        
        // Apply to all utility lines with scaling
        AppState.utilities.forEach(utility => {
            if (utility.lineLayer) {
                // Don't fade if currently highlighted/selected, in refine mode, or in excavation mode
                const isHighlighted = utility.lineLayer.options.className && 
                                    utility.lineLayer.options.className.includes('highlighted');
                const isBeingRefined = AppState.refineMode && 
                                     AppState.selectedUtilityData && 
                                     utility.id === AppState.selectedUtilityData.id;
                const isExcavationMode = AppState.excavationMode;
                const finalOpacity = (isHighlighted || isBeingRefined || isExcavationMode) ? 1.0 : opacity;
                
                // Base weight with zoom scaling
                const baseWeight = utility.lineType === 'main' ? 8 : 6;
                const scaledWeight = Math.max(2, baseWeight * scale); // Minimum of 2px
                
                utility.lineLayer.setStyle({ 
                    opacity: finalOpacity,
                    weight: scaledWeight
                });
                
                // Apply to connection markers
                if (utility.connectionMarkers) {
                    utility.connectionMarkers.forEach(marker => {
                        if (marker._icon) {
                            marker._icon.style.opacity = finalOpacity;
                        }
                    });
                }
            }
        });
        
        // Apply to all structure markers
        AppState.structures.forEach(structure => {
            if (structure.marker && structure.marker._icon) {
                const finalOpacity = AppState.excavationMode ? 1.0 : opacity;
                structure.marker._icon.style.opacity = finalOpacity;
            }
        });
        
        // Scale user location marker while preserving rotation
        if (AppState.userMarker) {
            applyUserMarkerScale();
        }
        
        // Ensure refine markers are always fully visible
        if (AppState.refineMode && AppState.refineMarkers) {
            AppState.refineMarkers.forEach(marker => {
                if (marker._icon) {
                    marker._icon.style.opacity = 1.0;
                }
            });
        }
    }

    function calculateZoomOpacity(zoom) {
        // VERY AGGRESSIVE zoom-based fading:
        // 20+ (max zoom): 1.0 (fully visible)
        // 18-19 (street level): 0.7 (noticeable fade starts early)
        // 16-17 (building level): 0.4 (heavy fade)
        // 14-15 (block level): 0.15 (barely visible)
        // <14 (neighborhood+): 0.02 (almost invisible)
        
        if (zoom >= 20) {
            return 1.0; // Full visibility only at maximum zoom
        } else if (zoom >= 18) {
            return 0.7; // Start fading aggressively at street level
        } else if (zoom >= 16) {
            return 0.4; // Heavy fade at building level
        } else if (zoom >= 14) {
            return 0.15; // Barely visible at block level
        } else {
            return 0.02; // Almost completely invisible below zoom 14
        }
    }

    // Zoom-based scaling calculation for user location and utility lines
    function calculateZoomScale(zoom) {
        // Responsive scaling - smaller at low zoom, larger at high zoom
        if (zoom >= 18) return 1.0;     // Full size at close zoom
        if (zoom >= 16) return 0.8;     // 80% size
        if (zoom >= 14) return 0.6;     // 60% size
        if (zoom >= 12) return 0.4;     // 40% size
        if (zoom >= 10) return 0.3;     // 30% size
        return 0.2;                     // 20% size at far zoom
    }

    function addDrawingPoint(latlng) {
        AppState.drawingPoints.push(latlng);
        updateDrawingStatus();
        updateTempLine();
        hapticFeedback(30);

        // Check for nearby connections
        if (AppState.drawingPoints.length >= 1) {
            checkForNearbyConnections(latlng);
        }

        // Add a temporary marker for visual feedback
        const tempMarker = L.circleMarker(latlng, {
            radius: 6,
            fillColor: getUtilityColor(AppState.selectedUtility),
            fillOpacity: 1,
            color: 'white',
            weight: 2
        }).addTo(AppState.map);

        setTimeout(() => {
            AppState.map.removeLayer(tempMarker);
        }, 1000);
    }

    function updateDrawingStatus() {
        const status = document.getElementById('drawingStatus');
        const finishBtn = document.getElementById('finishDrawBtn');
        
        if (AppState.drawingPoints.length === 0) {
            status.textContent = 'Click points on the map';
            finishBtn.style.display = 'none';
        } else if (AppState.drawingPoints.length === 1) {
            status.textContent = 'Click to add more points';
            finishBtn.style.display = 'none';
        } else {
            status.textContent = `${AppState.drawingPoints.length} points added`;
            finishBtn.style.display = 'block';
        }
    }

    function updateTempLine() {
        if (AppState.tempLine) {
            AppState.map.removeLayer(AppState.tempLine);
        }

        if (AppState.drawingPoints.length > 1) {
            AppState.tempLine = L.polyline(AppState.drawingPoints, {
                color: getUtilityColor(AppState.selectedUtility),
                weight: AppState.lineType === 'main' ? 8 : 6,
                opacity: 1.0, // Always fully visible during drawing
                dashArray: AppState.lineType === 'service' ? '15, 5' : null,
                className: 'utility-line drawing'
            }).addTo(AppState.map);
        }
    }

    function checkForNearbyConnections(currentPoint) {
        const threshold = 0.00009; // Approximately 10 meters
        AppState.connectionCandidate = null;

        // Check for nearby utilities of the same type
        AppState.utilities.forEach(utility => {
            if (utility.type === AppState.selectedUtility) {
                // For service lines, check if we can connect to a main
                if (AppState.lineType === 'service' && utility.lineType === 'main') {
                    // Check distance to any point on the main line
                    const closestPoint = getClosestPointOnLine(currentPoint, utility.points);
                    if (closestPoint.distance < threshold) {
                        AppState.connectionCandidate = {
                            utility: utility,
                            point: closestPoint.point,
                            type: 'main-to-service'
                        };
                    }
                } else if (utility.lineType === AppState.lineType) {
                    // Same line type - check endpoints only
                    const startPoint = utility.points[0];
                    const endPoint = utility.points[utility.points.length - 1];

                    if (getDistance(currentPoint, startPoint) < threshold) {
                        AppState.connectionCandidate = {
                            utility: utility,
                            point: startPoint,
                            type: 'endpoint'
                        };
                    } else if (getDistance(currentPoint, endPoint) < threshold) {
                        AppState.connectionCandidate = {
                            utility: utility,
                            point: endPoint,
                            type: 'endpoint'
                        };
                    }
                }
            }
        });

        // Check for nearby structures
        AppState.structures.forEach(structure => {
            if (structure.utilityType === AppState.selectedUtility) {
                if (getDistance(currentPoint, structure.latlng) < threshold) {
                    AppState.connectionCandidate = {
                        structure: structure,
                        point: structure.latlng,
                        type: 'structure'
                    };
                }
            }
        });
    }

    function getClosestPointOnLine(point, linePoints) {
        let minDistance = Infinity;
        let closestPoint = null;

        for (let i = 0; i < linePoints.length - 1; i++) {
            const projectedPoint = projectPointOnSegment(point, linePoints[i], linePoints[i + 1]);
            const distance = getDistance(point, projectedPoint);
            
            if (distance < minDistance) {
                minDistance = distance;
                closestPoint = projectedPoint;
            }
        }

        return { point: closestPoint, distance: minDistance };
    }

    function projectPointOnSegment(point, segStart, segEnd) {
        const A = point.lat - segStart.lat;
        const B = point.lng - segStart.lng;
        const C = segEnd.lat - segStart.lat;
        const D = segEnd.lng - segStart.lng;

        const dot = A * C + B * D;
        const lenSq = C * C + D * D;
        let param = -1;

        if (lenSq !== 0) {
            param = dot / lenSq;
        }

        let lat, lng;

        if (param < 0) {
            lat = segStart.lat;
            lng = segStart.lng;
        } else if (param > 1) {
            lat = segEnd.lat;
            lng = segEnd.lng;
        } else {
            lat = segStart.lat + param * C;
            lng = segStart.lng + param * D;
        }

        return L.latLng(lat, lng);
    }

    function getDistance(point1, point2) {
        const lat1 = point1.lat || point1[0];
        const lng1 = point1.lng || point1[1];
        const lat2 = point2.lat || point2[0];
        const lng2 = point2.lng || point2[1];
        
        return Math.sqrt(Math.pow(lat2 - lat1, 2) + Math.pow(lng2 - lng1, 2));
    }

    function showConnectionDialog() {
        const dialog = document.getElementById('connectionDialog');
        dialog.classList.add('active');
        hapticFeedback(50);
    }

    function closeConnectionDialog(connect) {
        const dialog = document.getElementById('connectionDialog');
        dialog.classList.remove('active');
        
        if (connect && AppState.connectionCandidate) {
            // Snap to connection point
            const lastIndex = AppState.drawingPoints.length - 1;
            AppState.drawingPoints[lastIndex] = AppState.connectionCandidate.point;
            updateTempLine();
            hapticFeedback(30);
            
            // Finish drawing immediately after connecting
            finishDrawingWithConnection();
        }
        
        // Clear connection candidate
        AppState.connectionCandidate = null;
    }
    
    function finishDrawingWithConnection() {
        if (AppState.drawingPoints.length < 2) {
            showToast('Need at least 2 points', 'warning');
            return;
        }

        // Create utility data
        const utilityData = {
            id: generateId(),
            type: AppState.selectedUtility,
            lineType: AppState.lineType,
            points: [...AppState.drawingPoints],
            size: '',
            depth: '',
            material: '',
            condition: '',
            curbDistance: '',
            dateAdded: new Date().toISOString(),
            connections: [],
            notes: []
        };

        // Add connection info if connected
        if (AppState.connectionCandidate) {
            utilityData.connections.push({
                type: AppState.connectionCandidate.type,
                targetId: AppState.connectionCandidate.utility?.id || AppState.connectionCandidate.structure?.id,
                point: AppState.connectionCandidate.point
            });
        }

        // Add utility to state
        AppState.utilities.push(utilityData);

        // Create the utility line on map
        createUtilityLine(utilityData);

        // Save
        saveUtilities();
        syncToCloud();

        // Show info modal for editing
        showInfoModal(utilityData);

        // Reset drawing state
        cancelDrawing();

        showToast('Utility line connected and added', 'success');
        hapticFeedback(100);
    }

    function finishDrawing() {
        if (AppState.drawingPoints.length < 2) {
            showToast('Need at least 2 points', 'warning');
            return;
        }

        // Check if we should show connection dialog
        if (AppState.connectionCandidate && AppState.drawingPoints.length > 0) {
            showConnectionDialog();
            return;
        }

        // Create utility data
        const utilityData = {
            id: generateId(),
            type: AppState.selectedUtility,
            lineType: AppState.lineType,
            points: [...AppState.drawingPoints],
            size: '',
            depth: '',
            material: '',
            condition: '',
            curbDistance: '',
            dateAdded: new Date().toISOString(),
            connections: [],
            notes: []
        };

        // Add connection info if connected
        if (AppState.connectionCandidate) {
            utilityData.connections.push({
                type: AppState.connectionCandidate.type,
                targetId: AppState.connectionCandidate.utility?.id || AppState.connectionCandidate.structure?.id,
                point: AppState.connectionCandidate.point
            });
        }

        // Add utility to state
        AppState.utilities.push(utilityData);

        // Create the utility line on map
        createUtilityLine(utilityData);

        // Save
        saveUtilities();
        syncToCloud();

        // Show info modal for editing
        showInfoModal(utilityData);

        // Reset drawing state
        cancelDrawing();

        showToast('Utility line added', 'success');
        hapticFeedback(100);
    }

    function cancelDrawing() {
        AppState.isDrawing = false;
        AppState.drawingPoints = [];
        AppState.connectionCandidate = null;
        
        if (AppState.tempLine) {
            AppState.map.removeLayer(AppState.tempLine);
            AppState.tempLine = null;
        }

        document.getElementById('drawingUI').classList.remove('active');
        document.getElementById('drawBtn').classList.remove('active');
    }

    function createUtilityLine(utilityData) {
        const line = L.polyline(utilityData.points, {
            color: getUtilityColor(utilityData.type),
            weight: utilityData.lineType === 'main' ? 8 : 6,
            opacity: 1,
            dashArray: utilityData.lineType === 'service' ? '15, 5' : null,
            className: `utility-line ${utilityData.type} ${utilityData.lineType}`,
            interactive: true
        });

        // Enhanced mobile-first interaction handling
        let pressTimer;
        let longPress = false;
        let startTime = 0;
        let lastClickTime = 0;
        let startPos = null;
        let hasMoved = false;
        
        const startPress = (e) => {
            if (AppState.isDrawing || AppState.refineMode || AppState.addingStructure || AppState.measureMode) {
                return; // Don't interfere with other modes
            }
            
            // Prevent event bubbling
            L.DomEvent.stopPropagation(e);
            L.DomEvent.preventDefault(e);
            
            longPress = false;
            hasMoved = false;
            startTime = Date.now();
            
            // Store initial position for move detection
            if (e.type === 'touchstart' && e.originalEvent.touches && e.originalEvent.touches[0]) {
                startPos = {
                    x: e.originalEvent.touches[0].clientX,
                    y: e.originalEvent.touches[0].clientY
                };
            } else {
                startPos = { x: e.originalEvent.clientX, y: e.originalEvent.clientY };
            }
            
            // Start long press timer
            pressTimer = setTimeout(() => {
                if (!hasMoved) {
                longPress = true;
                hapticFeedback(50);
                showInfoModal(utilityData);
                }
            }, 600); // Slightly longer for mobile
            
            // Highlight line on press
            line.setStyle({
                weight: (utilityData.lineType === 'main' ? 8 : 6) + 2,
                opacity: 0.8
            });
        };
        
        const movePress = (e) => {
            if (!startPos) return;
            
            let currentPos;
            if (e.type === 'touchmove' && e.originalEvent.touches && e.originalEvent.touches[0]) {
                currentPos = {
                    x: e.originalEvent.touches[0].clientX,
                    y: e.originalEvent.touches[0].clientY
                };
            } else {
                currentPos = { x: e.originalEvent.clientX, y: e.originalEvent.clientY };
            }
            
            // Check if moved more than 10px
            const distance = Math.sqrt(
                Math.pow(currentPos.x - startPos.x, 2) + 
                Math.pow(currentPos.y - startPos.y, 2)
            );
            
            if (distance > 10) {
                hasMoved = true;
            clearTimeout(pressTimer);
            }
        };
        
        const endPress = (e) => {
            clearTimeout(pressTimer);
            const pressDuration = Date.now() - startTime;
            
            // Reset line style
            line.setStyle({
                weight: utilityData.lineType === 'main' ? 8 : 6,
                opacity: 1
            });
            
            // Show quick info on short press without movement
            if (!longPress && !hasMoved && pressDuration < 400 && pressDuration > 50) {
                const utilityName = `${capitalizeFirst(utilityData.type)} ${capitalizeFirst(utilityData.lineType)}`;
                const info = utilityData.size ? ` (${utilityData.size}")` : '';
                showToast(`${utilityName}${info} - Long press to edit`, 'info');
                hapticFeedback(30);
            }
            
            // Reset state
            startPos = null;
            hasMoved = false;
        };

        // Enhanced event handling for mobile
        line.on('mousedown touchstart', startPress);
        line.on('mousemove touchmove', movePress);
        line.on('mouseup touchend mouseleave touchcancel', endPress);

        line.on('click', (e) => {
                L.DomEvent.stopPropagation(e);
            
            // Handle double-tap to open modal (alternative to long press)
            const now = Date.now();
            if (now - lastClickTime < 300) {
                // Double tap detected
                if (!AppState.isDrawing && !AppState.refineMode && !AppState.addingStructure && !AppState.measureMode) {
                    showInfoModal(utilityData);
                    hapticFeedback(50);
                }
            }
            lastClickTime = now;
        });

        // Store reference
        utilityData.lineLayer = line;

        // Add to appropriate layer
        line.addTo(AppState.layers.utilities[utilityData.type]);

        // Apply current zoom-based opacity
        const currentZoom = AppState.map.getZoom();
        const opacity = calculateZoomOpacity(currentZoom);
        line.setStyle({ opacity: opacity });

        // Enhanced connection markers with animations
        if (utilityData.connections && utilityData.connections.length > 0) {
            utilityData.connections.forEach((conn, index) => {
                let markerClass = 'connection-marker';
                let radius = 8;
                let fillColor = 'white';
                
                if (conn.type === 'main-to-service') {
                    markerClass += ' t-junction';
                    radius = 10;
                    fillColor = '#f0f8ff';
                } else if (conn.type === 'endpoint') {
                    markerClass += ' endpoint';
                    radius = 8;
                    fillColor = '#fff5f5';
                } else if (conn.type === 'structure') {
                    markerClass += ' structure';
                    radius = 12;
                    fillColor = '#f0fff0';
                }
                
                const marker = L.circleMarker(conn.point, {
                    radius: radius,
                    fillColor: fillColor,
                    color: getUtilityColor(utilityData.type),
                    weight: 3,
                    opacity: 1,
                    fillOpacity: 1,
                    className: `${markerClass} ${utilityData.type}`
                });
                
                // Add subtle animation delay for visual effect
                setTimeout(() => {
                marker.addTo(AppState.layers.utilities[utilityData.type]);
                }, index * 100);
                
                // Store connection marker reference
                if (!utilityData.connectionMarkers) {
                    utilityData.connectionMarkers = [];
                }
                utilityData.connectionMarkers.push(marker);
            });
        }
    }

    function getUtilityColor(type) {
        const colors = {
            water: '#00b4d8',
            gas: '#ffd60a',
            electric: '#ff006e',
            sewer: '#a8763e',
            telecom: '#b565d8'
        };
        return colors[type] || '#000000';
    }

    // Structure functions
    function toggleStructureMenu() {
        // If currently placing a structure, cancel it
        if (AppState.addingStructure) {
            cancelStructurePlacement();
            return;
        }
        
        const menu = document.getElementById('structureMenu');
        if (!menu) {
            console.error('❌ Structure menu element not found!');
            showToast('Structure menu not found', 'error');
            return;
        }
        
        const isActive = menu.classList.contains('active');
        
        if (isActive) {
            menu.classList.remove('active');
            console.log('📋 Structure menu closed');
        } else {
            menu.classList.add('active');
            console.log('📋 Structure menu opened, checking visibility...');
            
            // Debug menu visibility
            setTimeout(() => {
                const computedStyle = window.getComputedStyle(menu);
                console.log('Menu display:', computedStyle.display);
                console.log('Menu visibility:', computedStyle.visibility);
                console.log('Menu z-index:', computedStyle.zIndex);
                console.log('Menu position:', {
                    bottom: computedStyle.bottom,
                    right: computedStyle.right,
                    width: computedStyle.width,
                    height: computedStyle.height
                });
            }, 100);
            
            showToast('👆 Structure menu opened above green button', 'info');
        }
        
        hapticFeedback(30);
    }

    function startAddingStructure(structureType, utilityType) {
        console.log('🏗️ Starting to add structure:', { structureType, utilityType });
        
        AppState.addingStructure = true;
        AppState.structureToAdd = {
            type: structureType,
            utilityType: utilityType
        };
        
        // Close menu
        document.getElementById('structureMenu').classList.remove('active');
        
        // Add visual feedback to structure button
        document.getElementById('addStructureBtn').classList.add('active');
        
        // Change cursor to crosshair for better UX
        document.getElementById('map').style.cursor = 'crosshair';
        
        showToast(`Tap on map to place ${getStructureName(structureType)}`, 'success');
        hapticFeedback(50);
    }
    
    function getStructureName(structureType) {
        const names = {
            electricBox: 'Electric Box',
            catchBasin: 'Catch Basin',
            sewerManhole: 'Sewer Manhole',
            waterManhole: 'Water Manhole',
            gasManhole: 'Gas Manhole',
            gasValve: 'Gas Valve',
            hydrantValve: 'Hydrant',
            telecomBox: 'Telecom Box'
        };
        return names[structureType] || structureType;
    }

    function addStructure(latlng) {
        if (!AppState.structureToAdd) {
            console.warn('⚠️ No structure to add');
            return;
        }

        console.log('🏗️ Adding structure at:', latlng);

        const structureData = {
            id: generateId(),
            type: AppState.structureToAdd.type,
            utilityType: AppState.structureToAdd.utilityType,
            latlng: latlng,
            dateAdded: new Date().toISOString()
        };

        // Add to state
        AppState.structures.push(structureData);

        // Create marker
        createStructureMarker(structureData);

        // Save
        saveStructures();
        syncToCloud();

        // Reset cursor and state
        document.getElementById('map').style.cursor = '';
        document.getElementById('addStructureBtn').classList.remove('active');
        AppState.addingStructure = false;
        AppState.structureToAdd = null;

        const structureName = getStructureName(structureData.type);
        showToast(`✅ ${structureName} added successfully!`, 'success');
        hapticFeedback(100);
        
        console.log('✅ Structure added:', structureData);
    }
    
    function cancelStructurePlacement() {
        if (AppState.addingStructure) {
            console.log('❌ Cancelling structure placement');
            
            // Reset cursor and state
            document.getElementById('map').style.cursor = '';
            document.getElementById('addStructureBtn').classList.remove('active');
            AppState.addingStructure = false;
            AppState.structureToAdd = null;
            
            // Close menu if open
            document.getElementById('structureMenu').classList.remove('active');
            
            showToast('Structure placement cancelled', 'info');
            hapticFeedback(30);
        }
    }

    function createStructureMarker(structureData) {
        const icons = {
            electricBox: 'fa-bolt',
            catchBasin: 'fa-water',
            sewerManhole: 'fa-circle',
            waterManhole: 'fa-tint',
            gasManhole: 'fa-fire',
            gasValve: 'fa-wrench',
            hydrantValve: 'fa-fire-extinguisher',
            telecomBox: 'fa-network-wired'
        };

        const icon = L.divIcon({
            className: '',
            html: `<div class="structure-marker ${structureData.utilityType}">
                <i class="fas ${icons[structureData.type]}"></i>
            </div>`,
            iconSize: [48, 48],
            iconAnchor: [24, 24]
        });

        const marker = L.marker(structureData.latlng, { icon: icon });
        
        // Add click handler
        marker.on('click', () => {
            showStructureInfo(structureData);
        });

        // Store reference
        structureData.marker = marker;

        // Add to layer
        marker.addTo(AppState.layers.structures[structureData.utilityType]);

        // Apply current zoom-based opacity
        const currentZoom = AppState.map.getZoom();
        const opacity = calculateZoomOpacity(currentZoom);
        if (marker._icon) {
            marker._icon.style.opacity = opacity;
        }
    }

    function showStructureInfo(structureData) {
        const structureNames = {
            electricBox: 'Electrical Box',
            catchBasin: 'Catch Basin',
            sewerManhole: 'Sewer Manhole',
            waterManhole: 'Water Manhole',
            gasManhole: 'Gas Manhole',
            gasValve: 'Gas Valve',
            hydrantValve: 'Hydrant Valve',
            telecomBox: 'Telecom Box'
        };

        showToast(`${structureNames[structureData.type]}`, 'info');
    }

    // Info Modal functions
    function showInfoModal(utilityData) {
        console.log('📋 Opening info modal for utility:', utilityData?.id);
        AppState.selectedUtilityData = utilityData;
        
        // Update modal content
        document.getElementById('modalIcon').className = getUtilityIcon(utilityData.type);
        document.getElementById('modalIcon').style.color = getUtilityColor(utilityData.type);
        document.getElementById('modalTitle').textContent = `${capitalizeFirst(utilityData.type)} ${capitalizeFirst(utilityData.lineType)} Line`;
        
        document.getElementById('infoType').textContent = capitalizeFirst(utilityData.type);
        document.getElementById('infoLineType').textContent = capitalizeFirst(utilityData.lineType);
        document.getElementById('infoSize').textContent = utilityData.size ? `${utilityData.size}"` : 'Not specified';
        document.getElementById('infoDepth').textContent = utilityData.depth ? `${utilityData.depth}'` : 'Not specified';
        document.getElementById('infoMaterial').textContent = utilityData.material || 'Not specified';
        document.getElementById('infoCondition').textContent = utilityData.condition || 'Not specified';
        document.getElementById('infoCurbDistance').textContent = utilityData.curbDistance ? `${utilityData.curbDistance}'` : 'Not specified';
        document.getElementById('infoDate').textContent = new Date(utilityData.dateAdded).toLocaleDateString();

        // Load notes
        loadNotes(utilityData);

        // Show view mode, hide edit mode
        document.getElementById('viewMode').style.display = 'block';
        document.getElementById('editMode').classList.remove('active');

        // Show modal
        document.getElementById('infoModal').classList.add('active');
    }

    function closeInfoModal() {
        document.getElementById('infoModal').classList.remove('active');
        // Don't clear selectedUtilityData if we're entering refine mode
        if (!AppState.refineMode) {
        AppState.selectedUtilityData = null;
        }
    }

    function getUtilityIcon(type) {
        const icons = {
            water: 'fas fa-tint',
            gas: 'fas fa-fire',
            electric: 'fas fa-bolt',
            sewer: 'fas fa-toilet',
            telecom: 'fas fa-phone'
        };
        return icons[type] || 'fas fa-question';
    }

    function capitalizeFirst(str) {
        return str.charAt(0).toUpperCase() + str.slice(1);
    }

    function enterEditMode() {
        if (!AppState.selectedUtilityData) return;

        // Populate edit form
        document.getElementById('editSize').value = AppState.selectedUtilityData.size || '';
        document.getElementById('editDepth').value = AppState.selectedUtilityData.depth || '';
        document.getElementById('editMaterial').value = AppState.selectedUtilityData.material || '';
        document.getElementById('editCondition').value = AppState.selectedUtilityData.condition || '';
        document.getElementById('editCurbDistance').value = AppState.selectedUtilityData.curbDistance || '';

        // Show edit mode, hide view mode
        document.getElementById('viewMode').style.display = 'none';
        document.getElementById('editMode').classList.add('active');
    }

    function exitEditMode() {
        // Show view mode, hide edit mode
        document.getElementById('viewMode').style.display = 'block';
        document.getElementById('editMode').classList.remove('active');
    }

    function saveEdit() {
        if (!AppState.selectedUtilityData) return;

        // Get and validate input values
        const size = document.getElementById('editSize').value.trim();
        const depth = document.getElementById('editDepth').value.trim();
        const material = document.getElementById('editMaterial').value.trim();
        const condition = document.getElementById('editCondition').value.trim();
        const curbDistance = document.getElementById('editCurbDistance').value.trim();

        // Validate numeric inputs
        if (size && (isNaN(size) || parseFloat(size) < 0)) {
            showToast('Size must be a positive number', 'error');
            return;
        }
        if (depth && (isNaN(depth) || parseFloat(depth) < 0)) {
            showToast('Depth must be a positive number', 'error');
            return;
        }
        if (curbDistance && (isNaN(curbDistance) || parseFloat(curbDistance) < 0)) {
            showToast('Curb distance must be a positive number', 'error');
            return;
        }

        // Update utility data
        AppState.selectedUtilityData.size = size;
        AppState.selectedUtilityData.depth = depth;
        AppState.selectedUtilityData.material = material;
        AppState.selectedUtilityData.condition = condition;
        AppState.selectedUtilityData.curbDistance = curbDistance;

        // Save
        saveUtilities();
        syncToCloud();

        // Exit edit mode and refresh display
        exitEditMode();
        showInfoModal(AppState.selectedUtilityData);
        
        showToast('Utility information updated', 'success');
        hapticFeedback(50);
    }

    // Notes functions
    function loadNotes(utilityData) {
        const notesList = document.getElementById('notesList');
        notesList.innerHTML = '';
        
        if (utilityData.notes && utilityData.notes.length > 0) {
            utilityData.notes.forEach((note, index) => {
                const noteItem = document.createElement('div');
                noteItem.className = 'note-item';
                noteItem.innerHTML = `
                    <p class="note-text">${note.text}</p>
                    <span class="note-date">${new Date(note.date).toLocaleString()}</span>
                    <button class="note-delete" onclick="deleteNote(${index})">
                        <i class="fas fa-times"></i>
                    </button>
                `;
                notesList.appendChild(noteItem);
            });
        } else {
            notesList.innerHTML = '<p style="color: var(--text-tertiary); text-align: center;">No notes yet</p>';
        }
    }

    function showNoteInput() {
        document.getElementById('noteInputModal').classList.add('active');
        document.getElementById('noteTextarea').focus();
    }

    function hideNoteInput() {
        document.getElementById('noteInputModal').classList.remove('active');
        document.getElementById('noteTextarea').value = '';
    }

    function saveNote() {
        const noteText = document.getElementById('noteTextarea').value.trim();
        
        if (!noteText) {
            showToast('Please enter a note', 'warning');
            return;
        }
        
        if (noteText.length > 1000) {
            showToast('Note is too long (max 1000 characters)', 'error');
            return;
        }
        
        if (!AppState.selectedUtilityData) {
            showToast('No utility selected', 'error');
            return;
        }
        
        if (!AppState.selectedUtilityData.notes) {
            AppState.selectedUtilityData.notes = [];
        }
        
        AppState.selectedUtilityData.notes.push({
            text: noteText,
            date: new Date().toISOString()
        });
        
        saveUtilities();
        syncToCloud();
        loadNotes(AppState.selectedUtilityData);
        hideNoteInput();
        showToast('Note added', 'success');
        hapticFeedback(50);
    }

    function deleteNote(index) {
        if (!AppState.selectedUtilityData || !AppState.selectedUtilityData.notes) return;
        
        AppState.selectedUtilityData.notes.splice(index, 1);
        saveUtilities();
        syncToCloud();
        loadNotes(AppState.selectedUtilityData);
        showToast('Note deleted', 'success');
    }

    window.deleteNote = deleteNote;

    // Premium Refine Location - Completely Rebuilt for Reliability
    function startRefineLocation() {
        if (!AppState.selectedUtilityData) {
            console.error('❌ No selectedUtilityData found');
            showToast('No utility selected for refining', 'error');
            return;
        }

        console.log('🔧 Starting refine mode for utility:', AppState.selectedUtilityData.id);
        
        // Store reference to prevent accidental clearing
        const utilityToRefine = AppState.selectedUtilityData;
        
        // Cancel any other active modes
        if (AppState.addingStructure) {
            cancelStructurePlacement();
        }
        
        // Set refine mode FIRST
        AppState.refineMode = true;
        AppState.refineMarkers = [];
        
        // Close modal and show overlay
        closeInfoModal();

        // Ensure selectedUtilityData is still available
        AppState.selectedUtilityData = utilityToRefine;
        
        document.getElementById('refineOverlay').classList.add('active');

        // Highlight the utility line
        if (AppState.selectedUtilityData.lineLayer) {
            AppState.selectedUtilityData.lineLayer.setStyle({
                weight: AppState.selectedUtilityData.lineType === 'main' ? 12 : 10,
                opacity: 1,
                className: `utility-line ${AppState.selectedUtilityData.type} ${AppState.selectedUtilityData.lineType} highlighted`
            });
        }

        // Create simple, numbered refine markers
        const points = AppState.selectedUtilityData.points;
        points.forEach((point, index) => {
            createRefineMarker(point, index, false); // false = vertex marker
        });
        
        // Create intermediate markers for adding new points
        for (let i = 0; i < points.length - 1; i++) {
            const start = points[i];
            const end = points[i + 1];
            const midPoint = L.latLng(
                (start.lat + end.lat) / 2,
                (start.lng + end.lng) / 2
            );
            createRefineMarker(midPoint, i + 0.5, true); // true = intermediate marker
        }

        // Zoom to utility
        const bounds = L.latLngBounds(points);
        AppState.map.fitBounds(bounds, { 
            padding: [100, 100],
            maxZoom: 20
        });

        showToast(`Refine mode active - ${points.length} points to adjust. Drag + markers to add new points!`, 'success');
        hapticFeedback(100);
    }

    function createRefineMarker(latlng, index, isIntermediate = false) {
        const isVertex = !isIntermediate;
        
        const marker = L.marker(latlng, {
            icon: L.divIcon({
                className: 'refine-marker',
                html: isVertex 
                    ? `<div class="refine-point" title="Point ${Math.floor(index) + 1} - Drag to move">${Math.floor(index) + 1}</div>`
                    : `<div class="refine-point intermediate" title="Drag to create new point" style="width: 28px; height: 28px; font-size: 12px; background: linear-gradient(135deg, #e6f3ff 0%, #cce7ff 100%); border-color: #4d94ff;">+</div>`,
                iconSize: isVertex ? [40, 40] : [28, 28],
                iconAnchor: isVertex ? [20, 20] : [14, 14]
            }),
            draggable: true,
            zIndexOffset: isVertex ? 10000 : 9500
        });

        // Store marker properties
        marker.pointIndex = index;
        marker.utilityId = AppState.selectedUtilityData.id;
        marker.isIntermediate = isIntermediate;
        marker.originalPosition = L.latLng(latlng.lat, latlng.lng);

        // Enhanced drag events for mobile
        let isDragging = false;
        
        marker.on('dragstart', (e) => {
            isDragging = true;
            const displayIndex = isVertex ? Math.floor(index) + 1 : 'new';
            console.log(`📍 Starting drag of ${isVertex ? 'point' : 'intermediate'} ${displayIndex}`);
            
            // Visual feedback
            if (marker._icon) {
                const pointElement = marker._icon.querySelector('.refine-point');
                if (pointElement) {
                    pointElement.classList.add('dragging');
                }
            }
            
            // Disable map dragging
            AppState.map.dragging.disable();
            AppState.map.scrollWheelZoom.disable();
            
            const message = isVertex ? `Moving point ${displayIndex}` : 'Creating new point';
            showToast(message, 'info');
            hapticFeedback(50);
        });

        marker.on('drag', (e) => {
            if (!isDragging) return;
            
            // Update the line in real-time
                updateRefinedLine();
            hapticFeedback(5);
        });

        marker.on('dragend', (e) => {
                isDragging = false;
            const displayIndex = isVertex ? Math.floor(index) + 1 : 'new';
            console.log(`✅ Finished drag of ${isVertex ? 'point' : 'intermediate'} ${displayIndex}`);
            
            // Check if intermediate marker should become vertex
            if (isIntermediate) {
                const currentPos = marker.getLatLng();
                const distance = currentPos.distanceTo(marker.originalPosition);
                
                if (distance > 10) { // 10 meters threshold to create new vertex
                    console.log('🆕 Converting intermediate marker to vertex');
                    convertIntermediateToVertex(marker);
                    showToast('New point created!', 'success');
                    hapticFeedback(100);
                } else {
                    // If not moved far enough, snap back to middle
                    marker.setLatLng(marker.originalPosition);
                }
            }
            
            // Visual feedback reset
            if (marker._icon) {
                const pointElement = marker._icon.querySelector('.refine-point');
                if (pointElement) {
                    pointElement.classList.remove('dragging');
                }
            }
            
            // Re-enable map interactions
            setTimeout(() => {
                AppState.map.dragging.enable();
                AppState.map.scrollWheelZoom.enable();
            }, 100);
            
            // Final line update
            updateRefinedLine();
                hapticFeedback(30);
        });

        // Add to map and store reference
        marker.addTo(AppState.map);
        AppState.refineMarkers.push(marker);
        
        console.log(`✨ Created ${isVertex ? 'vertex' : 'intermediate'} marker ${index} at`, latlng);
    }

    function convertIntermediateToVertex(intermediateMarker) {
        const insertAfterIndex = Math.floor(intermediateMarker.pointIndex);
        
        // Convert the marker to a vertex
        intermediateMarker.isIntermediate = false;
        intermediateMarker.pointIndex = insertAfterIndex + 1;
        
        // Update all subsequent vertex markers' indices
        AppState.refineMarkers.forEach(marker => {
            if (!marker.isIntermediate && marker !== intermediateMarker && marker.pointIndex > insertAfterIndex) {
                marker.pointIndex += 1;
                
                // Update the visual number
                if (marker._icon) {
                    const pointElement = marker._icon.querySelector('.refine-point');
                    if (pointElement && !pointElement.classList.contains('intermediate')) {
                        pointElement.textContent = Math.floor(marker.pointIndex) + 1;
                        pointElement.title = `Point ${Math.floor(marker.pointIndex) + 1} - Drag to move`;
                    }
                }
            }
        });
        
        // Update the converted marker's appearance
        const newIcon = L.divIcon({
            className: 'refine-marker',
            html: `<div class="refine-point" title="Point ${Math.floor(intermediateMarker.pointIndex) + 1} - Drag to move">${Math.floor(intermediateMarker.pointIndex) + 1}</div>`,
            iconSize: [40, 40],
            iconAnchor: [20, 20]
        });
        intermediateMarker.setIcon(newIcon);
        intermediateMarker.setZIndexOffset(10000);
        
        // Recreate intermediate markers between all vertices
        recreateIntermediateMarkers();
        
        console.log('🔄 Updated marker indices and recreated intermediates');
    }

    function recreateIntermediateMarkers() {
        // Remove all existing intermediate markers
        const intermediateMarkers = AppState.refineMarkers.filter(m => m.isIntermediate);
        intermediateMarkers.forEach(marker => {
            AppState.map.removeLayer(marker);
        });
        
        // Remove them from the array
        AppState.refineMarkers = AppState.refineMarkers.filter(m => !m.isIntermediate);
        
        // Get all vertex markers sorted by index
        const vertexMarkers = AppState.refineMarkers
            .filter(m => !m.isIntermediate)
            .sort((a, b) => a.pointIndex - b.pointIndex);
        
        // Create new intermediate markers between each pair of vertices
        for (let i = 0; i < vertexMarkers.length - 1; i++) {
            const start = vertexMarkers[i].getLatLng();
            const end = vertexMarkers[i + 1].getLatLng();
            const midPoint = L.latLng(
                (start.lat + end.lat) / 2,
                (start.lng + end.lng) / 2
            );
            
            createRefineMarker(midPoint, vertexMarkers[i].pointIndex + 0.5, true);
        }
    }

    function updateRefinedLine() {
        if (!AppState.selectedUtilityData || !AppState.selectedUtilityData.lineLayer || !AppState.refineMode) {
            return;
        }

        try {
            // Get current positions from vertex markers only, sorted by index
            const currentPoints = AppState.refineMarkers
                .filter(marker => !marker.isIntermediate)
                .sort((a, b) => a.pointIndex - b.pointIndex)
                .map(marker => marker.getLatLng());
            
            if (currentPoints.length >= 2) {
                // Update the line on the map
                AppState.selectedUtilityData.lineLayer.setLatLngs(currentPoints);
                console.log(`📏 Updated line with ${currentPoints.length} vertex points`);
            }
        } catch (error) {
            console.error('Error updating refined line:', error);
        }
    }

    function finishRefining() {
        console.log('🔍 Checking refine state:', {
            selectedUtilityData: !!AppState.selectedUtilityData,
            refineMode: AppState.refineMode,
            markersCount: AppState.refineMarkers?.length || 0
        });
        
        if (!AppState.selectedUtilityData) {
            console.error('❌ No selectedUtilityData available');
            showToast('No utility data available for refining', 'error');
            return;
        }
        
        if (!AppState.refineMode) {
            console.error('❌ Refine mode not active');
            showToast('Refine mode not active', 'warning');
            return;
        }

        try {
            console.log('💾 Finishing refine mode...');
            
            // Get final positions from vertex markers only
            const finalPoints = AppState.refineMarkers
                .filter(marker => !marker.isIntermediate)
                .sort((a, b) => a.pointIndex - b.pointIndex)
                .map(marker => marker.getLatLng());

            if (finalPoints.length >= 2) {
                // Update utility data
                AppState.selectedUtilityData.points = [...finalPoints];
                console.log(`📍 Updated utility with ${finalPoints.length} points`);
            }
            
            // Clean up refine markers
            AppState.refineMarkers.forEach((marker, index) => {
                if (AppState.map.hasLayer(marker)) {
            AppState.map.removeLayer(marker);
                }
        });

            // Reset line styling
        if (AppState.selectedUtilityData.lineLayer) {
            AppState.selectedUtilityData.lineLayer.setStyle({
                    weight: AppState.selectedUtilityData.lineType === 'main' ? 8 : 6,
                    opacity: 1,
                className: `utility-line ${AppState.selectedUtilityData.type} ${AppState.selectedUtilityData.lineType}`
            });
                
                // Ensure line is updated with final points
                AppState.selectedUtilityData.lineLayer.setLatLngs(AppState.selectedUtilityData.points);
        }

            // Clear refine state
        AppState.refineMode = false;
        AppState.refineMarkers = [];
        
        // Hide overlay
        document.getElementById('refineOverlay').classList.remove('active');

            // Re-enable map interactions
            AppState.map.dragging.enable();
            AppState.map.scrollWheelZoom.enable();

            // Save changes
        saveUtilities();
            if (AppState.cloudSync.enabled) {
        syncToCloud();
            }

            showToast('✅ Location refined and saved!', 'success');
            hapticFeedback(200);
            
            console.log('🎉 Refine mode completed successfully');
            
        } catch (error) {
            console.error('❌ Error finishing refining:', error);
            showToast('Error saving refined location', 'error');
            
            // Emergency cleanup
            AppState.refineMode = false;
            AppState.refineMarkers.forEach(marker => {
                try {
                    if (AppState.map.hasLayer(marker)) {
                        AppState.map.removeLayer(marker);
                    }
                } catch (e) { /* ignore */ }
            });
            AppState.refineMarkers = [];
            document.getElementById('refineOverlay').classList.remove('active');
            AppState.map.dragging.enable();
            AppState.map.scrollWheelZoom.enable();
        }
    }

    function deleteUtility() {
        if (!AppState.selectedUtilityData) return;

        if (confirm('Are you sure you want to delete this utility line?')) {
            // Remove from map
            if (AppState.selectedUtilityData.lineLayer) {
                AppState.map.removeLayer(AppState.selectedUtilityData.lineLayer);
            }
            
            // Remove connection markers if they exist
            if (AppState.selectedUtilityData.connectionMarkers) {
                AppState.selectedUtilityData.connectionMarkers.forEach(marker => {
                    if (AppState.map.hasLayer(marker)) {
                        AppState.map.removeLayer(marker);
                    }
                });
            }

            // Remove from state
            const index = AppState.utilities.findIndex(u => u.id === AppState.selectedUtilityData.id);
            if (index > -1) {
                AppState.utilities.splice(index, 1);
            }

            saveUtilities();
            syncToCloud();
            closeInfoModal();
            showToast('Utility deleted', 'success');
            hapticFeedback(50);
        }
    }

    // Excavation Mode
    function toggleExcavationMode() {
        if (AppState.excavationMode) {
            exitExcavationMode();
        } else {
            enterExcavationMode();
        }
    }

    function enterExcavationMode() {
        console.log('Entering excavation mode...');
        
        AppState.excavationMode = true;
        document.getElementById('excavationBtn').classList.add('active');
        document.getElementById('excavationOverlay').classList.add('active');

        // Enhanced utility visibility during excavation
        enhanceUtilityVisibilityForExcavation();
        
        // Initialize toggle state
        const toggleBtn = document.getElementById('alertToggleBtn');
        const toggleIcon = toggleBtn.querySelector('i');
        if (AppState.proximityAlertsVisible) {
            toggleBtn.classList.remove('alerts-hidden');
            toggleIcon.className = 'fas fa-eye';
            toggleBtn.title = 'Hide proximity alerts';
        } else {
            toggleBtn.classList.add('alerts-hidden');
            toggleIcon.className = 'fas fa-eye-slash';
            toggleBtn.title = 'Show proximity alerts';
            document.getElementById('proximityAlerts').classList.add('hidden');
        }

        // Check if user location is available
        if (!AppState.userLocation) {
            console.log('User location not available, requesting location...');
            showToast('Getting your location for excavation mode...', 'info');
            
            // Try to get current location
            if (navigator.geolocation) {
                navigator.geolocation.getCurrentPosition(
                    position => {
                        const { latitude, longitude } = position.coords;
                        AppState.userLocation = [latitude, longitude];
                        console.log('Got user location:', AppState.userLocation);
                        
                        // Update user marker if it exists
                        if (AppState.userMarker) {
                            AppState.userMarker.setLatLng([latitude, longitude]);
                        }
                        
                        // Zoom to location and start checking
            AppState.map.setView(AppState.userLocation, 20);
                        checkProximity();
                        showExcavationModeStatus();
                    },
                    error => {
                        console.error('Location error:', error);
                        showToast('Location required for excavation mode. Please enable location services.', 'error');
                        exitExcavationMode();
                    },
                    { enableHighAccuracy: true, timeout: 10000, maximumAge: 60000 }
                );
            } else {
                showToast('Location services not available', 'error');
                exitExcavationMode();
                return;
            }
        } else {
            console.log('Using existing user location:', AppState.userLocation);
            // Zoom to user location
            AppState.map.setView(AppState.userLocation, 20);
            
            // Start proximity checking immediately
        checkProximity();
            showExcavationModeStatus();
        }

        // Start periodic proximity checking
        AppState.proximityInterval = setInterval(checkProximity, 2000); // Check every 2 seconds

        console.log('Excavation mode setup complete', {
            userLocation: AppState.userLocation,
            utilitiesCount: AppState.utilities.length,
            intervalId: AppState.proximityInterval
        });

        // Strong haptic feedback
        hapticFeedback(200);
        setTimeout(() => hapticFeedback(200), 200);
        setTimeout(() => hapticFeedback(200), 400);
    }

    function showExcavationModeStatus() {
        const utilitiesCount = AppState.utilities.length;
        if (utilitiesCount === 0) {
            showToast('Excavation mode active - No utilities mapped yet', 'warning');
            console.log('No utilities available for proximity checking');
        } else {
            showToast(`Excavation mode active - Monitoring ${utilitiesCount} utilities`, 'warning');
        }
    }

    // Debug function to create test utilities for testing excavation mode
    function createTestUtility(offsetLat = 0.0001, offsetLng = 0.0001) {
        if (!AppState.userLocation) {
            console.log('Cannot create test utility - no user location');
            return;
        }

        const testUtility = {
            id: generateId(),
            type: 'water',
            lineType: 'main',
            points: [
                L.latLng(AppState.userLocation[0] + offsetLat, AppState.userLocation[1] + offsetLng),
                L.latLng(AppState.userLocation[0] + offsetLat + 0.0001, AppState.userLocation[1] + offsetLng + 0.0001)
            ],
            size: '8',
            depth: '4',
            material: 'Cast Iron',
            condition: 'Good',
            curbDistance: '6',
            dateAdded: new Date().toISOString(),
            connections: [],
            notes: []
        };

        AppState.utilities.push(testUtility);
        createUtilityLine(testUtility);
        saveUtilities();
        
        console.log('Created test utility:', testUtility);
        return testUtility;
    }

    // Make debug function available globally for testing
    window.createTestUtility = createTestUtility;
    
    // Quick Test Function for New Refine Feature
    function createTestUtilityForRefining() {
        try {
            if (AppState.utilities.length > 0) {
                console.log('✅ Opening first utility for testing refine...');
                showInfoModal(AppState.utilities[0]);
                return AppState.utilities[0];
            }
            
            let testLocation;
            if (AppState.userLocation) {
                testLocation = AppState.userLocation;
            } else {
                testLocation = [40.7128, -74.0060]; // Default NYC
            }
            
            console.log('🧪 Creating test utility for refining at:', testLocation);
            
            const testUtility = {
                id: generateId(),
                type: 'water',
                lineType: 'main',
                points: [
                    L.latLng(testLocation[0] - 0.0003, testLocation[1] - 0.0003),
                    L.latLng(testLocation[0] + 0.0003, testLocation[1] + 0.0003)
                ],
                size: '8',
                depth: '4',
                material: 'Cast Iron',
                condition: 'Good',
                curbDistance: '6',
                dateAdded: new Date().toISOString(),
                connections: [],
                notes: []
            };

            AppState.utilities.push(testUtility);
            createUtilityLine(testUtility);
            saveUtilities();
            
            console.log('✨ Test utility created with 2 points for refining');
            showToast('🔧 Test utility created! Long press line → Edit → Refine. Drag + to add points!', 'success');
            
            // Zoom to the test utility
            const bounds = L.latLngBounds(testUtility.points);
            AppState.map.fitBounds(bounds, { padding: [80, 80] });
            
            return testUtility;
        } catch (error) {
            console.error('❌ Error creating test utility:', error);
            showToast('Error creating test utility', 'error');
            return null;
        }
    }
    
    // Make it available globally for testing
    window.createTestUtilityForRefining = createTestUtilityForRefining;

    function exitExcavationMode() {
        AppState.excavationMode = false;
        document.getElementById('excavationBtn').classList.remove('active');
        document.getElementById('excavationOverlay').classList.remove('active');

        // Reset utility visibility
        resetUtilityVisibilityFromExcavation();

        // Clear proximity alerts and reset visibility
        clearProximityAlerts();
        document.getElementById('proximityAlerts').classList.remove('hidden');

        // Stop proximity checking
        if (AppState.proximityInterval) {
            clearInterval(AppState.proximityInterval);
        }

        showToast('Excavation mode deactivated', 'info');
        hapticFeedback(50);
    }

    function checkProximity() {
        if (!AppState.userLocation || !AppState.excavationMode) {
            console.log('Proximity check skipped:', {
                userLocation: !!AppState.userLocation,
                excavationMode: AppState.excavationMode
            });
            return;
        }

        const alertsContainer = document.getElementById('proximityAlerts');
        const radius = 15; // 15 feet in meters
        const radiusMeters = radius * 0.3048;

        console.log('Checking proximity:', {
            userLocation: AppState.userLocation,
            radiusMeters: radiusMeters,
            utilitiesCount: AppState.utilities.length
        });

        // Track which utilities are in range
        const inRangeUtilities = new Set();

        // Check each utility
        AppState.utilities.forEach((utility, index) => {
            // Skip if utility is not visible
            if (!AppState.layers.visibility[utility.type] || 
                !AppState.layers.visibility[utility.lineType]) {
                console.log(`Utility ${index} skipped - not visible:`, {
                    type: utility.type,
                    lineType: utility.lineType,
                    typeVisible: AppState.layers.visibility[utility.type],
                    lineTypeVisible: AppState.layers.visibility[utility.lineType]
                });
                return;
            }

            // Calculate distance to utility line
            const distance = calculateDistanceToLine(AppState.userLocation, utility.points);
            
            console.log(`Utility ${index} distance:`, {
                id: utility.id,
                type: utility.type,
                lineType: utility.lineType,
                distance: distance,
                radiusMeters: radiusMeters,
                inRange: distance <= radiusMeters
            });
            
            if (distance <= radiusMeters) {
                inRangeUtilities.add(utility.id);
                
                // Check if already alerted and not dismissed
                const alertId = `alert-${utility.id}`;
                const existingAlert = document.getElementById(alertId);
                const dismissedTime = AppState.dismissedAlerts.get(utility.id);
                
                if (dismissedTime) {
                    // Check if 3 minutes have passed
                    if (Date.now() - dismissedTime < 180000) {
                        console.log(`Alert for ${utility.id} dismissed recently`);
                        return;
                    }
                    AppState.dismissedAlerts.delete(utility.id);
                }

                if (!existingAlert) {
                    console.log(`Creating new proximity alert for utility ${utility.id}`);
                    createProximityAlert(utility, distance);
                } else {
                    console.log(`Updating existing alert for utility ${utility.id}`);
                    updateProximityAlert(utility, distance);
                }
            }
        });

        console.log('In-range utilities:', Array.from(inRangeUtilities));

        // Handle alerts for utilities that are out of range
        AppState.alertTimeouts.forEach((timeout, utilityId) => {
            if (!inRangeUtilities.has(utilityId)) {
                // Start or continue timeout
                if (!timeout) {
                    AppState.alertTimeouts.set(utilityId, Date.now());
                }
            } else {
                // In range again, clear timeout
                AppState.alertTimeouts.delete(utilityId);
            }
        });

        // Remove alerts that have been out of range for 45 seconds
        AppState.alertTimeouts.forEach((startTime, utilityId) => {
            if (Date.now() - startTime > 45000) {
                removeProximityAlert(utilityId);
                AppState.alertTimeouts.delete(utilityId);
            }
        });
    }

    function calculateDistanceToLine(point, linePoints) {
        let minDistance = Infinity;

        for (let i = 0; i < linePoints.length - 1; i++) {
            const distance = distanceToLineSegment(point, linePoints[i], linePoints[i + 1]);
            minDistance = Math.min(minDistance, distance);
        }

        return minDistance;
    }

    function distanceToLineSegment(point, lineStart, lineEnd) {
        const startLat = lineStart.lat || lineStart[0];
        const startLng = lineStart.lng || lineStart[1];
        const endLat = lineEnd.lat || lineEnd[0];
        const endLng = lineEnd.lng || lineEnd[1];

        const A = point[0] - startLat;
        const B = point[1] - startLng;
        const C = endLat - startLat;
        const D = endLng - startLng;

        const dot = A * C + B * D;
        const lenSq = C * C + D * D;
        let param = -1;

        if (lenSq !== 0) {
            param = dot / lenSq;
        }

        let closestLat, closestLng;

        if (param < 0) {
            // Closest point is the start of the segment
            closestLat = startLat;
            closestLng = startLng;
        } else if (param > 1) {
            // Closest point is the end of the segment
            closestLat = endLat;
            closestLng = endLng;
        } else {
            // Closest point is somewhere along the segment
            closestLat = startLat + param * C;
            closestLng = startLng + param * D;
        }

        // Calculate distance using Haversine formula for better accuracy
        const R = 6371000; // Earth's radius in meters
        const φ1 = point[0] * Math.PI / 180;
        const φ2 = closestLat * Math.PI / 180;
        const Δφ = (closestLat - point[0]) * Math.PI / 180;
        const Δλ = (closestLng - point[1]) * Math.PI / 180;

        const a = Math.sin(Δφ / 2) * Math.sin(Δφ / 2) +
                  Math.cos(φ1) * Math.cos(φ2) *
                  Math.sin(Δλ / 2) * Math.sin(Δλ / 2);
        const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));

        return R * c; // Distance in meters
    }

    function createProximityAlert(utility, distance) {
        // Don't create alerts if they're hidden
        if (!AppState.proximityAlertsVisible) {
            return;
        }
        
        const alertsContainer = document.getElementById('proximityAlerts');
        const alertId = `alert-${utility.id}`;

        const alertDiv = document.createElement('div');
        alertDiv.id = alertId;
        alertDiv.className = `proximity-alert ${utility.type}`;
        alertDiv.innerHTML = `
            <div class="alert-content">
                <div class="alert-header">
                    <div class="alert-icon-container ${utility.type}">
                        <i class="${getUtilityIcon(utility.type)}" aria-hidden="true"></i>
                    </div>
                    <button class="alert-close" onclick="dismissProximityAlert('${utility.id}')" aria-label="Dismiss alert">
                        <i class="fas fa-times" aria-hidden="true"></i>
                    </button>
                </div>
                
                <div class="alert-utility-info">
                    <h3 class="alert-utility-type">${utility.type}</h3>
                    <p class="alert-line-type">${utility.lineType} Line</p>
                </div>
                
                <div class="alert-distance-banner">
                    <span class="distance-value">${Math.round(distance / 0.3048)}</span>
                    <span class="distance-unit">FEET AWAY</span>
                </div>
                
                <div class="alert-details">
                    <div class="detail-item">
                        <span class="detail-label">Size</span>
                        <span class="detail-value">${utility.size ? utility.size + '"' : 'N/A'}</span>
                    </div>
                    <div class="detail-item">
                        <span class="detail-label">Depth</span>
                        <span class="detail-value">${utility.depth ? utility.depth + "'" : 'N/A'}</span>
                    </div>
                    <div class="detail-item">
                        <span class="detail-label">Material</span>
                        <span class="detail-value">${utility.material || 'N/A'}</span>
                    </div>
                    <div class="detail-item">
                        <span class="detail-label">Condition</span>
                        <span class="detail-value">${utility.condition || 'N/A'}</span>
                    </div>
                </div>
            </div>
        `;

        alertsContainer.appendChild(alertDiv);

        // Limit to 5 alerts
        while (alertsContainer.children.length > 5) {
            const firstChild = alertsContainer.firstChild;
            const utilityId = firstChild.id.replace('alert-', '');
            AppState.alertTimeouts.set(utilityId, Date.now());
            alertsContainer.removeChild(firstChild);
        }

        // Haptic feedback for new alert
        hapticFeedback(200);
    }

    function updateProximityAlert(utility, distance) {
        // Don't update alerts if they're hidden
        if (!AppState.proximityAlertsVisible) {
            return;
        }
        
        const alertElement = document.getElementById(`alert-${utility.id}`);
        if (alertElement) {
            const distanceValue = alertElement.querySelector('.distance-value');
            if (distanceValue) {
                distanceValue.textContent = Math.round(distance / 0.3048);
            }
        }
    }

    function removeProximityAlert(utilityId) {
        const alert = document.getElementById(`alert-${utilityId}`);
        if (alert) {
            alert.remove();
        }
    }

    function dismissProximityAlert(utilityId) {
        const alert = document.getElementById(`alert-${utilityId}`);
        if (alert) {
            alert.remove();
            AppState.dismissedAlerts.set(utilityId, Date.now());
            AppState.alertTimeouts.delete(utilityId);
            hapticFeedback(30);
        }
    }

    window.dismissProximityAlert = dismissProximityAlert;

    function clearProximityAlerts() {
        const alertsContainer = document.getElementById('proximityAlerts');
        alertsContainer.innerHTML = '';
        AppState.dismissedAlerts.clear();
        AppState.alertTimeouts.clear();
    }

    function toggleProximityAlerts() {
        AppState.proximityAlertsVisible = !AppState.proximityAlertsVisible;
        const alertsContainer = document.getElementById('proximityAlerts');
        const toggleBtn = document.getElementById('alertToggleBtn');
        const toggleIcon = toggleBtn.querySelector('i');
        
        if (AppState.proximityAlertsVisible) {
            alertsContainer.classList.remove('hidden');
            toggleBtn.classList.remove('alerts-hidden');
            toggleIcon.className = 'fas fa-eye';
            toggleBtn.title = 'Hide proximity alerts';
        } else {
            alertsContainer.classList.add('hidden');
            toggleBtn.classList.add('alerts-hidden');
            toggleIcon.className = 'fas fa-eye-slash';
            toggleBtn.title = 'Show proximity alerts';
        }
        
        hapticFeedback(30);
    }

    function enhanceUtilityVisibilityForExcavation() {
        // Force all utilities to be fully visible and enhanced during excavation
        AppState.utilities.forEach(utility => {
            if (utility.lineLayer) {
                utility.lineLayer.setStyle({
                    opacity: 1.0, // Full opacity regardless of zoom
                    weight: utility.lineType === 'main' ? 12 : 10, // Thicker lines
                    className: `utility-line ${utility.type} ${utility.lineType} excavation-enhanced`
                });
                
                // Add glow effect
                utility.lineLayer.getElement()?.classList.add('excavation-enhanced');
            }
            
            // Enhanced connection markers
            if (utility.connectionMarkers) {
                utility.connectionMarkers.forEach(marker => {
                    if (marker._icon) {
                        marker._icon.style.opacity = '1.0';
                        marker._icon.style.transform = 'scale(1.3)';
                        marker._icon.style.filter = 'drop-shadow(0 0 12px currentColor)';
                    }
                });
            }
        });
        
        // Enhanced structures
        AppState.structures.forEach(structure => {
            if (structure.marker && structure.marker._icon) {
                structure.marker._icon.style.opacity = '1.0';
                structure.marker._icon.style.transform = 'scale(1.4)';
                structure.marker._icon.style.filter = 'drop-shadow(0 0 16px currentColor)';
            }
        });
    }

    function resetUtilityVisibilityFromExcavation() {
        // Reset utilities to normal zoom-based visibility
        const currentZoom = AppState.map.getZoom();
        const zoomOpacity = calculateZoomOpacity(currentZoom);
        
        AppState.utilities.forEach(utility => {
            if (utility.lineLayer) {
                utility.lineLayer.setStyle({
                    opacity: zoomOpacity,
                    weight: utility.lineType === 'main' ? 8 : 6, // Normal thickness
                    className: `utility-line ${utility.type} ${utility.lineType}`
                });
                
                // Remove glow effect
                utility.lineLayer.getElement()?.classList.remove('excavation-enhanced');
            }
            
            // Reset connection markers
            if (utility.connectionMarkers) {
                utility.connectionMarkers.forEach(marker => {
                    if (marker._icon) {
                        marker._icon.style.opacity = zoomOpacity;
                        marker._icon.style.transform = 'scale(1)';
                        marker._icon.style.filter = '';
                    }
                });
            }
        });
        
        // Reset structures
        AppState.structures.forEach(structure => {
            if (structure.marker && structure.marker._icon) {
                structure.marker._icon.style.opacity = zoomOpacity;
                structure.marker._icon.style.transform = 'scale(1)';
                structure.marker._icon.style.filter = '';
            }
        });
    }

    // Measurement Tools
    function toggleMeasureMode(mode) {
        if (AppState.measureMode === mode) {
            // Cancel measurement
            clearMeasurement();
            AppState.measureMode = null;
            document.getElementById('measureDistanceBtn').classList.remove('active');
            document.getElementById('measureAreaBtn').classList.remove('active');
        } else {
            // Start new measurement
            clearMeasurement();
            AppState.measureMode = mode;
            AppState.measurePoints = [];
            
            if (mode === 'distance') {
                document.getElementById('measureDistanceBtn').classList.add('active');
                document.getElementById('measureAreaBtn').classList.remove('active');
                showToast('Click points to measure distance', 'info');
            } else {
                document.getElementById('measureAreaBtn').classList.add('active');
                document.getElementById('measureDistanceBtn').classList.remove('active');
                showToast('Click points to measure area', 'info');
            }
        }
        hapticFeedback(30);
    }

    function addMeasurePoint(latlng) {
        AppState.measurePoints.push(latlng);
        
        // Add marker
        const marker = L.circleMarker(latlng, {
            radius: 6,
            fillColor: '#667eea',
            fillOpacity: 1,
            color: 'white',
            weight: 2
        }).addTo(AppState.map);
        
        AppState.measureMarkers.push(marker);
        
        // Update measurement display
        updateMeasurement();
        
        hapticFeedback(30);
    }

    function updateMeasurement() {
        if (AppState.measureMode === 'distance') {
            // Clear previous line
            if (AppState.measureLine) {
                AppState.map.removeLayer(AppState.measureLine);
            }
            
            if (AppState.measurePoints.length > 1) {
                // Draw line
                AppState.measureLine = L.polyline(AppState.measurePoints, {
                    color: '#667eea',
                    weight: 3,
                    dashArray: '5, 10'
                }).addTo(AppState.map);
                
                // Calculate total distance
                let totalDistance = 0;
                for (let i = 1; i < AppState.measurePoints.length; i++) {
                    totalDistance += AppState.measurePoints[i - 1].distanceTo(AppState.measurePoints[i]);
                }
                
                // Convert to feet
                const distanceFeet = Math.round(totalDistance * 3.28084);
                
                // Show distance
                showMeasurementDisplay(`Distance: ${distanceFeet}'`);
            }
        } else if (AppState.measureMode === 'area') {
            // Clear previous polygon
            if (AppState.measurePolygon) {
                AppState.map.removeLayer(AppState.measurePolygon);
            }
            
            if (AppState.measurePoints.length > 2) {
                // Draw polygon
                AppState.measurePolygon = L.polygon(AppState.measurePoints, {
                    color: '#667eea',
                    weight: 3,
                    fillOpacity: 0.2,
                    dashArray: '5, 10'
                }).addTo(AppState.map);
                
                // Calculate area
                const area = L.GeometryUtil.geodesicArea(AppState.measurePoints);
                const areaFeet = Math.round(area * 10.764); // Convert to square feet
                
                // Show area
                showMeasurementDisplay(`Area: ${areaFeet.toLocaleString()} sq ft`);
            }
        }
    }

    function showMeasurementDisplay(text) {
        // Remove previous display
        const existingDisplay = document.querySelector('.measurement-display');
        if (existingDisplay) {
            existingDisplay.remove();
        }
        
        // Create new display
        const display = document.createElement('div');
        display.className = 'measurement-display';
        display.textContent = text;
        
        // Position at last point
        const lastPoint = AppState.measurePoints[AppState.measurePoints.length - 1];
        const point = AppState.map.latLngToContainerPoint(lastPoint);
        
        display.style.left = `${point.x}px`;
        display.style.top = `${point.y - 40}px`;
        
        document.querySelector('.app-container').appendChild(display);
    }

    function clearMeasurement() {
        // Clear markers
        AppState.measureMarkers.forEach(marker => {
            AppState.map.removeLayer(marker);
        });
        AppState.measureMarkers = [];
        
        // Clear lines/polygons
        if (AppState.measureLine) {
            AppState.map.removeLayer(AppState.measureLine);
            AppState.measureLine = null;
        }
        if (AppState.measurePolygon) {
            AppState.map.removeLayer(AppState.measurePolygon);
            AppState.measurePolygon = null;
        }
        
        // Clear display
        const display = document.querySelector('.measurement-display');
        if (display) {
            display.remove();
        }
        
        AppState.measurePoints = [];
    }

    // Settings
    function openSettings() {
        document.getElementById('settingsPanel').classList.add('active');
    }

    function closeSettings() {
        document.getElementById('settingsPanel').classList.remove('active');
    }

    function toggleLayersPanel() {
        openSettings();
    }

    function setTheme(theme) {
        AppState.theme = theme;
        document.documentElement.setAttribute('data-theme', theme);
        localStorage.setItem('theme', theme);
        
        const darkModeToggle = document.getElementById('darkModeToggle');
        if (theme === 'dark') {
            darkModeToggle.classList.add('active');
            if (AppState.currentMapStyle === 'streets') {
                changeMapStyle('dark');
            }
        } else {
            darkModeToggle.classList.remove('active');
            if (AppState.currentMapStyle === 'dark') {
                changeMapStyle('streets');
            }
        }
    }

    function toggleDarkMode() {
        const newTheme = AppState.theme === 'light' ? 'dark' : 'light';
        setTheme(newTheme);
        hapticFeedback(30);
    }

    function changeMapStyle(style) {
        // Update active button
        document.querySelectorAll('.map-style-btn').forEach(btn => {
            btn.classList.toggle('active', btn.dataset.style === style);
        });

        // Change map tiles
        AppState.map.eachLayer(layer => {
            if (layer instanceof L.TileLayer) {
                AppState.map.removeLayer(layer);
            }
        });

        L.tileLayer(AppState.mapStyles[style], {
            maxZoom: 22,
            maxNativeZoom: 19
        }).addTo(AppState.map);

        AppState.currentMapStyle = style;
        hapticFeedback(30);
    }

    function toggleUtilityVisibility(toggle) {
        const utility = toggle.dataset.utility;
        const isActive = toggle.classList.toggle('active');
        AppState.layers.visibility[utility] = isActive;

        // Show/hide layers
        if (isActive) {
            AppState.map.addLayer(AppState.layers.utilities[utility]);
            AppState.map.addLayer(AppState.layers.structures[utility]);
        } else {
            AppState.map.removeLayer(AppState.layers.utilities[utility]);
            AppState.map.removeLayer(AppState.layers.structures[utility]);
        }
        hapticFeedback(30);
    }

    function toggleLineTypeVisibility(toggle) {
        const lineType = toggle.dataset.linetype;
        const isActive = toggle.classList.toggle('active');
        AppState.layers.visibility[lineType] = isActive;

        // Update utility visibility
        updateUtilityVisibility();
        hapticFeedback(30);
    }

    function updateUtilityVisibility() {
        const currentZoom = AppState.map.getZoom();
        const zoomOpacity = calculateZoomOpacity(currentZoom);
        
        AppState.utilities.forEach(utility => {
            if (utility.lineLayer) {
                const shouldShow = AppState.layers.visibility[utility.type] && 
                                 AppState.layers.visibility[utility.lineType];
                
                if (shouldShow) {
                    // Apply zoom-based opacity when visible
                    const isHighlighted = utility.lineLayer.options.className && 
                                        utility.lineLayer.options.className.includes('highlighted');
                    const isBeingRefined = AppState.refineMode && 
                                         AppState.selectedUtilityData && 
                                         utility.id === AppState.selectedUtilityData.id;
                    const finalOpacity = (isHighlighted || isBeingRefined) ? 1.0 : zoomOpacity;
                    
                    utility.lineLayer.setStyle({ opacity: finalOpacity });
                } else {
                    // Completely hidden when type is disabled
                    utility.lineLayer.setStyle({ opacity: 0 });
                }
            }
        });
    }

    // Cloud Sync functions
    function toggleCloudSync() {
        const toggle = document.getElementById('cloudSyncToggle');
        const isActive = toggle.classList.toggle('active');
        
        if (isActive) {
            enableCloudSync();
        } else {
            disableCloudSync();
        }
        
        localStorage.setItem('cloudSyncEnabled', isActive);
        hapticFeedback(30);
    }

    function enableCloudSync() {
        AppState.cloudSync.enabled = true;
        document.getElementById('cloudSyncToggle').classList.add('active');
        
        // Initialize cloud sync (implement actual cloud service)
        initializeCloudSync();
        syncToCloud();
    }

    function disableCloudSync() {
        AppState.cloudSync.enabled = false;
        document.getElementById('cloudSyncToggle').classList.remove('active');
    }

    function initializeCloudSync() {
        // This would connect to your actual cloud service
        // For now, we'll use a mock implementation
        AppState.cloudSync.userId = localStorage.getItem('userId') || generateId();
        localStorage.setItem('userId', AppState.cloudSync.userId);
    }

    function syncToCloud() {
        if (!AppState.cloudSync.enabled) return;
        
        showSyncStatus();
        
        // Mock cloud sync - replace with actual API calls
        setTimeout(() => {
            AppState.cloudSync.lastSync = new Date().toISOString();
            hideSyncStatus();
            console.log('Data synced to cloud');
        }, 1000);
    }

    function showSyncStatus() {
        document.getElementById('syncStatus').classList.add('show');
    }

    function hideSyncStatus() {
        setTimeout(() => {
            document.getElementById('syncStatus').classList.remove('show');
        }, 2000);
    }

    // Utility functions
    function generateId() {
        return Date.now().toString(36) + Math.random().toString(36).substr(2);
    }

    function saveUtilities() {
        try {
        const data = AppState.utilities.map(u => ({
            id: u.id,
            type: u.type,
            lineType: u.lineType,
            points: u.points,
            size: u.size,
            depth: u.depth,
            material: u.material,
            condition: u.condition,
            curbDistance: u.curbDistance,
            dateAdded: u.dateAdded,
            connections: u.connections,
            notes: u.notes || []
        }));
        localStorage.setItem('utilities', JSON.stringify(data));
        } catch (error) {
            console.error('Error saving utilities:', error);
            showToast('Error saving data. Storage may be full.', 'error');
        }
    }

    function loadUtilities() {
        const saved = localStorage.getItem('utilities');
        if (saved) {
            try {
                const data = JSON.parse(saved);
                data.forEach(utilityData => {
                    // Ensure notes array exists
                    utilityData.notes = utilityData.notes || [];
                    
                    AppState.utilities.push(utilityData);
                    createUtilityLine(utilityData);
                });
            } catch (e) {
                console.error('Error loading utilities:', e);
            }
        }
    }

    function saveStructures() {
        try {
        const data = AppState.structures.map(s => ({
            id: s.id,
            type: s.type,
            utilityType: s.utilityType,
            latlng: s.latlng,
            dateAdded: s.dateAdded
        }));
        localStorage.setItem('structures', JSON.stringify(data));
        } catch (error) {
            console.error('Error saving structures:', error);
            showToast('Error saving structure data.', 'error');
        }
    }

    function loadStructures() {
        const saved = localStorage.getItem('structures');
        if (saved) {
            try {
                const data = JSON.parse(saved);
                data.forEach(structureData => {
                    AppState.structures.push(structureData);
                    createStructureMarker(structureData);
                });
            } catch (e) {
                console.error('Error loading structures:', e);
            }
        }
    }

    function showToast(message, type = 'info') {
        const container = document.getElementById('toastContainer');
        const toast = document.createElement('div');
        toast.className = `toast ${type}`;
        
        const icons = {
            success: 'fa-check-circle',
            error: 'fa-exclamation-circle',
            warning: 'fa-exclamation-triangle',
            info: 'fa-info-circle'
        };
        
        toast.innerHTML = `
            <i class="fas ${icons[type]}"></i>
            <span>${message}</span>
        `;
        
        container.appendChild(toast);
        
        setTimeout(() => toast.classList.add('show'), 10);
        
        // Adjust timeout based on message length
        const timeout = type === 'info' && message.length > 50 ? 5000 : 3000;
        
        setTimeout(() => {
            toast.classList.remove('show');
            setTimeout(() => toast.remove(), 300);
        }, timeout);
    }

    // Initialize GeometryUtil for area calculations
    L.GeometryUtil = L.extend(L.GeometryUtil || {}, {
        geodesicArea: function (latLngs) {
            const R = 6378137; // Earth's radius in meters
            let area = 0;
            const len = latLngs.length;
            let x1, y1, x2, y2;
            
            for (let i = 0; i < len; i++) {
                x1 = latLngs[i].lng * Math.PI / 180;
                y1 = latLngs[i].lat * Math.PI / 180;
                x2 = latLngs[(i + 1) % len].lng * Math.PI / 180;
                y2 = latLngs[(i + 1) % len].lat * Math.PI / 180;
                
                area += (x2 - x1) * (Math.sin(y1) + Math.sin(y2));
            }
            
            area = Math.abs(area * R * R / 2);
            return area;
        }
    });
    
    // Debug function to test refine workflow
    function testRefineWorkflow() {
        console.log('🧪 Testing refine workflow...');
        
        // Step 1: Create test utility if none exist
        if (AppState.utilities.length === 0) {
            console.log('📝 Creating test utility...');
            createTestUtilityForRefining();
            return;
        }
        
        // Step 2: Open info modal for first utility
        const testUtility = AppState.utilities[0];
        console.log('📋 Opening modal for:', testUtility.id);
        showInfoModal(testUtility);
        
        // Step 3: After a short delay, start refining
        setTimeout(() => {
            console.log('🔧 Starting refine mode...');
            startRefineLocation();
        }, 1000);
    }
    
    // Make it available globally for testing
    window.testRefineWorkflow = testRefineWorkflow;
    
    // Test structure functionality
    function testStructureButton() {
        console.log('🧪 Testing structure button functionality...');
        
        // Check if button exists
        const structureBtn = document.getElementById('addStructureBtn');
        if (!structureBtn) {
            console.error('❌ Structure button not found');
            return;
        }
        
        // Check if menu exists
        const structureMenu = document.getElementById('structureMenu');
        if (!structureMenu) {
            console.error('❌ Structure menu not found');
            return;
        }
        
        console.log('✅ Structure button and menu found');
        console.log('📏 Button position:', structureBtn.getBoundingClientRect());
        console.log('📏 Menu position:', structureMenu.getBoundingClientRect());
        
        // Simulate clicking the button
        console.log('🔄 Opening menu...');
        toggleStructureMenu();
        
        setTimeout(() => {
            const isVisible = structureMenu.classList.contains('active');
            const computedStyle = window.getComputedStyle(structureMenu);
            console.log('📋 Menu active:', isVisible);
            console.log('📋 Menu display:', computedStyle.display);
            console.log('📋 Menu visibility:', computedStyle.visibility);
            console.log('📏 Menu bounds after open:', structureMenu.getBoundingClientRect());
            
            if (isVisible && computedStyle.display === 'grid') {
                console.log('✅ Menu is properly visible!');
                showToast('✅ Structure menu test passed!', 'success');
            } else {
                console.error('❌ Menu is not visible properly');
                showToast('❌ Structure menu test failed', 'error');
            }
            
            // Close after 3 seconds
            setTimeout(() => {
                console.log('🔄 Closing menu...');
                toggleStructureMenu();
            }, 3000);
            
        }, 500);
        
        console.log('✅ Structure test initiated');
    }
    
    // Make it available globally for testing
    window.testStructureButton = testStructureButton;
    
    // Test zoom fading functionality
    function testZoomFading() {
        console.log('🔍 Testing zoom-based fading...');
        
        if (AppState.utilities.length === 0) {
            console.log('📝 Creating test utility for zoom testing...');
            createTestUtilityForRefining();
        }
        
        const startZoom = AppState.map.getZoom();
        console.log(`🎯 Starting zoom level: ${startZoom}`);
        
        showToast('🔍 Testing zoom fading - watch utilities fade as we zoom out!', 'info');
        
        // Zoom out gradually to show aggressive fading effect
        let currentZoom = Math.min(startZoom, 20); // Start from max zoom 20
        const zoomOut = () => {
            if (currentZoom > 10) {
                currentZoom -= 1;
                AppState.map.setZoom(currentZoom);
                const opacity = calculateZoomOpacity(currentZoom);
                console.log(`🔍 Zoom ${currentZoom}: Opacity ${opacity.toFixed(2)}`);
                showToast(`Zoom ${currentZoom}: ${Math.round(opacity * 100)}% opacity`, 'info');
                setTimeout(zoomOut, 1200);
            } else {
                // Zoom back in
                console.log('🔄 Zooming back in...');
                setTimeout(() => {
                    const zoomIn = () => {
                        if (currentZoom < startZoom) {
                            currentZoom += 1;
                            AppState.map.setZoom(currentZoom);
                            const opacity = calculateZoomOpacity(currentZoom);
                            console.log(`🔍 Zoom ${currentZoom}: Opacity ${opacity.toFixed(2)}`);
                            setTimeout(zoomIn, 500);
                        } else {
                            console.log('✅ Zoom fading test completed!');
                            showToast('✅ Zoom fading test completed!', 'success');
                        }
                    };
                    zoomIn();
                }, 1000);
            }
        };
        
        setTimeout(zoomOut, 1000);
    }
    
    // Make it available globally for testing
    window.testZoomFading = testZoomFading;
    
    // Enhanced cleanup function for memory management
    function cleanup() {
        console.log('Cleaning up UtiliTrack resources...');
        
        // Location tracking cleanup
        if (AppState.watchId) {
            navigator.geolocation.clearWatch(AppState.watchId);
            AppState.watchId = null;
        }
        
        // Excavation mode cleanup
        if (AppState.proximityInterval) {
            clearInterval(AppState.proximityInterval);
            AppState.proximityInterval = null;
        }
        
        // Clear all alert timeouts
        AppState.alertTimeouts.forEach((timeout, utilityId) => {
            if (timeout && typeof timeout === 'number') {
                clearTimeout(timeout);
            }
        });
        AppState.alertTimeouts.clear();
        
        // Clear refine markers if any exist
        if (AppState.refineMarkers && AppState.refineMarkers.length > 0) {
            AppState.refineMarkers.forEach(marker => {
                try {
                    if (AppState.map && AppState.map.hasLayer(marker)) {
                        AppState.map.removeLayer(marker);
                    }
                } catch (error) {
                    console.error('Error removing refine marker during cleanup:', error);
                }
            });
            AppState.refineMarkers = [];
        }
        
        // Clear refine mode state
        AppState.refineMode = false;
        
        // Run all stored cleanup functions
        if (AppState.cleanupFunctions) {
            AppState.cleanupFunctions.forEach(fn => {
                try {
                    fn();
                } catch (error) {
                    console.error('Error in cleanup function:', error);
                }
            });
        }
        
        console.log('UtiliTrack cleanup completed');
    }
    
    // Cleanup on page unload
    window.addEventListener('beforeunload', cleanup);
    window.addEventListener('pagehide', cleanup);
</script>

</body>
</html>
