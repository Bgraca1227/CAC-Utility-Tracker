<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>CAC UtiliTrack - Precision Utility Mapping</title>
    
    <!-- Leaflet CSS -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/leaflet/1.9.4/leaflet.min.css" />
    <!-- Font Awesome for icons -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.1/css/all.min.css" />
    <!-- Google Fonts -->
    <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap">

    <style>
        /*********************************
        * GLOBAL STYLES & VARIABLES
        *********************************/
        :root {
            /* Brand Colors */
            --primary: #2962ff;
            --primary-dark: #0039cb;
            --primary-light: #768fff;
            --secondary: #ff6e40;
            --secondary-dark: #c53d13;
            --secondary-light: #ffa06d;
            
            /* Utility Type Colors */
            --water-color: #29b6f6;
            --gas-color: #ffb300;
            --electric-color: #ffee58;
            --sewer-color: #8d6e63;
            --telecom-color: #ab47bc;
            
            /* UI Colors */
            --success: #4caf50;
            --warning: #ff9800;
            --danger: #f44336;
            --info: #2196f3;
            
            /* Grayscale */
            --gray-50: #fafafa;
            --gray-100: #f5f5f5;
            --gray-200: #eeeeee;
            --gray-300: #e0e0e0;
            --gray-400: #bdbdbd;
            --gray-500: #9e9e9e;
            --gray-600: #757575;
            --gray-700: #616161;
            --gray-800: #424242;
            --gray-900: #212121;
            
            /* Text */
            --text-primary: var(--gray-900);
            --text-secondary: var(--gray-700);
            --text-disabled: var(--gray-500);
            --text-light: var(--gray-50);
            
            /* Background */
            --bg-main: var(--gray-100);
            --bg-card: white;
            --bg-dark: var(--gray-900);
            
            /* Spacing */
            --space-xs: 4px;
            --space-sm: 8px;
            --space-md: 16px;
            --space-lg: 24px;
            --space-xl: 32px;
            
            /* Border Radius */
            --radius-sm: 4px;
            --radius-md: 8px;
            --radius-lg: 16px;
            --radius-xl: 24px;
            --radius-full: 9999px;
            
            /* Shadows */
            --shadow-sm: 0 1px 3px rgba(0,0,0,0.12), 0 1px 2px rgba(0,0,0,0.24);
            --shadow-md: 0 4px 6px rgba(0,0,0,0.1), 0 1px 3px rgba(0,0,0,0.08);
            --shadow-lg: 0 10px 25px rgba(0,0,0,0.1), 0 2px 10px rgba(0,0,0,0.04);
            --shadow-xl: 0 20px 40px rgba(0,0,0,0.1), 0 5px 10px rgba(0,0,0,0.05);
            
            /* Transitions */
            --transition-fast: 150ms cubic-bezier(0.4, 0, 0.2, 1);
            --transition-normal: 300ms cubic-bezier(0.4, 0, 0.2, 1);
            --transition-slow: 500ms cubic-bezier(0.4, 0, 0.2, 1);
            
            /* Z-index layers */
            --z-back: -1;
            --z-normal: 1;
            --z-tooltip: 10;
            --z-fixed: 100;
            --z-modal: 1000;
            --z-popover: 2000;
            --z-tooltip: 3000;
            --z-toast: 5000;
            --z-splash: 9000;
        }
        
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            -webkit-tap-highlight-color: transparent;
            font-family: 'Inter', system-ui, -apple-system, sans-serif;
        }
        
        html, body {
            height: 100%;
            width: 100%;
            overflow: hidden;
            background-color: var(--bg-main);
            color: var(--text-primary);
        }
        
        button, 
        input, 
        select, 
        textarea {
            font-family: inherit;
        }
        
        button {
            cursor: pointer;
            border: none;
            background: none;
        }
        
        a {
            text-decoration: none;
            color: inherit;
        }
        
        /* Apply smooth scrolling for smoother animations */
        html {
            scroll-behavior: smooth;
        }
        
        /* iOS Safe Area Support */
        @supports(padding: env(safe-area-inset-bottom)) {
            body {
                padding-bottom: env(safe-area-inset-bottom);
            }
        }
        
        /*********************************
        * LAYOUT & APP CONTAINER
        *********************************/
        .app-container {
            position: relative;
            width: 100%;
            height: 100vh;
            height: 100dvh; /* Dynamic viewport height for mobile */
            overflow: hidden;
            display: flex;
            flex-direction: column;
            background-color: var(--bg-main);
        }
        
        /* Map Container */
        .map-container {
            flex: 1;
            position: relative;
            width: 100%;
            overflow: hidden;
            z-index: var(--z-normal);
        }
        
        #map {
            width: 100%;
            height: 100%;
            z-index: var(--z-normal);
        }
        
        /*********************************
        * HEADER
        *********************************/
        .app-header {
            position: relative;
            padding: var(--space-sm) var(--space-md);
            background-color: var(--primary);
            color: white;
            box-shadow: var(--shadow-md);
            z-index: var(--z-fixed);
            display: flex;
            justify-content: space-between;
            align-items: center;
            transition: height var(--transition-normal);
        }
        
        .app-header.minimal {
            height: 40px;
        }
        
        .header-left, 
        .header-right {
            display: flex;
            align-items: center;
            gap: var(--space-sm);
        }
        
        .app-logo {
            display: flex;
            align-items: center;
            gap: var(--space-sm);
            font-weight: 700;
            font-size: 1.2rem;
            color: white;
        }
        
        .logo-icon {
            display: flex;
            align-items: center;
            justify-content: center;
            width: 32px;
            height: 32px;
            border-radius: var(--radius-md);
            background-color: white;
            color: var(--primary);
            font-size: 1rem;
            box-shadow: var(--shadow-sm);
            transform-origin: center;
            transition: transform var(--transition-normal);
        }
        
        .logo-icon:hover {
            transform: scale(1.05);
        }
        
        .logo-text {
            display: flex;
            flex-direction: column;
            line-height: 1;
        }
        
        .app-title {
            font-weight: 700;
            font-size: 16px;
        }
        
        .app-subtitle {
            font-size: 10px;
            font-weight: 500;
            opacity: 0.8;
        }
        
        /*********************************
        * NAVIGATION & TOOLBARS
        *********************************/
        /* Main Navigation */
        .nav-bar {
            position: fixed;
            bottom: 0;
            left: 0;
            right: 0;
            display: flex;
            justify-content: center;
            padding: var(--space-sm);
            background-color: var(--bg-card);
            box-shadow: var(--shadow-lg);
            z-index: var(--z-fixed);
            transform: translateY(0);
            transition: transform var(--transition-normal);
        }
        
        .nav-bar.hidden {
            transform: translateY(100%);
        }
        
        .nav-bar-inner {
            display: flex;
            gap: var(--space-md);
            padding: var(--space-xs) var(--space-sm);
            background-color: var(--bg-card);
            border-radius: var(--radius-full);
            box-shadow: var(--shadow-sm);
        }
        
        .nav-button {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            padding: var(--space-sm);
            color: var(--gray-600);
            border-radius: var(--radius-full);
            transition: background-color var(--transition-fast),
                        color var(--transition-fast);
            gap: 2px;
        }
        
        .nav-button:active {
            transform: scale(0.95);
        }
        
        .nav-button.active {
            background-color: var(--primary-light);
            color: white;
        }
        
        .nav-button i {
            font-size: 1.25rem;
        }
        
        .nav-label {
            font-size: 0.65rem;
            font-weight: 500;
        }
        
        /* Utility Toolbar */
        .utility-toolbar {
            position: absolute;
            top: calc(var(--space-lg) + 50px);
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            background-color: var(--bg-card);
            border-radius: var(--radius-full);
            box-shadow: var(--shadow-md);
            padding: var(--space-xs);
            z-index: var(--z-fixed);
            overflow-x: auto;
            max-width: 85%;
            scrollbar-width: none;
            -ms-overflow-style: none;
        }
        
        .utility-toolbar::-webkit-scrollbar {
            display: none; /* Hide scrollbar for Chrome, Safari and Opera */
        }
        
        .utility-button {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            padding: var(--space-xs) var(--space-sm);
            color: var(--gray-600);
            border-radius: var(--radius-full);
            transition: background-color var(--transition-fast),
                        color var(--transition-fast),
                        transform var(--transition-fast);
            gap: 2px;
            min-width: 48px; /* Reduced from 60px */
        }
        
        .utility-button:active {
            transform: scale(0.95);
        }
        
        .utility-button i {
            font-size: 1rem; /* Reduced from 1.25rem */
        }
        
        .utility-label {
            font-size: 0.6rem; /* Reduced from 0.65rem */
            font-weight: 500;
        }
        
        /* Utility Type Coloring */
        .utility-button.water {
            color: var(--water-color);
        }
        
        .utility-button.gas {
            color: var(--gas-color);
        }
        
        .utility-button.electric {
            color: var(--electric-color);
        }
        
        .utility-button.sewer {
            color: var(--sewer-color);
        }
        
        .utility-button.telecom {
            color: var(--telecom-color);
        }
        
        .utility-button.water.active {
            background-color: var(--water-color);
            color: white;
        }
        
        .utility-button.gas.active {
            background-color: var(--gas-color);
            color: white;
        }
        
        .utility-button.electric.active {
            background-color: var(--electric-color);
            color: black;
        }
        
        .utility-button.sewer.active {
            background-color: var(--sewer-color);
            color: white;
        }
        
        .utility-button.telecom.active {
            background-color: var(--telecom-color);
            color: white;
        }
        
        /* Action Buttons */
        .action-buttons {
            position: absolute;
            right: var(--space-md);
            bottom: 100px; /* Above navbar */
            display: flex;
            flex-direction: column;
            gap: var(--space-md);
            z-index: var(--z-fixed);
        }
        
        .action-button {
            width: 56px;
            height: 56px;
            display: flex;
            align-items: center;
            justify-content: center;
            background-color: var(--bg-card);
            color: var(--primary);
            border-radius: var(--radius-full);
            box-shadow: var(--shadow-lg);
            font-size: 1.5rem;
            transition: transform var(--transition-fast),
                        background-color var(--transition-fast);
        }
        
        .action-button.primary {
            background-color: var(--primary);
            color: white;
        }
        
        .action-button.danger {
            background-color: var(--danger);
            color: white;
        }
        
        .action-button.warning {
            background-color: var(--warning);
            color: white;
        }
        
        .action-button:active {
            transform: scale(0.95);
        }
        
        /* Tool Options Container */
        .tool-options {
            position: absolute;
            left: var(--space-md);
            top: calc(var(--space-lg) + 50px); /* Align with other controls */
            display: flex;
            flex-direction: column;
            gap: var(--space-sm);
            z-index: var(--z-fixed);
        }
        
        .tool-button {
            width: 48px;
            height: 48px;
            display: flex;
            align-items: center;
            justify-content: center;
            background-color: var(--bg-card);
            color: var(--gray-600);
            border-radius: var(--radius-full);
            box-shadow: var(--shadow-md);
            transition: background-color var(--transition-fast),
                        color var(--transition-fast),
                        transform var(--transition-fast);
        }
        
        .tool-button:active {
            transform: scale(0.95);
        }
        
        .tool-button.active {
            background-color: var(--primary);
            color: white;
        }
        
        /* Mode Toggle */
        .mode-toggle {
            position: absolute;
            left: 50%;
            bottom: calc(100px + var(--space-lg)); /* Above navbar */
            transform: translateX(-50%);
            display: flex;
            background-color: var(--bg-card);
            border-radius: var(--radius-full);
            box-shadow: var(--shadow-md);
            padding: var(--space-xs);
            z-index: var(--z-fixed);
            overflow: hidden;
        }
        
        .mode-button {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: var(--space-xs);
            padding: var(--space-sm) var(--space-md);
            color: var(--gray-600);
            font-weight: 600;
            font-size: 0.875rem;
            border-radius: var(--radius-full);
            transition: background-color var(--transition-fast),
                        color var(--transition-fast);
        }
        
        .mode-button.active {
            background-color: var(--primary);
            color: white;
        }
        
        /*********************************
        * MODALS & DIALOGS
        *********************************/
        .modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: rgba(0, 0, 0, 0.5);
            backdrop-filter: blur(3px);
            z-index: var(--z-modal);
            display: flex;
            align-items: center;
            justify-content: center;
            opacity: 0;
            visibility: hidden;
            transition: opacity var(--transition-normal),
                        visibility var(--transition-normal);
        }
        
        .modal-overlay.visible {
            opacity: 1;
            visibility: visible;
        }
        
        .modal-container {
            background-color: var(--bg-card);
            border-radius: var(--radius-lg);
            box-shadow: var(--shadow-xl);
            width: 90%;
            max-width: 400px;
            max-height: 80vh;
            overflow: hidden;
            display: flex;
            flex-direction: column;
            transform: translateY(20px);
            opacity: 0;
            transition: transform var(--transition-normal),
                        opacity var(--transition-normal);
        }
        
        .modal-overlay.visible .modal-container {
            transform: translateY(0);
            opacity: 1;
        }
        
        .modal-header {
            padding: var(--space-md);
            display: flex;
            justify-content: space-between;
            align-items: center;
            border-bottom: 1px solid var(--gray-200);
        }
        
        .modal-title {
            font-weight: 600;
            font-size: 1.125rem;
        }
        
        .modal-close {
            width: 32px;
            height: 32px;
            display: flex;
            align-items: center;
            justify-content: center;
            color: var(--gray-500);
            border-radius: var(--radius-full);
            transition: background-color var(--transition-fast),
                        color var(--transition-fast);
        }
        
        .modal-close:hover {
            background-color: var(--gray-100);
            color: var(--gray-700);
        }
        
        .modal-body {
            padding: var(--space-md);
            overflow-y: auto;
            flex: 1;
        }
        
        .modal-footer {
            padding: var(--space-md);
            display: flex;
            justify-content: flex-end;
            gap: var(--space-md);
            border-top: 1px solid var(--gray-200);
        }
        
        /* Slide-up Panels */
        .panel-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: rgba(0, 0, 0, 0.25);
            z-index: var(--z-modal);
            display: flex;
            align-items: flex-end;
            justify-content: center;
            opacity: 0;
            visibility: hidden;
            transition: opacity var(--transition-normal),
                        visibility var(--transition-normal);
        }
        
        .panel-overlay.visible {
            opacity: 1;
            visibility: visible;
        }
        
        .panel-container {
            background-color: var(--bg-card);
            border-radius: var(--radius-lg) var(--radius-lg) 0 0;
            box-shadow: var(--shadow-xl);
            width: 100%;
            max-height: 80vh;
            overflow: hidden;
            display: flex;
            flex-direction: column;
            transform: translateY(100%);
            transition: transform var(--transition-normal);
        }
        
        .panel-overlay.visible .panel-container {
            transform: translateY(0);
        }
        
        .panel-handle {
            width: 40px;
            height: 5px;
            background-color: var(--gray-300);
            border-radius: var(--radius-full);
            margin: var(--space-sm) auto;
        }
        
        .panel-header {
            padding: var(--space-md);
            display: flex;
            justify-content: space-between;
            align-items: center;
            border-bottom: 1px solid var(--gray-200);
        }
        
        .panel-title {
            font-weight: 600;
            font-size: 1.125rem;
        }
        
        .panel-body {
            padding: var(--space-md);
            overflow-y: auto;
            flex: 1;
        }
        
        .panel-footer {
            padding: var(--space-md);
            display: flex;
            justify-content: space-between;
            border-top: 1px solid var(--gray-200);
        }
        
        /*********************************
        * FORMS & INPUT ELEMENTS
        *********************************/
        .form-group {
            margin-bottom: var(--space-md);
        }
        
        .form-label {
            display: block;
            font-weight: 500;
            font-size: 0.875rem;
            margin-bottom: var(--space-xs);
            color: var(--text-secondary);
        }
        
        .form-control {
            width: 100%;
            padding: var(--space-md);
            border: 1px solid var(--gray-300);
            border-radius: var(--radius-md);
            background-color: var(--bg-card);
            font-size: 1rem;
            color: var(--text-primary);
            transition: border-color var(--transition-fast),
                        box-shadow var(--transition-fast);
        }
        
        .form-control:focus {
            outline: none;
            border-color: var(--primary);
            box-shadow: 0 0 0 3px rgba(41, 98, 255, 0.1);
        }
        
        .form-control::placeholder {
            color: var(--gray-400);
        }
        
        select.form-control {
            appearance: none;
            background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='24' height='24' viewBox='0 0 24 24' fill='none' stroke='%23757575' stroke-width='2' stroke-linecap='round' stroke-linejoin='round'%3E%3Cpolyline points='6 9 12 15 18 9'%3E%3C/polyline%3E%3C/svg%3E");
            background-repeat: no-repeat;
            background-position: right 12px center;
            background-size: 16px;
            padding-right: 40px;
        }
        
        /* Checkboxes and Radio Buttons */
        .checkbox-group,
        .radio-group {
            display: flex;
            gap: var(--space-md);
            margin-top: var(--space-xs);
        }
        
        .checkbox-item,
        .radio-item {
            display: flex;
            align-items: center;
            gap: var(--space-xs);
            cursor: pointer;
        }
        
        .checkbox-item input,
        .radio-item input {
            cursor: pointer;
        }
        
        /* Utility Type Selection */
        .utility-selection {
            display: flex;
            flex-wrap: wrap;
            gap: var(--space-md);
            margin-bottom: var(--space-md);
        }
        
        .utility-option {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: var(--space-xs);
            width: calc(20% - var(--space-md) * 0.8);
            padding: var(--space-sm);
            border-radius: var(--radius-md);
            border: 2px solid transparent;
            transition: border-color var(--transition-fast),
                        transform var(--transition-fast);
            cursor: pointer;
        }
        
        .utility-option:active {
            transform: scale(0.95);
        }
        
        .utility-option.water:hover,
        .utility-option.water.selected {
            border-color: var(--water-color);
            background-color: rgba(41, 182, 246, 0.1);
        }
        
        .utility-option.gas:hover,
        .utility-option.gas.selected {
            border-color: var(--gas-color);
            background-color: rgba(255, 179, 0, 0.1);
        }
        
        .utility-option.electric:hover,
        .utility-option.electric.selected {
            border-color: var(--electric-color);
            background-color: rgba(255, 238, 88, 0.1);
        }
        
        .utility-option.sewer:hover,
        .utility-option.sewer.selected {
            border-color: var(--sewer-color);
            background-color: rgba(141, 110, 99, 0.1);
        }
        
        .utility-option.telecom:hover,
        .utility-option.telecom.selected {
            border-color: var(--telecom-color);
            background-color: rgba(171, 71, 188, 0.1);
        }
        
        .utility-option-icon {
            font-size: 1.5rem;
        }
        
        .utility-option-label {
            font-size: 0.75rem;
            font-weight: 500;
            text-align: center;
        }
        
        .utility-option.water .utility-option-icon {
            color: var(--water-color);
        }
        
        .utility-option.gas .utility-option-icon {
            color: var(--gas-color);
        }
        
        .utility-option.electric .utility-option-icon {
            color: var(--electric-color);
        }
        
        .utility-option.sewer .utility-option-icon {
            color: var(--sewer-color);
        }
        
        .utility-option.telecom .utility-option-icon {
            color: var(--telecom-color);
        }
        
        /* Structure Type Selection */
        .structure-selection {
            display: flex;
            flex-wrap: wrap;
            gap: var(--space-md);
            margin-bottom: var(--space-md);
        }
        
        .structure-option {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: var(--space-xs);
            width: calc(33.33% - var(--space-md) * 0.67);
            padding: var(--space-md);
            border-radius: var(--radius-md);
            border: 2px solid transparent;
            transition: border-color var(--transition-fast),
                        transform var(--transition-fast);
            cursor: pointer;
        }
        
        .structure-option:active {
            transform: scale(0.95);
        }
        
        .structure-option:hover,
        .structure-option.selected {
            border-color: var(--primary);
            background-color: rgba(41, 98, 255, 0.05);
        }
        
        .structure-option-icon {
            font-size: 1.5rem;
            color: var(--primary);
        }
        
        .structure-option-label {
            font-size: 0.75rem;
            font-weight: 500;
            text-align: center;
        }
        
        /* Buttons */
        .btn {
            display: inline-flex;
            align-items: center;
            justify-content: center;
            padding: var(--space-sm) var(--space-lg);
            border-radius: var(--radius-md);
            font-weight: 500;
            font-size: 0.875rem;
            text-align: center;
            transition: background-color var(--transition-fast),
                        transform var(--transition-fast);
            cursor: pointer;
        }
        
        .btn:active {
            transform: scale(0.98);
        }
        
        .btn-primary {
            background-color: var(--primary);
            color: white;
        }
        
        .btn-primary:hover {
            background-color: var(--primary-dark);
        }
        
        .btn-secondary {
            background-color: var(--gray-200);
            color: var(--gray-800);
        }
        
        .btn-secondary:hover {
            background-color: var(--gray-300);
        }
        
        .btn-danger {
            background-color: var(--danger);
            color: white;
        }
        
        .btn-danger:hover {
            background-color: #d32f2f;
        }
        
        .btn-block {
            display: flex;
            width: 100%;
        }
        
        .btn-lg {
            padding: var(--space-md) var(--space-xl);
            font-size: 1rem;
        }
        
        .btn-sm {
            padding: var(--space-xs) var(--space-md);
            font-size: 0.75rem;
        }
        
        .btn-icon {
            gap: var(--space-xs);
        }
        
        /*********************************
        * MAP UTILITIES & MARKERS
        *********************************/
        /* Map Controls */
        .map-controls {
            position: absolute;
            right: var(--space-md);
            top: calc(var(--space-lg) + 50px); /* Move below the layer control */
            display: flex;
            flex-direction: column;
            gap: var(--space-sm);
            z-index: var(--z-fixed);
        }
        
        .map-control-button {
            width: 48px;
            height: 48px;
            display: flex;
            align-items: center;
            justify-content: center;
            background-color: var(--bg-card);
            color: var(--gray-600);
            border-radius: var(--radius-full);
            box-shadow: var(--shadow-md);
            transition: background-color var(--transition-fast),
                        color var(--transition-fast),
                        transform var(--transition-fast);
        }
        
        .map-control-button:active {
            transform: scale(0.95);
        }
        
        /* Status Bar */
        .status-bar {
            position: absolute;
            bottom: calc(100px + var(--space-xl)); /* Above navbar */
            left: 50%;
            transform: translateX(-50%);
            padding: var(--space-sm) var(--space-lg);
            background-color: var(--bg-dark);
            color: white;
            border-radius: var(--radius-full);
            font-size: 0.75rem;
            font-weight: 500;
            box-shadow: var(--shadow-md);
            z-index: var(--z-fixed);
            display: flex;
            align-items: center;
            gap: var(--space-sm);
            opacity: 0;
            transition: opacity var(--transition-normal);
        }
        
        .status-bar.visible {
            opacity: 1;
        }
        
        .status-bar i {
            font-size: 0.875rem;
        }
        
        /* Map Indicators */
        .tap-indicator {
            position: absolute;
            width: 40px;
            height: 40px;
            margin-left: -20px;
            margin-top: -20px;
            border-radius: 50%;
            border: 2px solid white;
            background-color: rgba(41, 98, 255, 0.2);
            box-shadow: 0 0 0 4px rgba(41, 98, 255, 0.3);
            animation: pulse 2s infinite;
            pointer-events: none;
            z-index: var(--z-normal);
        }
        
        @keyframes pulse {
            0% {
                transform: scale(0.8);
                opacity: 1;
            }
            70% {
                transform: scale(1.5);
                opacity: 0;
            }
            100% {
                transform: scale(0.8);
                opacity: 0;
            }
        }
        
        /* Utility Icons */
        .utility-marker {
            display: flex;
            align-items: center;
            justify-content: center;
            width: 36px;
            height: 36px;
            border-radius: 50%;
            background-color: white;
            color: var(--primary);
            border: 2px solid currentColor;
            box-shadow: var(--shadow-md);
            font-size: 1rem;
            position: relative;
        }
        
        .utility-marker::after {
            content: "";
            position: absolute;
            top: 100%;
            left: 50%;
            margin-left: -8px;
            border-width: 8px;
            border-style: solid;
            border-color: white transparent transparent transparent;
        }
        
        .utility-marker.water {
            color: var(--water-color);
        }
        
        .utility-marker.gas {
            color: var(--gas-color);
        }
        
        .utility-marker.electric {
            color: var(--electric-color);
        }
        
        .utility-marker.sewer {
            color: var(--sewer-color);
        }
        
        .utility-marker.telecom {
            color: var(--telecom-color);
        }
        
        /* Structure Icons */
        .structure-marker {
            display: flex;
            align-items: center;
            justify-content: center;
            width: 40px;
            height: 40px;
            border-radius: 8px;
            background-color: white;
            color: var(--primary);
            border: 2px solid currentColor;
            box-shadow: var(--shadow-md);
            font-size: 1.25rem;
        }
        
        .structure-marker.water {
            color: var(--water-color);
        }
        
        .structure-marker.gas {
            color: var(--gas-color);
        }
        
        .structure-marker.electric {
            color: var(--electric-color);
        }
        
        .structure-marker.sewer {
            color: var(--sewer-color);
        }
        
        .structure-marker.telecom {
            color: var(--telecom-color);
        }
        
        /* Utility Lines */
        .utility-line {
            stroke-width: 5;
            stroke-linecap: round;
            stroke-linejoin: round;
            fill: none;
        }
        
        .utility-line.main {
            stroke-width: 6;
        }
        
        .utility-line.service {
            stroke-width: 4;
        }
        
        .utility-line.water {
            stroke: var(--water-color);
        }
        
        .utility-line.gas {
            stroke: var(--gas-color);
        }
        
        .utility-line.electric {
            stroke: var(--electric-color);
        }
        
        .utility-line.sewer {
            stroke: var(--sewer-color);
        }
        
        .utility-line.telecom {
            stroke: var(--telecom-color);
        }
        
        /* Measurement Line */
        .measure-line {
            stroke: var(--primary);
            stroke-width: 2;
            stroke-dasharray: 5, 5;
            fill: none;
        }
        
        .measure-label {
            background-color: var(--primary);
            color: white;
            padding: 4px 8px;
            border-radius: 4px;
            font-size: 0.75rem;
            font-weight: 600;
            box-shadow: var(--shadow-sm);
            white-space: nowrap;
        }
        
        /* Annotation Markers */
        .annotation-marker {
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 4px 8px;
            border-radius: 4px;
            background-color: rgba(255, 255, 255, 0.9);
            border: 1px solid var(--gray-300);
            color: var(--text-primary);
            font-size: 0.75rem;
            font-weight: 500;
            box-shadow: var(--shadow-sm);
            max-width: 120px;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }
        
        /*********************************
        * CONTEXT MENU
        *********************************/
        .context-menu {
            position: absolute;
            background-color: var(--bg-card);
            border-radius: var(--radius-md);
            box-shadow: var(--shadow-lg);
            padding: var(--space-xs) 0;
            z-index: var(--z-popover);
            min-width: 160px;
            transition: opacity var(--transition-fast),
                        transform var(--transition-fast);
            transform-origin: top left;
            transform: scale(0.95);
            opacity: 0;
            visibility: hidden;
        }
        
        .context-menu.visible {
            transform: scale(1);
            opacity: 1;
            visibility: visible;
        }
        
        .context-menu-item {
            padding: var(--space-sm) var(--space-md);
            display: flex;
            align-items: center;
            gap: var(--space-sm);
            color: var(--text-primary);
            font-weight: 400;
            font-size: 0.875rem;
            transition: background-color var(--transition-fast);
            cursor: pointer;
        }
        
        .context-menu-item:hover {
            background-color: var(--gray-100);
        }
        
        .context-menu-item.danger {
            color: var(--danger);
        }
        
        .context-menu-divider {
            width: 100%;
            height: 1px;
            background-color: var(--gray-200);
            margin: var(--space-xs) 0;
        }
        
        /*********************************
        * NOTIFICATIONS & TOASTS
        *********************************/
        .notification-container {
            position: fixed;
            top: calc(var(--space-lg) + 10px);
            left: 50%;
            transform: translateX(-50%);
            z-index: var(--z-toast);
            display: flex;
            flex-direction: column;
            gap: var(--space-sm);
            width: 90%;
            max-width: 320px;
            pointer-events: none;
        }
        
        .toast {
            background-color: var(--bg-dark);
            color: white;
            border-radius: var(--radius-md);
            padding: var(--space-md);
            box-shadow: var(--shadow-lg);
            display: flex;
            align-items: center;
            gap: var(--space-sm);
            font-size: 0.875rem;
            opacity: 0;
            transform: translateY(-20px);
            transition: opacity var(--transition-normal),
                        transform var(--transition-normal);
            width: 100%;
            pointer-events: auto;
        }
        
        .toast.visible {
            opacity: 1;
            transform: translateY(0);
        }
        
        .toast-icon {
            flex-shrink: 0;
            font-size: 1rem;
        }
        
        .toast-content {
            flex: 1;
        }
        
        .toast-close {
            flex-shrink: 0;
            width: 24px;
            height: 24px;
            display: flex;
            align-items: center;
            justify-content: center;
            color: var(--gray-400);
            border-radius: var(--radius-full);
            cursor: pointer;
            transition: background-color var(--transition-fast),
                        color var(--transition-fast);
        }
        
        .toast-close:hover {
            background-color: rgba(255, 255, 255, 0.1);
            color: white;
        }
        
        .toast.success {
            background-color: var(--success);
        }
        
        .toast.error {
            background-color: var(--danger);
        }
        
        .toast.warning {
            background-color: var(--warning);
            color: var(--gray-900);
        }
        
        .toast.info {
            background-color: var(--info);
        }
        
        /*********************************
        * CONFIRMATION DIALOG
        *********************************/
        .confirm-dialog {
            background-color: var(--bg-card);
            border-radius: var(--radius-lg);
            box-shadow: var(--shadow-xl);
            width: 90%;
            max-width: 320px;
            padding: var(--space-lg);
            text-align: center;
            transform: scale(0.9);
            opacity: 0;
            transition: transform var(--transition-normal),
                        opacity var(--transition-normal);
        }
        
        .confirm-dialog.visible {
            transform: scale(1);
            opacity: 1;
        }
        
        .confirm-dialog-icon {
            font-size: 3rem;
            color: var(--warning);
            margin-bottom: var(--space-md);
        }
        
        .confirm-dialog-title {
            font-weight: 600;
            font-size: 1.25rem;
            margin-bottom: var(--space-sm);
        }
        
        .confirm-dialog-message {
            color: var(--text-secondary);
            margin-bottom: var(--space-lg);
            font-size: 0.875rem;
        }
        
        .confirm-dialog-buttons {
            display: flex;
            justify-content: space-between;
            gap: var(--space-md);
        }
        
        /*********************************
        * HIGH ACCURACY REPOSITIONING
        *********************************/
        .reposition-control-panel {
            position: absolute;
            bottom: var(--space-lg);
            left: 50%;
            transform: translateX(-50%);
            background-color: var(--bg-card);
            border-radius: var(--radius-md);
            padding: var(--space-md);
            box-shadow: var(--shadow-lg);
            display: flex;
            flex-direction: column;
            gap: var(--space-md);
            z-index: var(--z-fixed);
            width: 90%;
            max-width: 320px;
            opacity: 0;
            visibility: hidden;
            transition: opacity var(--transition-normal),
                        visibility var(--transition-normal);
        }
        
        .reposition-control-panel.visible {
            opacity: 1;
            visibility: visible;
        }
        
        .reposition-panel-heading {
            font-weight: 600;
            font-size: 0.875rem;
            text-align: center;
            color: var(--primary);
        }
        
        .reposition-buttons {
            display: flex;
            justify-content: space-between;
            gap: var(--space-md);
        }
        
        /* Enhanced styling for control points */
        .edit-control-point {
            width: 16px !important;
            height: 16px !important;
            border-radius: 50%;
            background-color: white !important;
            border: 3px solid var(--primary) !important;
            cursor: move;
            transition: transform var(--transition-fast), background-color var(--transition-fast);
            box-shadow: var(--shadow-sm);
        }
        
        .edit-control-point:hover {
            transform: scale(1.5);
            background-color: var(--primary-light) !important;
        }
        
        /* Add styles for the zoom warning */
        .zoom-warning {
            position: absolute;
            top: calc(var(--space-xl) + 10px);
            left: 50%;
            transform: translateX(-50%);
            background-color: var(--warning);
            color: var(--gray-900);
            padding: var(--space-sm) var(--space-md);
            border-radius: var(--radius-md);
            box-shadow: var(--shadow-md);
            font-size: 0.875rem;
            font-weight: 500;
            z-index: var(--z-toast); /* Ensure it's above other elements */
            display: flex;
            align-items: center;
            gap: var(--space-sm);
            opacity: 0;
            visibility: hidden;
            transition: opacity var(--transition-normal),
                        visibility var(--transition-normal);
            max-width: 80%;
        }
        
        .zoom-warning.visible {
            opacity: 1;
            visibility: visible;
        }
        
        /*********************************
        * ANIMATIONS
        *********************************/
        @keyframes fadeIn {
            from {
                opacity: 0;
            }
            to {
                opacity: 1;
            }
        }
        
        @keyframes fadeOut {
            from {
                opacity: 1;
            }
            to {
                opacity: 0;
            }
        }
        
        @keyframes slideUp {
            from {
                transform: translateY(40px);
                opacity: 0;
            }
            to {
                transform: translateY(0);
                opacity: 1;
            }
        }
        
        @keyframes slideDown {
            from {
                transform: translateY(-40px);
                opacity: 0;
            }
            to {
                transform: translateY(0);
                opacity: 1;
            }
        }
        
        @keyframes scale {
            from {
                transform: scale(0.8);
                opacity: 0;
            }
            to {
                transform: scale(1);
                opacity: 1;
            }
        }
        
        @keyframes spin {
            from {
                transform: rotate(0deg);
            }
            to {
                transform: rotate(360deg);
            }
        }
        
        @keyframes progress {
            from {
                width: 0;
            }
            to {
                width: 100%;
            }
        }
        
        /* Animation Utility Classes */
        .animate-fade-in {
            animation: fadeIn var(--transition-normal) forwards;
        }
        
        .animate-fade-out {
            animation: fadeOut var(--transition-normal) forwards;
        }
        
        .animate-slide-up {
            animation: slideUp var(--transition-normal) forwards;
        }
        
        .animate-slide-down {
            animation: slideDown var(--transition-normal) forwards;
        }
        
        .animate-scale {
            animation: scale var(--transition-normal) forwards;
        }
        
        .animate-spin {
            animation: spin 1s linear infinite;
        }
        
        /*********************************
        * SPLASH SCREEN
        *********************************/
        .splash-screen {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: var(--primary);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            color: white;
            z-index: var(--z-splash);
            transition: opacity var(--transition-slow);
        }
        
        .splash-logo {
            font-size: 3rem;
            margin-bottom: var(--space-md);
            animation: pulse 2s infinite;
        }
        
        .splash-title {
            font-size: 1.5rem;
            font-weight: 700;
            margin-bottom: var(--space-xs);
        }
        
        .splash-subtitle {
            font-size: 0.875rem;
            opacity: 0.8;
        }
        
        .splash-progress {
            width: 200px;
            height: 4px;
            background-color: rgba(255, 255, 255, 0.2);
            border-radius: var(--radius-full);
            margin-top: var(--space-xl);
            overflow: hidden;
        }
        
        .splash-progress-bar {
            height: 100%;
            background-color: white;
            border-radius: var(--radius-full);
            width: 0;
            animation: progress 2s ease-in-out forwards;
        }
        
        /*********************************
        * UTILITY INFO CARD
        *********************************/
        .utility-info-card {
            position: absolute;
            background-color: var(--bg-card);
            border-radius: var(--radius-lg);
            box-shadow: var(--shadow-lg);
            padding: var(--space-md);
            z-index: var(--z-fixed);
            max-width: 300px;
            width: 90%;
            opacity: 0;
            visibility: hidden;
            transform: translateY(10px);
            transition: opacity var(--transition-normal),
                        visibility var(--transition-normal),
                        transform var(--transition-normal);
        }
        
        .utility-info-card.visible {
            opacity: 1;
            visibility: visible;
            transform: translateY(0);
        }
        
        .info-card-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: var(--space-sm);
            padding-bottom: var(--space-sm);
            border-bottom: 1px solid var(--gray-200);
        }
        
        .info-card-title {
            font-weight: 600;
            font-size: 1rem;
            color: var(--text-primary);
            display: flex;
            align-items: center;
            gap: var(--space-xs);
        }
        
        .info-card-close {
            width: 28px;
            height: 28px;
            display: flex;
            align-items: center;
            justify-content: center;
            color: var(--gray-500);
            border-radius: var(--radius-full);
            transition: background-color var(--transition-fast),
                        color var(--transition-fast);
        }
        
        .info-card-close:hover {
            background-color: var(--gray-100);
            color: var(--gray-700);
        }
        
        .info-card-content {
            display: flex;
            flex-direction: column;
            gap: var(--space-xs);
        }
        
        .info-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: var(--space-xs) 0;
        }
        
        .info-label {
            font-size: 0.75rem;
            color: var(--text-secondary);
            font-weight: 500;
        }
        
        .info-value {
            font-size: 0.875rem;
            color: var(--text-primary);
            font-weight: 500;
            text-align: right;
        }
        
        .info-card-image {
            width: 100%;
            border-radius: var(--radius-md);
            margin-top: var(--space-sm);
            max-height: 150px;
            object-fit: cover;
        }
        
        .info-card-actions {
            display: flex;
            justify-content: flex-end;
            gap: var(--space-sm);
            margin-top: var(--space-md);
        }
        
        /*********************************
        * MEASUREMENT TOOLS
        *********************************/
        .measurement-toolbar {
            position: absolute;
            bottom: calc(100px + var(--space-xl)); /* Above navbar */
            left: 50%;
            transform: translateX(-50%);
            background-color: var(--bg-card);
            border-radius: var(--radius-md);
            box-shadow: var(--shadow-lg);
            padding: var(--space-sm);
            z-index: var(--z-fixed);
            display: flex;
            gap: var(--space-sm);
            opacity: 0;
            visibility: hidden;
            transition: opacity var(--transition-normal),
                        visibility var(--transition-normal);
        }
        
        .measurement-toolbar.visible {
            opacity: 1;
            visibility: visible;
        }
        
        .measurement-button {
            width: 40px;
            height: 40px;
            display: flex;
            align-items: center;
            justify-content: center;
            background-color: var(--bg-card);
            color: var(--gray-600);
            border-radius: var(--radius-full);
            transition: background-color var(--transition-fast),
                        color var(--transition-fast),
                        transform var(--transition-fast);
        }
        
        .measurement-button:active {
            transform: scale(0.95);
        }
        
        .measurement-button.active {
            background-color: var(--primary);
            color: white;
        }
        
        .measurement-result {
            position: absolute;
            background-color: var(--primary);
            color: white;
            padding: var(--space-xs) var(--space-sm);
            border-radius: var(--radius-md);
            font-size: 0.75rem;
            font-weight: 600;
            box-shadow: var(--shadow-md);
            z-index: var(--z-fixed);
            white-space: nowrap;
        }
        
        /*********************************
        * RESPONSIVE ADJUSTMENTS
        *********************************/
        @media (max-width: 480px) {
            /* Make buttons slightly smaller on very small screens */
            .action-button,
            .tool-button,
            .map-control-button {
                width: 44px;
                height: 44px;
                font-size: 1.25rem;
            }
            
            .utility-button {
                padding: var(--space-xs) var(--space-sm);
                min-width: 50px;
            }
            
            .utility-button i {
                font-size: 1.125rem;
            }
            
            .utility-label,
            .nav-label {
                font-size: 0.625rem;
            }
            
            /* Adjust modal sizes */
            .modal-container,
            .panel-container {
                width: 95%;
                max-height: 85vh;
            }
            
            /* Adjust form controls for touch */
            .form-control {
                padding: var(--space-sm) var(--space-md);
            }
            
            /* Make utility options more compact */
            .utility-option,
            .structure-option {
                padding: var(--space-xs);
            }
            
            .utility-toolbar {
                top: calc(var(--space-lg) + 40px);
            }
            
            .map-controls {
                top: calc(var(--space-lg) + 40px);
            }
            
            .tool-options {
                top: calc(var(--space-lg) + 40px);
            }
        }
        
        @media (min-width: 768px) {
            /* Slightly larger elements on tablets and up */
            .app-header {
                padding: var(--space-md) var(--space-lg);
            }
            
            .app-title {
                font-size: 18px;
            }
            
            .app-subtitle {
                font-size: 12px;
            }
            
            .modal-container {
                max-width: 480px;
            }
            
            .panel-container {
                max-width: 600px;
            }
            
            /* More prominent buttons */
            .action-button {
                width: 60px;
                height: 60px;
                font-size: 1.5rem;
            }
            
            .utility-toolbar {
                top: calc(var(--space-lg) + 60px);
            }
            
            .map-controls {
                top: calc(var(--space-lg) + 60px);
            }
            
            .tool-options {
                top: calc(var(--space-lg) + 60px);
            }
        }

        /* Add styles for confirm buttons and layer control */
        .confirm-drawing-btn {
            position: absolute;
            bottom: calc(100px + var(--space-xl) + 60px); /* Ensure it's well above navbar */
            left: 50%;
            transform: translateX(-50%);
            background-color: var(--success);
            color: white;
            padding: var(--space-sm) var(--space-md);
            border-radius: var(--radius-md);
            box-shadow: var(--shadow-md);
            font-weight: 500;
            z-index: var(--z-fixed);
            display: none;
        }

        .confirm-drawing-btn.visible {
            display: flex;
            align-items: center;
            gap: var(--space-xs);
        }

        .leaflet-control-layers {
            border-radius: var(--radius-md) !important;
            box-shadow: var(--shadow-md) !important;
            z-index: var(--z-fixed) !important;
            position: relative !important;
        }

        .leaflet-control-layers-toggle {
            width: 36px !important;
            height: 36px !important;
        }

        .control-point-label {
            position: absolute;
            background-color: var(--primary);
            color: white;
            padding: 2px 6px;
            border-radius: var(--radius-sm);
            font-size: 0.65rem;
            font-weight: 600;
            white-space: nowrap;
            pointer-events: none;
            z-index: var(--z-tooltip);
            transform: translate(-50%, -150%);
        }

        /* Line type selector for mapping mode */
        .line-type-selector {
            position: absolute;
            left: 50%;
            transform: translateX(-50%);
            top: calc(var(--space-lg) + 110px); /* Position below utility toolbar */
            display: flex;
            background-color: var(--bg-card);
            border-radius: var(--radius-full);
            box-shadow: var(--shadow-md);
            padding: var(--space-xs);
            z-index: var(--z-fixed);
            overflow: hidden;
            opacity: 0;
            visibility: hidden;
            transition: opacity var(--transition-normal),
                        visibility var(--transition-normal);
        }

        .line-type-selector.visible {
            opacity: 1;
            visibility: visible;
        }

        .line-type-button {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: var(--space-xs);
            padding: var(--space-xs) var(--space-md);
            color: var(--gray-600);
            font-weight: 500;
            font-size: 0.8rem;
            border-radius: var(--radius-full);
            transition: background-color var(--transition-fast),
                        color var(--transition-fast);
        }

        .line-type-button.active {
            background-color: var(--primary);
            color: white;
        }

        /* Enhance utility line styling to better differentiate between main and service lines */
        .utility-line.main {
            stroke-width: 6px;
            stroke-linecap: round;
            stroke-linejoin: round;
        }

        .utility-line.service {
            stroke-width: 4px;
            stroke-dasharray: none;
            stroke-linecap: butt;
        }

        /* Add connector styling */
        .connector-point {
            fill: white;
            stroke-width: 2px;
        }

        .connector-point.water {
            stroke: var(--water-color);
        }

        .connector-point.gas {
            stroke: var(--gas-color);
        }

        .connector-point.electric {
            stroke: var(--electric-color);
        }

        .connector-point.sewer {
            stroke: var(--sewer-color);
        }

        .connector-point.telecom {
            stroke: var(--telecom-color);
        }

        /* Connection indicator */
        .connection-indicator {
            position: absolute;
            background-color: var(--bg-card);
            border-radius: var(--radius-md);
            padding: var(--space-sm) var(--space-md);
            box-shadow: var(--shadow-md);
            z-index: var(--z-tooltip);
            display: flex;
            align-items: center;
            gap: var(--space-xs);
            font-size: 0.875rem;
            font-weight: 500;
            opacity: 0;
            visibility: hidden;
            transform: translateY(10px);
            transition: opacity var(--transition-normal),
                        visibility var(--transition-normal),
                        transform var(--transition-normal);
        }

        .connection-indicator.visible {
            opacity: 1;
            visibility: visible;
            transform: translateY(0);
        }

        .connection-indicator-icon {
            display: flex;
            align-items: center;
            justify-content: center;
            width: 24px;
            height: 24px;
            border-radius: 50%;
            color: white;
        }

        .connection-indicator-icon.water {
            background-color: var(--water-color);
        }

        .connection-indicator-icon.gas {
            background-color: var(--gas-color);
        }

        .connection-indicator-icon.electric {
            background-color: var(--electric-color);
        }

        .connection-indicator-icon.sewer {
            background-color: var(--sewer-color);
        }

        .connection-indicator-icon.telecom {
            background-color: var(--telecom-color);
        }

        /* Add styles for utility marker with main indicator */
        .utility-marker {
            display: flex;
            align-items: center;
            justify-content: center;
            width: 36px;
            height: 36px;
            border-radius: 50%;
            background-color: white;
            color: var(--primary);
            border: 2px solid currentColor;
            box-shadow: var(--shadow-md);
            font-size: 1rem;
            position: relative;
        }

        /* Add main indicator badge */
        .utility-marker::after {
            content: "";
            position: absolute;
            top: 100%;
            left: 50%;
            margin-left: -8px;
            border-width: 8px;
            border-style: solid;
            border-color: white transparent transparent transparent;
        }

        .utility-marker.main::before {
            content: "M";
            position: absolute;
            top: -5px;
            right: -5px;
            width: 16px;
            height: 16px;
            background-color: var(--primary-dark);
            color: white;
            border-radius: 50%;
            font-size: 0.7rem;
            font-weight: bold;
            display: flex;
            align-items: center;
            justify-content: center;
            box-shadow: var(--shadow-sm);
        }

        /* Custom styles for each utility type main indicator */
        .utility-marker.main.water::before {
            background-color: var(--water-color);
        }

        .utility-marker.main.gas::before {
            background-color: var(--gas-color);
        }

        .utility-marker.main.electric::before {
            background-color: var(--electric-color);
            color: black;
        }

        .utility-marker.main.sewer::before {
            background-color: var(--sewer-color);
        }

        .utility-marker.main.telecom::before {
            background-color: var(--telecom-color);
        }

        /* Update the utility line styling to be more distinct */
        .utility-line.service {
            stroke-width: 4px;
            stroke-dasharray: 8, 8;
        }

        /* Add an animation for potential connection */
        @keyframes pulse-connection {
            0% {
                transform: scale(1);
                opacity: 0.8;
            }
            50% {
                transform: scale(1.3);
                opacity: 1;
            }
            100% {
                transform: scale(1);
                opacity: 0.8;
            }
        }

        .connection-point-indicator {
            animation: pulse-connection 1.5s ease-in-out infinite;
            opacity: 0.8;
        }
    </style>
</head>

<body>
    <!-- Splash Screen -->
    <div class="splash-screen" id="splash-screen">
        <div class="splash-logo">
            <i class="fas fa-map-marker-alt"></i>
        </div>
        <div class="splash-title">CAC UtiliTrack</div>
        <div class="splash-subtitle">Precision Utility Mapping</div>
        <div class="splash-progress">
            <div class="splash-progress-bar"></div>
        </div>
    </div>

    <!-- Main App Container -->
    <div class="app-container">
        <!-- App Header -->
        <header class="app-header" id="app-header">
            <div class="header-left">
                <div class="app-logo">
                    <div class="logo-icon">
                        <i class="fas fa-map-marker-alt"></i>
                    </div>
                    <div class="logo-text">
                        <div class="app-title">CAC UtiliTrack</div>
                        <div class="app-subtitle">Precision Utility Mapping</div>
                    </div>
                </div>
            </div>
            <div class="header-right">
                <button class="map-control-button" id="menu-button">
                    <i class="fas fa-bars"></i>
                </button>
            </div>
        </header>

        <!-- Map Container -->
        <div class="map-container">
            <div id="map"></div>
            
            <!-- Utility Type Toolbar -->
            <div class="utility-toolbar" id="utility-toolbar">
                <button class="utility-button water" data-utility="water">
                    <i class="fas fa-tint"></i>
                    <span class="utility-label">Water</span>
                </button>
                <button class="utility-button gas" data-utility="gas">
                    <i class="fas fa-fire"></i>
                    <span class="utility-label">Gas</span>
                </button>
                <button class="utility-button electric" data-utility="electric">
                    <i class="fas fa-bolt"></i>
                    <span class="utility-label">Electric</span>
                </button>
                <button class="utility-button sewer" data-utility="sewer">
                    <i class="fas fa-toilet"></i>
                    <span class="utility-label">Sewer</span>
                </button>
                <button class="utility-button telecom" data-utility="telecom">
                    <i class="fas fa-phone"></i>
                    <span class="utility-label">Telecom</span>
                </button>
            </div>
            
            <!-- Map Controls -->
            <div class="map-controls">
                <button class="map-control-button" id="zoom-in-btn">
                    <i class="fas fa-plus"></i>
                </button>
                <button class="map-control-button" id="zoom-out-btn">
                    <i class="fas fa-minus"></i>
                </button>
                <button class="map-control-button" id="locate-btn">
                    <i class="fas fa-crosshairs"></i>
                </button>
            </div>
            
            <!-- Tool Options -->
            <div class="tool-options" id="tool-options">
                <button class="tool-button" id="layers-btn" title="Layers">
                    <i class="fas fa-layer-group"></i>
                </button>
                <button class="tool-button" id="measure-btn" title="Measure">
                    <i class="fas fa-ruler"></i>
                </button>
            </div>
            
            <!-- Action Buttons -->
            <div class="action-buttons" id="action-buttons">
                <button class="action-button primary" id="add-utility-btn">
                    <i class="fas fa-plus"></i>
                </button>
            </div>
            
            <!-- Mode Toggle -->
            <div class="mode-toggle" id="mode-toggle">
                <button class="mode-button active" data-mode="discovery">
                    <i class="fas fa-search"></i>
                    <span>Discovery</span>
                </button>
                <button class="mode-button" data-mode="mapping">
                    <i class="fas fa-draw-polygon"></i>
                    <span>Mapping</span>
                </button>
            </div>
            
            <!-- Status Bar -->
            <div class="status-bar" id="status-bar">
                <i class="fas fa-info-circle"></i>
                <span id="status-text">Ready to track utilities</span>
            </div>
            
            <!-- Measurement Toolbar -->
            <div class="measurement-toolbar" id="measurement-toolbar">
                <button class="measurement-button active" data-tool="measure-distance">
                    <i class="fas fa-ruler-horizontal"></i>
                </button>
                <button class="measurement-button" data-tool="add-note">
                    <i class="fas fa-sticky-note"></i>
                </button>
                <button class="measurement-button" data-tool="clear-measurements">
                    <i class="fas fa-trash"></i>
                </button>
                <button class="measurement-button" data-tool="exit-measure">
                    <i class="fas fa-times"></i>
                </button>
            </div>
            
            <!-- High Accuracy Repositioning Panel -->
            <div class="reposition-control-panel" id="reposition-panel">
                <div class="reposition-panel-heading">
                    <i class="fas fa-crosshairs"></i> High Accuracy Repositioning
                </div>
                <div class="reposition-instruction" style="text-align: center; font-size: 0.8rem; color: var(--gray-600);">
                    Drag the blue markers to reposition the utility line
                </div>
                <div class="reposition-buttons">
                    <button class="btn btn-secondary" id="cancel-reposition-btn">
                        <i class="fas fa-times"></i> Cancel
                    </button>
                    <button class="btn btn-primary" id="save-reposition-btn">
                        <i class="fas fa-check"></i> Save Position
                    </button>
                </div>
            </div>
            
            <!-- Utility Info Card -->
            <div class="utility-info-card" id="utility-info-card">
                <div class="info-card-header">
                    <div class="info-card-title">
                        <i class="fas fa-info-circle"></i>
                        <span id="info-title">Utility Information</span>
                    </div>
                    <button class="info-card-close" id="info-close-btn">
                        <i class="fas fa-times"></i>
                    </button>
                </div>
                <div class="info-card-content">
                    <div class="info-row">
                        <div class="info-label">Type:</div>
                        <div class="info-value" id="info-type">Water</div>
                    </div>
                    <div class="info-row">
                        <div class="info-label">Line Type:</div>
                        <div class="info-value" id="info-line-type">Service</div>
                    </div>
                    <div class="info-row">
                        <div class="info-label">Size:</div>
                        <div class="info-value" id="info-size">4 inches</div>
                    </div>
                    <div class="info-row">
                        <div class="info-label">Depth:</div>
                        <div class="info-value" id="info-depth">3 feet</div>
                    </div>
                    <div class="info-row">
                        <div class="info-label">Material:</div>
                        <div class="info-value" id="info-material">PVC</div>
                    </div>
                    <div class="info-row">
                        <div class="info-label">Condition:</div>
                        <div class="info-value" id="info-condition">Good</div>
                    </div>
                    <div class="info-row">
                        <div class="info-label">Added:</div>
                        <div class="info-value" id="info-date">Today at 2:30 PM</div>
                    </div>
                    <img id="info-image" class="info-card-image" style="display: none;" />
                </div>
                <div class="info-card-actions">
                    <button class="btn btn-secondary btn-sm" id="edit-utility-btn">
                        <i class="fas fa-edit"></i> Edit
                    </button>
                    <button class="btn btn-primary btn-sm" id="reposition-utility-btn">
                        <i class="fas fa-crosshairs"></i> Reposition
                    </button>
                </div>
            </div>
        </div>
        
        <!-- Navigation Bar -->
        <nav class="nav-bar" id="nav-bar">
            <div class="nav-bar-inner">
                <button class="nav-button active" data-screen="home">
                    <i class="fas fa-map-marked-alt"></i>
                    <span class="nav-label">Map</span>
                </button>
                <button class="nav-button" data-screen="utilities">
                    <i class="fas fa-list"></i>
                    <span class="nav-label">Utilities</span>
                </button>
                <button class="nav-button" data-screen="settings">
                    <i class="fas fa-cog"></i>
                    <span class="nav-label">Settings</span>
                </button>
            </div>
        </nav>
    </div>
    
    <!-- Notifications Container -->
    <div class="notification-container" id="notification-container"></div>
    
    <!-- Context Menu -->
    <div class="context-menu" id="context-menu">
        <div class="context-menu-item" id="edit-item">
            <i class="fas fa-edit"></i>
            <span>Edit</span>
        </div>
        <div class="context-menu-item" id="connect-item">
            <i class="fas fa-plug"></i>
            <span>Connect</span>
        </div>
        <div class="context-menu-item" id="measure-item">
            <i class="fas fa-ruler"></i>
            <span>Measure</span>
        </div>
        <div class="context-menu-item" id="reposition-item">
            <i class="fas fa-crosshairs"></i>
            <span>Reposition</span>
        </div>
        <div class="context-menu-divider"></div>
        <div class="context-menu-item danger" id="delete-item">
            <i class="fas fa-trash"></i>
            <span>Delete</span>
        </div>
    </div>
    
    <!-- MODALS -->
    
    <!-- Add Utility Modal -->
    <div class="modal-overlay" id="add-utility-modal">
        <div class="modal-container">
            <div class="modal-header">
                <div class="modal-title">Add Utility</div>
                <button class="modal-close" id="close-add-utility">
                    <i class="fas fa-times"></i>
                </button>
            </div>
            <div class="modal-body">
                <div class="form-group">
                    <label class="form-label">Utility Type</label>
                    <div class="utility-selection">
                        <div class="utility-option water selected" data-type="water">
                            <i class="fas fa-tint utility-option-icon"></i>
                            <span class="utility-option-label">Water</span>
                        </div>
                        <div class="utility-option gas" data-type="gas">
                            <i class="fas fa-fire utility-option-icon"></i>
                            <span class="utility-option-label">Gas</span>
                        </div>
                        <div class="utility-option electric" data-type="electric">
                            <i class="fas fa-bolt utility-option-icon"></i>
                            <span class="utility-option-label">Electric</span>
                        </div>
                        <div class="utility-option sewer" data-type="sewer">
                            <i class="fas fa-toilet utility-option-icon"></i>
                            <span class="utility-option-label">Sewer</span>
                        </div>
                        <div class="utility-option telecom" data-type="telecom">
                            <i class="fas fa-phone utility-option-icon"></i>
                            <span class="utility-option-label">Telecom</span>
                        </div>
                    </div>
                </div>
                
                <div class="form-group">
                    <label class="form-label">Line Type</label>
                    <div class="radio-group">
                        <div class="radio-item">
                            <input type="radio" id="service-type" name="line-type" value="service" checked>
                            <label for="service-type">Service Line</label>
                        </div>
                        <div class="radio-item">
                            <input type="radio" id="main-type" name="line-type" value="main">
                            <label for="main-type">Main Line</label>
                        </div>
                    </div>
                </div>
                
                <div class="form-group">
                    <label class="form-label" for="utility-size">Size (inches)</label>
                    <input type="number" id="utility-size" class="form-control" value="4" min="0.5" step="0.5">
                </div>
                
                <div class="form-group">
                    <label class="form-label" for="utility-depth">Depth (feet)</label>
                    <input type="number" id="utility-depth" class="form-control" value="3" min="0.5" step="0.5">
                </div>
                
                <div class="form-group">
                    <label class="form-label" for="utility-material">Material</label>
                    <select id="utility-material" class="form-control">
                        <option value="PVC">PVC</option>
                        <option value="Cast Iron">Cast Iron</option>
                        <option value="Ductile Iron">Ductile Iron</option>
                        <option value="Copper">Copper</option>
                        <option value="HDPE">HDPE</option>
                        <option value="Steel">Steel</option>
                        <option value="Clay">Clay</option>
                        <option value="Concrete">Concrete</option>
                        <option value="Unknown">Unknown</option>
                    </select>
                </div>
                
                <div class="form-group">
                    <label class="form-label" for="utility-condition">Condition</label>
                    <select id="utility-condition" class="form-control">
                        <option value="Excellent">Excellent</option>
                        <option value="Good">Good</option>
                        <option value="Fair">Fair</option>
                        <option value="Poor">Poor</option>
                        <option value="Critical">Critical</option>
                        <option value="Unknown">Unknown</option>
                    </select>
                </div>
                
                <div class="form-group">
                    <label class="form-label" for="utility-photo">Photo (optional)</label>
                    <input type="file" id="utility-photo" class="form-control" accept="image/*">
                </div>
                
                <div class="form-group">
                    <label class="form-label" for="utility-notes">Notes</label>
                    <textarea id="utility-notes" class="form-control" rows="2" placeholder="Any additional details..."></textarea>
                </div>
            </div>
            <div class="modal-footer">
                <button class="btn btn-secondary" id="cancel-add-utility">Cancel</button>
                <button class="btn btn-primary" id="confirm-add-utility">Add Utility</button>
            </div>
        </div>
    </div>
    
    <!-- Add Structure Modal -->
    <div class="modal-overlay" id="add-structure-modal">
        <div class="modal-container">
            <div class="modal-header">
                <div class="modal-title">Add Structure</div>
                <button class="modal-close" id="close-add-structure">
                    <i class="fas fa-times"></i>
                </button>
            </div>
            <div class="modal-body">
                <div class="form-group">
                    <label class="form-label">Structure Type</label>
                    <div class="structure-selection">
                        <div class="structure-option" data-structure="valve" data-utility="water">
                            <i class="fas fa-tint-slash structure-option-icon"></i>
                            <span class="structure-option-label">Valve</span>
                        </div>
                        <div class="structure-option" data-structure="meter" data-utility="water">
                            <i class="fas fa-tachometer-alt structure-option-icon"></i>
                            <span class="structure-option-label">Meter</span>
                        </div>
                        <div class="structure-option" data-structure="hydrant" data-utility="water">
                            <i class="fas fa-fire-extinguisher structure-option-icon"></i>
                            <span class="structure-option-label">Hydrant</span>
                        </div>
                        <div class="structure-option" data-structure="regulator" data-utility="gas">
                            <i class="fas fa-compress-alt structure-option-icon"></i>
                            <span class="structure-option-label">Regulator</span>
                        </div>
                        <div class="structure-option" data-structure="transformer" data-utility="electric">
                            <i class="fas fa-car-battery structure-option-icon"></i>
                            <span class="structure-option-label">Transformer</span>
                        </div>
                        <div class="structure-option" data-structure="junction" data-utility="electric">
                            <i class="fas fa-box structure-option-icon"></i>
                            <span class="structure-option-label">Junction Box</span>
                        </div>
                        <div class="structure-option" data-structure="manhole" data-utility="sewer">
                            <i class="fas fa-circle structure-option-icon"></i>
                            <span class="structure-option-label">Manhole</span>
                        </div>
                        <div class="structure-option" data-structure="catchbasin" data-utility="sewer">
                            <i class="fas fa-water structure-option-icon"></i>
                            <span class="structure-option-label">Catch Basin</span>
                        </div>
                        <div class="structure-option" data-structure="handhole" data-utility="telecom">
                            <i class="fas fa-box-open structure-option-icon"></i>
                            <span class="structure-option-label">Handhole</span>
                        </div>
                    </div>
                </div>
                
                <div class="form-group">
                    <label class="form-label" for="structure-size">Size (inches)</label>
                    <input type="number" id="structure-size" class="form-control" value="24" min="1">
                </div>
                
                <div class="form-group">
                    <label class="form-label" for="structure-depth">Depth/Height (feet)</label>
                    <input type="number" id="structure-depth" class="form-control" value="3" min="0.5" step="0.5">
                </div>
                
                <div class="form-group">
                    <label class="form-label" for="structure-material">Material</label>
                    <select id="structure-material" class="form-control">
                        <option value="Concrete">Concrete</option>
                        <option value="Metal">Metal</option>
                        <option value="Plastic">Plastic</option>
                        <option value="Fiberglass">Fiberglass</option>
                        <option value="Cast Iron">Cast Iron</option>
                        <option value="Brick">Brick</option>
                        <option value="Unknown">Unknown</option>
                    </select>
                </div>
                
                <div class="form-group">
                    <label class="form-label" for="structure-condition">Condition</label>
                    <select id="structure-condition" class="form-control">
                        <option value="Excellent">Excellent</option>
                        <option value="Good">Good</option>
                        <option value="Fair">Fair</option>
                        <option value="Poor">Poor</option>
                        <option value="Critical">Critical</option>
                        <option value="Unknown">Unknown</option>
                    </select>
                </div>
                
                <div class="form-group">
                    <label class="form-label" for="structure-photo">Photo (optional)</label>
                    <input type="file" id="structure-photo" class="form-control" accept="image/*">
                </div>
                
                <div class="form-group">
                    <label class="form-label" for="structure-notes">Notes</label>
                    <textarea id="structure-notes" class="form-control" rows="2" placeholder="Any additional details..."></textarea>
                </div>
            </div>
            <div class="modal-footer">
                <button class="btn btn-secondary" id="cancel-add-structure">Cancel</button>
                <button class="btn btn-primary" id="confirm-add-structure">Add Structure</button>
            </div>
        </div>
    </div>
    
    <!-- Main Menu Panel -->
    <div class="panel-overlay" id="main-menu-panel">
        <div class="panel-container">
            <div class="panel-handle"></div>
            <div class="panel-header">
                <div class="panel-title">Menu</div>
                <button class="modal-close" id="close-main-menu">
                    <i class="fas fa-times"></i>
                </button>
            </div>
            <div class="panel-body">
                <button class="btn btn-primary btn-block btn-icon" style="margin-bottom: 12px;" id="menu-add-utility">
                    <i class="fas fa-plus"></i> Add Utility
                </button>
                <button class="btn btn-primary btn-block btn-icon" style="margin-bottom: 12px;" id="menu-add-structure">
                    <i class="fas fa-plus-square"></i> Add Structure
                </button>
                <button class="btn btn-secondary btn-block btn-icon" style="margin-bottom: 12px;" id="menu-toggle-layers">
                    <i class="fas fa-layer-group"></i> Toggle Layers
                </button>
                <button class="btn btn-secondary btn-block btn-icon" style="margin-bottom: 12px;" id="menu-export">
                    <i class="fas fa-file-export"></i> Export Data
                </button>
                <button class="btn btn-secondary btn-block btn-icon" id="menu-import">
                    <i class="fas fa-file-import"></i> Import Data
                </button>
            </div>
        </div>
    </div>
    
    <!-- Layers Panel -->
    <div class="panel-overlay" id="layers-panel">
        <div class="panel-container">
            <div class="panel-handle"></div>
            <div class="panel-header">
                <div class="panel-title">Layers</div>
                <button class="modal-close" id="close-layers">
                    <i class="fas fa-times"></i>
                </button>
            </div>
            <div class="panel-body">
                <div style="margin-bottom: 20px;">
                    <div style="font-weight: 500; margin-bottom: 10px;">Utility Types</div>
                    <div class="form-group">
                        <div class="checkbox-item">
                            <input type="checkbox" id="layer-water" checked>
                            <label for="layer-water" style="color: var(--water-color);">Water</label>
                        </div>
                    </div>
                    <div class="form-group">
                        <div class="checkbox-item">
                            <input type="checkbox" id="layer-gas" checked>
                            <label for="layer-gas" style="color: var(--gas-color);">Gas</label>
                        </div>
                    </div>
                    <div class="form-group">
                        <div class="checkbox-item">
                            <input type="checkbox" id="layer-electric" checked>
                            <label for="layer-electric" style="color: var(--electric-color);">Electric</label>
                        </div>
                    </div>
                    <div class="form-group">
                        <div class="checkbox-item">
                            <input type="checkbox" id="layer-sewer" checked>
                            <label for="layer-sewer" style="color: var(--sewer-color);">Sewer</label>
                        </div>
                    </div>
                    <div class="form-group">
                        <div class="checkbox-item">
                            <input type="checkbox" id="layer-telecom" checked>
                            <label for="layer-telecom" style="color: var(--telecom-color);">Telecom</label>
                        </div>
                    </div>
                </div>
                
                <div style="margin-bottom: 20px;">
                    <div style="font-weight: 500; margin-bottom: 10px;">Line Types</div>
                    <div class="form-group">
                        <div class="checkbox-item">
                            <input type="checkbox" id="layer-mains" checked>
                            <label for="layer-mains">Main Lines</label>
                        </div>
                    </div>
                    <div class="form-group">
                        <div class="checkbox-item">
                            <input type="checkbox" id="layer-services" checked>
                            <label for="layer-services">Service Lines</label>
                        </div>
                    </div>
                </div>
                
                <div>
                    <div style="font-weight: 500; margin-bottom: 10px;">Structures</div>
                    <div class="form-group">
                        <div class="checkbox-item">
                            <input type="checkbox" id="layer-structures" checked>
                            <label for="layer-structures">Show Structures</label>
                        </div>
                    </div>
                    <div class="form-group">
                        <div class="checkbox-item">
                            <input type="checkbox" id="layer-labels" checked>
                            <label for="layer-labels">Show Labels</label>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>
    
    <!-- Add Annotation Modal -->
    <div class="modal-overlay" id="add-annotation-modal">
        <div class="modal-container">
            <div class="modal-header">
                <div class="modal-title">Add Annotation</div>
                <button class="modal-close" id="close-annotation">
                    <i class="fas fa-times"></i>
                </button>
            </div>
            <div class="modal-body">
                <div class="form-group">
                    <label class="form-label" for="annotation-text">Annotation Text</label>
                    <input type="text" id="annotation-text" class="form-control" placeholder="e.g. 6' from curb">
                </div>
            </div>
            <div class="modal-footer">
                <button class="btn btn-secondary" id="cancel-annotation">Cancel</button>
                <button class="btn btn-primary" id="confirm-annotation">Add Annotation</button>
            </div>
        </div>
    </div>
    
    <!-- Confirm Delete Dialog -->
    <div class="modal-overlay" id="confirm-delete-modal">
        <div class="confirm-dialog">
            <div class="confirm-dialog-icon">
                <i class="fas fa-exclamation-triangle"></i>
            </div>
            <div class="confirm-dialog-title">Confirm Delete</div>
            <div class="confirm-dialog-message">Are you sure you want to delete this utility? This action cannot be undone.</div>
            <div class="confirm-dialog-buttons">
                <button class="btn btn-secondary" id="cancel-delete">Cancel</button>
                <button class="btn btn-danger" id="confirm-delete">Delete</button>
            </div>
        </div>
    </div>
    
    <!-- Connect Utility Modal -->
    <div class="modal-overlay" id="connect-utility-modal">
        <div class="modal-container">
            <div class="modal-header">
                <div class="modal-title">Connect Utility</div>
                <button class="modal-close" id="close-connect">
                    <i class="fas fa-times"></i>
                </button>
            </div>
            <div class="modal-body">
                <div class="form-group">
                    <label class="form-label">Connection Type</label>
                    <select id="connection-type" class="form-control">
                        <option value="tap">Tap Main Line</option>
                        <option value="extend">Extend Line</option>
                        <option value="connect-structure">Connect to Structure</option>
                    </select>
                </div>
                <div class="form-group" id="connection-target-group">
                    <label class="form-label">Connect To</label>
                    <select id="connection-target" class="form-control">
                        <!-- Will be populated dynamically -->
                    </select>
                </div>
                <div class="form-group">
                    <label class="form-label">Notes</label>
                    <textarea id="connection-notes" class="form-control" rows="2" placeholder="Any additional details..."></textarea>
                </div>
            </div>
            <div class="modal-footer">
                <button class="btn btn-secondary" id="cancel-connect">Cancel</button>
                <button class="btn btn-primary" id="confirm-connect">Connect</button>
            </div>
        </div>
    </div>

    <!-- Add confirm drawing button -->
    <button class="confirm-drawing-btn" id="confirm-drawing-btn">
        <i class="fas fa-check"></i>
        <span>Finish Drawing</span>
    </button>
    
    <!-- Add zoom warning message -->
    <div class="zoom-warning" id="zoom-warning">
        <i class="fas fa-search-plus"></i>
        <span>Zoom in closer to see more map details</span>
    </div>

    <!-- Connection indicator -->
    <div class="connection-indicator" id="connection-indicator">
        <div class="connection-indicator-icon" id="connection-indicator-icon">
            <i class="fas fa-plug"></i>
        </div>
        <span id="connection-indicator-text">Connect to Main</span>
        <button class="btn btn-sm btn-primary" id="confirm-connection-btn">
            <i class="fas fa-check"></i>
        </button>
    </div>

    <!-- Line type selector for mapping mode -->
    <div class="line-type-selector" id="line-type-selector">
        <button class="line-type-button active" data-type="service">
            <i class="fas fa-level-up-alt"></i>
            <span>Service Line</span>
        </button>
        <button class="line-type-button" data-type="main">
            <i class="fas fa-grip-lines"></i>
            <span>Main Line</span>
        </button>
    </div>

    <!-- Leaflet JS -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/leaflet/1.9.4/leaflet.min.js"></script>
    
    <script>
        /*********************************
        * APP INITIALIZATION
        *********************************/
        document.addEventListener('DOMContentLoaded', function() {
            // Simulate splash screen for a better first-time experience
            setTimeout(() => {
                const splash = document.getElementById('splash-screen');
                splash.style.opacity = '0';
                setTimeout(() => {
                    splash.style.display = 'none';
                }, 500);
            }, 2000);
            
            // Initialize the application
            CAC_UtiliTrack.init();
        });

        // Main Application Namespace
        const CAC_UtiliTrack = (function() {
            /*********************************
            * DATA MODELS & STATE
            *********************************/
            // Application State
            const AppState = {
                mode: 'discovery', // 'discovery' or 'mapping'
                activeUtilityType: 'water', // Selected utility type
                activeLineType: 'service', // 'service' or 'main'
                activeTool: null, // Current active tool
                isDrawing: false, // Whether user is drawing a utility line
                drawingPoints: [], // Points collected during drawing
                tempLine: null, // Temporary line during drawing
                selectedElement: null, // Currently selected utility/structure
                isMeasuring: false, // Whether measurement mode is active
                measurePoints: [], // Points for measurement
                measureLine: null, // Current measurement line
                repositioningUtility: null, // Utility being repositioned
                controlPoints: [], // Control points for repositioning
            };
            
            // Data Collections
            const DataStore = {
                utilities: {
                    water: [],
                    gas: [],
                    electric: [],
                    sewer: [],
                    telecom: []
                },
                structures: {
                    water: [],
                    gas: [],
                    electric: [],
                    sewer: [],
                    telecom: []
                },
                annotations: [],
                measurements: [],
                
                // Get a utility by ID
                getUtilityById: function(id) {
                    let found = null;
                    
                    for (const type in this.utilities) {
                        const utility = this.utilities[type].find(u => u.id === id);
                        if (utility) {
                            found = utility;
                            break;
                        }
                    }
                    
                    return found;
                },
                
                // Get a structure by ID
                getStructureById: function(id) {
                    let found = null;
                    
                    for (const type in this.structures) {
                        const structure = this.structures[type].find(s => s.id === id);
                        if (structure) {
                            found = structure;
                            break;
                        }
                    }
                    
                    return found;
                },
                
                // Generate a unique ID for a new element
                generateId: function(prefix) {
                    return prefix + '-' + Date.now() + '-' + Math.floor(Math.random() * 1000);
                },
                
                // Save data to localStorage
                saveData: function() {
                    try {
                        const data = {
                            utilities: this.utilities,
                            structures: this.structures,
                            annotations: this.annotations,
                            measurements: this.measurements
                        };
                        
                        // Remove circular references before saving
                        const cleanData = JSON.stringify(data, (key, value) => {
                            // Skip Leaflet objects
                            if (
                                key === 'marker' || 
                                key === 'line' ||
                                key === 'editHandles' ||
                                key === 'layer' ||
                                value instanceof L.Layer ||
                                value instanceof L.Map
                            ) {
                                return undefined;
                            }
                            
                            // Keep the rest
                            return value;
                        });
                        
                        localStorage.setItem('cac_utilitrack_data', cleanData);
                        UI.showToast('Data saved successfully', 'success');
                    } catch (error) {
                        console.error('Error saving data:', error);
                        UI.showToast('Error saving data', 'error');
                    }
                },
                
                // Load data from localStorage
                loadData: function() {
                    try {
                        const savedData = localStorage.getItem('cac_utilitrack_data');
                        
                        if (!savedData) {
                            return false;
                        }
                        
                        const data = JSON.parse(savedData);
                        
                        // Restore data
                        this.utilities = data.utilities || this.utilities;
                        this.structures = data.structures || this.structures;
                        this.annotations = data.annotations || this.annotations;
                        this.measurements = data.measurements || this.measurements;
                        
                        return true;
                    } catch (error) {
                        console.error('Error loading data:', error);
                        UI.showToast('Error loading data', 'error');
                        return false;
                    }
                },
                
                // Export data as JSON file
                exportData: function() {
                    try {
                        // Clean the data for export 
                        const exportData = {
                            utilities: {},
                            structures: {},
                            annotations: this.annotations,
                            measurements: this.measurements,
                            timestamp: new Date().toISOString(),
                            version: '1.0'
                        };
                        
                        // Convert utilities for export (removing circular references)
                        for (const type in this.utilities) {
                            exportData.utilities[type] = this.utilities[type].map(utility => {
                                return {
                                    id: utility.id,
                                    type: utility.type,
                                    lineType: utility.lineType,
                                    points: utility.points,
                                    size: utility.size,
                                    depth: utility.depth,
                                    material: utility.material,
                                    condition: utility.condition,
                                    notes: utility.notes,
                                    date: utility.date,
                                    connections: utility.connections,
                                    imageData: utility.imageData
                                };
                            });
                        }
                        
                        // Convert structures for export
                        for (const type in this.structures) {
                            exportData.structures[type] = this.structures[type].map(structure => {
                                return {
                                    id: structure.id,
                                    type: structure.type,
                                    structureType: structure.structureType,
                                    latlng: structure.latlng,
                                    size: structure.size,
                                    depth: structure.depth,
                                    material: structure.material,
                                    condition: structure.condition,
                                    notes: structure.notes,
                                    date: structure.date,
                                    connections: structure.connections,
                                    imageData: structure.imageData
                                };
                            });
                        }
                        
                        // Convert to JSON string
                        const jsonString = JSON.stringify(exportData, null, 2);
                        
                        // Create a download link
                        const blob = new Blob([jsonString], { type: 'application/json' });
                        const url = URL.createObjectURL(blob);
                        const a = document.createElement('a');
                        a.href = url;
                        a.download = `cac-utilitrack-export-${new Date().toISOString().split('T')[0]}.json`;
                        
                        // Trigger download
                        document.body.appendChild(a);
                        a.click();
                        
                        // Cleanup
                        document.body.removeChild(a);
                        URL.revokeObjectURL(url);
                        
                        UI.showToast('Data exported successfully', 'success');
                        return true;
                    } catch (error) {
                        console.error('Error exporting data:', error);
                        UI.showToast('Error exporting data', 'error');
                        return false;
                    }
                },
                
                // Import data from JSON file
                importData: function(jsonString) {
                    try {
                        const data = JSON.parse(jsonString);
                        
                        // Validate data format
                        if (!data.utilities || !data.structures) {
                            throw new Error('Invalid data format');
                        }
                        
                        // Store the data
                        this.utilities = data.utilities;
                        this.structures = data.structures;
                        this.annotations = data.annotations || [];
                        this.measurements = data.measurements || [];
                        
                        // Save to local storage
                        this.saveData();
                        
                        // Update UI
                        UI.showToast('Data imported successfully', 'success');
                        return true;
                    } catch (error) {
                        console.error('Error importing data:', error);
                        UI.showToast('Error importing data', 'error');
                        return false;
                    }
                }
            };
            
            /*********************************
            * MAP CONTROLLER
            *********************************/
            const MapController = {
                map: null,
                baseLayers: {}, // Added for different map types
                utilityLayers: {},
                structureLayers: {},
                annotationLayer: null,
                measurementLayer: null,
                
                // Initialize the map
                init: function() {
                    // Create map with default view (centered on user's location if available)
                    this.map = L.map('map', {
                        zoomControl: false,
                        attributionControl: true,
                        maxZoom: 22,  // Increased from default to allow deeper zoom
                        preferCanvas: true // Better performance for high detail rendering
                    }).setView([40.7128, -74.0060], 16); // Default to NYC
                    
                    // Add multiple tile layers for different map views with high zoom support
                    const osmLayer = L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
                        attribution: '&copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors',
                        maxZoom: 22,
                        maxNativeZoom: 19, // Max zoom where original tiles exist (then they'll be scaled)
                        keepBuffer: 8 // Increased buffer to prevent tile disappearance during panning
                    });
                    
                    const satelliteLayer = L.tileLayer('https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}', {
                        attribution: 'Tiles &copy; Esri &mdash; Source: Esri, i-cubed, USDA, USGS, AEX, GeoEye, Getmapping, Aerogrid, IGN, IGP, UPR-EGP, and the GIS User Community',
                        maxZoom: 22,
                        maxNativeZoom: 19,
                        keepBuffer: 8
                    });
                    
                    const topoLayer = L.tileLayer('https://{s}.tile.opentopomap.org/{z}/{x}/{y}.png', {
                        attribution: 'Map data: &copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors, <a href="http://viewfinderpanoramas.org">SRTM</a> | Map style: &copy; <a href="https://opentopomap.org">OpenTopoMap</a>',
                        maxZoom: 22,
                        maxNativeZoom: 17, // OpenTopoMap has more limited zoom levels
                        keepBuffer: 8
                    });
                    
                    // High-detail street map for very high zoom levels
                    const streetsLayer = L.tileLayer('https://{s}.basemaps.cartocdn.com/rastertiles/voyager/{z}/{x}/{y}{r}.png', {
                        attribution: '&copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors &copy; <a href="https://carto.com/attributions">CARTO</a>',
                        subdomains: 'abcd',
                        maxZoom: 22,
                        maxNativeZoom: 19,
                        keepBuffer: 8
                    });
                    
                    // Store base layers
                    this.baseLayers = {
                        "Standard Map": osmLayer,
                        "Satellite": satelliteLayer,
                        "Topographic": topoLayer,
                        "Streets (Detailed)": streetsLayer
                    };
                    
                    // Add default layer to map
                    osmLayer.addTo(this.map);
                    
                    // Initialize utility layers for each type
                    const utilityTypes = ['water', 'gas', 'electric', 'sewer', 'telecom'];
                    utilityTypes.forEach(type => {
                        this.utilityLayers[type] = L.layerGroup().addTo(this.map);
                        this.structureLayers[type] = L.layerGroup().addTo(this.map);
                    });
                    
                    // Initialize annotation and measurement layers
                    this.annotationLayer = L.layerGroup().addTo(this.map);
                    this.measurementLayer = L.layerGroup().addTo(this.map);
                    
                    // Create overlay layers object for the layer control
                    const overlays = {
                        "Water Utilities": this.utilityLayers.water,
                        "Gas Utilities": this.utilityLayers.gas,
                        "Electric Utilities": this.utilityLayers.electric,
                        "Sewer Utilities": this.utilityLayers.sewer,
                        "Telecom Utilities": this.utilityLayers.telecom,
                        "Annotations": this.annotationLayer,
                        "Measurements": this.measurementLayer
                    };
                    
                    // Add layer control to switch between different map types
                    L.control.layers(this.baseLayers, overlays, {
                        position: 'topright',
                        collapsed: true
                    }).addTo(this.map);
                    
                    // Set up map event listeners
                    this.setupMapEvents();
                    
                    // Get user location if available
                    this.getUserLocation();
                    
                    // Monitor zoom level for warning
                    this.map.on('zoomend', function() {
                        const currentZoom = MapController.map.getZoom();
                        if (currentZoom < 18) {
                            UI.showZoomWarning();
                        } else {
                            UI.hideZoomWarning();
                        }
                        
                        // Update UI positions when zoom changes
                        UI.updateUIPositions();
                    });
                    
                    // Listen for map move events to ensure UI stays positioned correctly
                    this.map.on('moveend', function() {
                        UI.updateUIPositions();
                    });
                },
                
                // Set up map event listeners
                setupMapEvents: function() {
                    // Click on map
                    this.map.on('click', function(e) {
                        EventHandlers.handleMapClick(e);
                    });
                    
                    // Context menu on map
                    this.map.on('contextmenu', function(e) {
                        EventHandlers.handleMapContextMenu(e);
                    });
                    
                    // Mouse move for drawing
                    this.map.on('mousemove', function(e) {
                        EventHandlers.handleMapMouseMove(e);
                    });
                    
                    // Map movement starts
                    this.map.on('movestart', function() {
                        UI.closeContextMenu();
                        UI.hideUtilityInfoCard();
                    });
                },
                
                // Get user's current location
                getUserLocation: function() {
                    if (navigator.geolocation) {
                        UI.showStatusBar('Getting your location...');
                        
                        navigator.geolocation.getCurrentPosition(
                            // Success
                            function(position) {
                                const lat = position.coords.latitude;
                                const lng = position.coords.longitude;
                                
                                // Center map on user location
                                MapController.map.setView([lat, lng], 18);
                                
                                // Add a marker for user location
                                MapController.addUserLocationMarker(lat, lng);
                                
                                UI.showStatusBar('Location found. Ready to track utilities.');
                                setTimeout(() => UI.hideStatusBar(), 3000);
                            },
                            // Error
                            function(error) {
                                console.error('Error getting location:', error);
                                UI.showStatusBar('Could not get your location. Using default map view.');
                                setTimeout(() => UI.hideStatusBar(), 3000);
                            },
                            // Options
                            {
                                enableHighAccuracy: true,
                                timeout: 10000,
                                maximumAge: 0
                            }
                        );
                    } else {
                        UI.showStatusBar('Geolocation is not supported by your browser.');
                        setTimeout(() => UI.hideStatusBar(), 3000);
                    }
                },
                
                // Add user location marker
                addUserLocationMarker: function(lat, lng) {
                    // Create pulsing marker style
                    const userLocationIcon = L.divIcon({
                        className: 'user-location-marker',
                        html: '<div class="location-pulse"></div><div class="location-center"></div>',
                        iconSize: [24, 24],
                        iconAnchor: [12, 12]
                    });
                    
                    // Add marker to map
                    const marker = L.marker([lat, lng], {
                        icon: userLocationIcon,
                        zIndexOffset: 1000
                    }).addTo(this.map);
                    
                    // Store reference to marker
                    this.userLocationMarker = marker;
                },
                
                // Add a utility line to the map
                addUtilityLine: function(utility) {
                    if (!utility || !utility.points || utility.points.length < 2) return;
                    
                    // Get color based on utility type
                    const colors = {
                        water: 'var(--water-color)',
                        gas: 'var(--gas-color)',
                        electric: 'var(--electric-color)',
                        sewer: 'var(--sewer-color)',
                        telecom: 'var(--telecom-color)'
                    };
                    
                    // Create line style options based on line type
                    const lineOptions = {
                        color: colors[utility.type],
                        weight: utility.lineType === 'main' ? 6 : 4,
                        opacity: 1,
                        lineJoin: 'round',
                        className: `utility-line ${utility.type} ${utility.lineType}`
                    };
                    
                    // Add dash style for service lines
                    if (utility.lineType === 'service') {
                        lineOptions.dashArray = '8, 8';
                    }
                    
                    // Create polyline
                    const line = L.polyline(utility.points, lineOptions);
                    
                    // Store reference to the utility ID
                    line.utilityId = utility.id;
                    
                    // Add to appropriate layer
                    line.addTo(this.utilityLayers[utility.type]);
                    
                    // Add marker at start point
                    const startMarker = this.addUtilityMarker(
                        utility.points[0],
                        utility.type,
                        utility.id
                    );
                    
                    // Add connector marker if this is a service line with connections
                    if (utility.lineType === 'service' && utility.connections && utility.connections.length > 0) {
                        const mainConnection = utility.connections.find(c => c.type === 'main');
                        if (mainConnection && mainConnection.point) {
                            // Add a connector marker at the connection point
                            utility.connector = this.addConnectorMarker(mainConnection.point, utility.type);
                        }
                    }
                    
                    // Store reference to the line in the utility object
                    utility.line = line;
                    utility.marker = startMarker;
                    
                    // Return the created line
                    return line;
                },
                
                // Add measurement line to the map
                addMeasurementLine: function(points) {
                    if (!points || points.length < 2) return;
                    
                    // Create polyline
                    const line = L.polyline(points, {
                        color: 'var(--primary)',
                        weight: 2,
                        opacity: 0.8,
                        dashArray: '5, 5',
                        className: 'measure-line'
                    }).addTo(this.measurementLayer);
                    
                    // Calculate distance
                    const distance = this.calculateDistance(points[0], points[1]);
                    
                    // Add distance label
                    const midpoint = this.getMidpoint(points[0], points[1]);
                    
                    const labelHtml = `
                        <div class="measure-label">
                            ${distance.toFixed(2)} ft
                        </div>
                    `;
                    
                    const icon = L.divIcon({
                        html: labelHtml,
                        className: '',
                        iconSize: [80, 24],
                        iconAnchor: [40, 12]
                    });
                    
                    // Create marker for the label
                    const marker = L.marker(midpoint, {
                        icon: icon,
                        draggable: false
                    }).addTo(this.measurementLayer);
                    
                    // Store reference to the measurement
                    const measurement = {
                        id: DataStore.generateId('measurement'),
                        points: points,
                        distance: distance,
                        line: line,
                        label: marker
                    };
                    
                    // Add to data store
                    DataStore.measurements.push(measurement);
                    
                    return measurement;
                },
                
                // Calculate distance between two points in feet
                calculateDistance: function(latlng1, latlng2) {
                    // Calculate distance in meters
                    const distanceMeters = this.map.distance(latlng1, latlng2);
                    
                    // Convert to feet (1 meter = 3.28084 feet)
                    return distanceMeters * 3.28084;
                },
                
                // Get midpoint between two lat/lng points
                getMidpoint: function(latlng1, latlng2) {
                    return L.latLng(
                        (latlng1.lat + latlng2.lat) / 2,
                        (latlng1.lng + latlng2.lng) / 2
                    );
                },
                
                // Clear all measurement lines
                clearMeasurements: function() {
                    this.measurementLayer.clearLayers();
                    DataStore.measurements = [];
                },
                
                // Enable high accuracy repositioning for a utility
                enableRepositioning: function(utility) {
                    if (!utility || !utility.line) return;
                    
                    // Store the utility being repositioned
                    AppState.repositioningUtility = utility;
                    
                    // Get the original points
                    const points = utility.line.getLatLngs();
                    
                    // Create more control points for better repositioning
                    AppState.controlPoints = [];
                    
                    // Create a control point for each vertex in the line
                    for (let i = 0; i < points.length; i++) {
                        const point = points[i];
                        
                        // Create marker for control point
                        const handle = L.marker(point, {
                            draggable: true,
                            icon: L.divIcon({
                                className: 'edit-control-point',
                                iconSize: [12, 12],
                                iconAnchor: [6, 6]
                            })
                        }).addTo(this.map);
                        
                        // Add point index label
                        const labelDiv = document.createElement('div');
                        labelDiv.className = 'control-point-label';
                        labelDiv.textContent = `Point ${i+1}`;
                        
                        const label = L.marker(point, {
                            icon: L.divIcon({
                                html: labelDiv,
                                className: '',
                                iconSize: [0, 0]
                            })
                        }).addTo(this.map);
                        
                        // Store point index
                        handle.pointIndex = i;
                        
                        // Add drag events
                        handle.on('drag', function(e) {
                            // Update point position
                            points[this.pointIndex] = e.latlng;
                            
                            // Update line on the map
                            utility.line.setLatLngs(points);
                            
                            // Update label position
                            label.setLatLng(e.latlng);
                        });
                        
                        // Store control point and label
                        AppState.controlPoints.push(handle);
                        AppState.controlPoints.push(label);
                    }
                    
                    // Show repositioning panel
                    UI.showRepositionPanel();
                    
                    // Zoom in for better precision
                    this.map.setView(points[0], 21);
                },
                
                // Disable high accuracy repositioning
                disableRepositioning: function(save = false) {
                    // Check if we're in repositioning mode
                    if (!AppState.repositioningUtility) return;
                    
                    const utility = AppState.repositioningUtility;
                    
                    if (save) {
                        // Update utility points with new positions
                        utility.points = utility.line.getLatLngs();
                        
                        // If there's a marker, update its position
                        if (utility.marker) {
                            utility.marker.setLatLng(utility.points[0]);
                        }
                        
                        UI.showToast('Position updated successfully', 'success');
                    } else {
                        // Revert to original points
                        utility.line.setLatLngs(utility.points);
                        
                        UI.showToast('Repositioning cancelled', 'info');
                    }
                    
                    // Remove all control points and labels
                    AppState.controlPoints.forEach(handle => {
                        this.map.removeLayer(handle);
                    });
                    
                    // Clear state
                    AppState.repositioningUtility = null;
                    AppState.controlPoints = [];
                    
                    // Hide repositioning panel
                    UI.hideRepositionPanel();
                    
                    // Save data
                    DataStore.saveData();
                },
                
                // Filter map layers by utility type and line type
                filterLayers: function() {
                    // Get checked layers
                    const waterVisible = document.getElementById('layer-water').checked;
                    const gasVisible = document.getElementById('layer-gas').checked;
                    const electricVisible = document.getElementById('layer-electric').checked;
                    const sewerVisible = document.getElementById('layer-sewer').checked;
                    const telecomVisible = document.getElementById('layer-telecom').checked;
                    
                    const mainsVisible = document.getElementById('layer-mains').checked;
                    const servicesVisible = document.getElementById('layer-services').checked;
                    
                    const structuresVisible = document.getElementById('layer-structures').checked;
                    
                    // Update visibility for each utility type layer
                    this.updateLayerVisibility('water', waterVisible);
                    this.updateLayerVisibility('gas', gasVisible);
                    this.updateLayerVisibility('electric', electricVisible);
                    this.updateLayerVisibility('sewer', sewerVisible);
                    this.updateLayerVisibility('telecom', telecomVisible);
                    
                    // Filter by line type within each visible layer
                    DataStore.utilities.water.forEach(u => this.updateUtilityVisibility(u, waterVisible, mainsVisible, servicesVisible));
                    DataStore.utilities.gas.forEach(u => this.updateUtilityVisibility(u, gasVisible, mainsVisible, servicesVisible));
                    DataStore.utilities.electric.forEach(u => this.updateUtilityVisibility(u, electricVisible, mainsVisible, servicesVisible));
                    DataStore.utilities.sewer.forEach(u => this.updateUtilityVisibility(u, sewerVisible, mainsVisible, servicesVisible));
                    DataStore.utilities.telecom.forEach(u => this.updateUtilityVisibility(u, telecomVisible, mainsVisible, servicesVisible));
                    
                    // Update structure layer visibility
                    this.updateStructureVisibility('water', waterVisible && structuresVisible);
                    this.updateStructureVisibility('gas', gasVisible && structuresVisible);
                    this.updateStructureVisibility('electric', electricVisible && structuresVisible);
                    this.updateStructureVisibility('sewer', sewerVisible && structuresVisible);
                    this.updateStructureVisibility('telecom', telecomVisible && structuresVisible);
                },
                
                // Update visibility for a layer
                updateLayerVisibility: function(type, visible) {
                    if (visible) {
                        if (!this.map.hasLayer(this.utilityLayers[type])) {
                            this.map.addLayer(this.utilityLayers[type]);
                        }
                    } else {
                        if (this.map.hasLayer(this.utilityLayers[type])) {
                            this.map.removeLayer(this.utilityLayers[type]);
                        }
                    }
                },
                
                // Update visibility for a specific utility
                updateUtilityVisibility: function(utility, typeVisible, mainsVisible, servicesVisible) {
                    if (!utility.line) return;
                    
                    const lineTypeVisible = utility.lineType === 'main' ? mainsVisible : servicesVisible;
                    const shouldBeVisible = typeVisible && lineTypeVisible;
                    
                    if (shouldBeVisible) {
                        utility.line.setStyle({ opacity: 1 });
                        if (utility.marker) utility.marker.setOpacity(1);
                    } else {
                        utility.line.setStyle({ opacity: 0 });
                        if (utility.marker) utility.marker.setOpacity(0);
                    }
                },
                
                // Update structure layer visibility
                updateStructureVisibility: function(type, visible) {
                    if (visible) {
                        if (!this.map.hasLayer(this.structureLayers[type])) {
                            this.map.addLayer(this.structureLayers[type]);
                        }
                    } else {
                        if (this.map.hasLayer(this.structureLayers[type])) {
                            this.map.removeLayer(this.structureLayers[type]);
                        }
                    }
                },
                
                // Find the nearest utility to a point
                findNearestUtility: function(latlng, maxDistance = 20) {
                    let nearest = null;
                    let minDistance = maxDistance;
                    
                    // Check each utility type
                    for (const type in DataStore.utilities) {
                        DataStore.utilities[type].forEach(utility => {
                            if (!utility.line) return;
                            
                            // Calculate distance to line
                            const distance = this.distanceToPolyline(latlng, utility.line.getLatLngs());
                            
                            if (distance < minDistance) {
                                minDistance = distance;
                                nearest = utility;
                            }
                        });
                    }
                    
                    return nearest;
                },
                
                // Calculate distance from a point to a polyline
                distanceToPolyline: function(point, polyline) {
                    let minDistance = Infinity;
                    
                    for (let i = 0; i < polyline.length - 1; i++) {
                        const distance = this.distanceToSegment(point, polyline[i], polyline[i + 1]);
                        if (distance < minDistance) {
                            minDistance = distance;
                        }
                    }
                    
                    return minDistance;
                },
                
                // Calculate distance from a point to a line segment
                distanceToSegment: function(point, segmentStart, segmentEnd) {
                    const p = L.latLng(point);
                    const p1 = L.latLng(segmentStart);
                    const p2 = L.latLng(segmentEnd);
                    
                    // Calculate the closest point on the segment
                    const x = p.lng;
                    const y = p.lat;
                    const x1 = p1.lng;
                    const y1 = p1.lat;
                    const x2 = p2.lng;
                    const y2 = p2.lat;
                    
                    const A = x - x1;
                    const B = y - y1;
                    const C = x2 - x1;
                    const D = y2 - y1;
                    
                    const dot = A * C + B * D;
                    const lenSq = C * C + D * D;
                    let param = -1;
                    
                    if (lenSq !== 0) {
                        param = dot / lenSq;
                    }
                    
                    let xx, yy;
                    
                    if (param < 0) {
                        xx = x1;
                        yy = y1;
                    } else if (param > 1) {
                        xx = x2;
                        yy = y2;
                    } else {
                        xx = x1 + param * C;
                        yy = y1 + param * D;
                    }
                    
                    const closestPoint = L.latLng(yy, xx);
                    return this.map.distance(p, closestPoint);
                },
                
                // Find the nearest structure to a point
                findNearestStructure: function(latlng, maxDistance = 20) {
                    let nearest = null;
                    let minDistance = maxDistance;
                    
                    // Check each structure type
                    for (const type in DataStore.structures) {
                        DataStore.structures[type].forEach(structure => {
                            if (!structure.marker) return;
                            
                            // Calculate distance
                            const distance = this.map.distance(latlng, structure.latlng);
                            
                            if (distance < minDistance) {
                                minDistance = distance;
                                nearest = structure;
                            }
                        });
                    }
                    
                    return nearest;
                },
                
                // Render all utilities and structures from data store
                renderAllData: function() {
                    // Clear all layers
                    for (const type in this.utilityLayers) {
                        this.utilityLayers[type].clearLayers();
                    }
                    
                    for (const type in this.structureLayers) {
                        this.structureLayers[type].clearLayers();
                    }
                    
                    this.annotationLayer.clearLayers();
                    this.measurementLayer.clearLayers();
                    
                    // Render utilities
                    for (const type in DataStore.utilities) {
                        DataStore.utilities[type].forEach(utility => {
                            this.addUtilityLine(utility);
                        });
                    }
                    
                    // Render structures
                    for (const type in DataStore.structures) {
                        DataStore.structures[type].forEach(structure => {
                            this.addStructureMarker(structure);
                        });
                    }
                    
                    // Render annotations
                    DataStore.annotations.forEach(annotation => {
                        this.addAnnotation(annotation);
                    });
                    
                    // Render measurements
                    DataStore.measurements.forEach(measurement => {
                        // Create polyline
                        const line = L.polyline(measurement.points, {
                            color: 'var(--primary)',
                            weight: 2,
                            opacity: 0.8,
                            dashArray: '5, 5',
                            className: 'measure-line'
                        }).addTo(this.measurementLayer);
                        
                        // Add distance label
                        const midpoint = this.getMidpoint(measurement.points[0], measurement.points[1]);
                        
                        const labelHtml = `
                            <div class="measure-label">
                                ${measurement.distance.toFixed(2)} ft
                            </div>
                        `;
                        
                        const icon = L.divIcon({
                            html: labelHtml,
                            className: '',
                            iconSize: [80, 24],
                            iconAnchor: [40, 12]
                        });
                        
                        // Create marker for the label
                        const marker = L.marker(midpoint, {
                            icon: icon,
                            draggable: false
                        }).addTo(this.measurementLayer);
                        
                        // Update references
                        measurement.line = line;
                        measurement.label = marker;
                    });
                },

                // Add this to MapController object to find nearby mains of the same type
                findNearbyMains: function(latlng, utilityType, maxDistance = 20) {
                    let nearestMain = null;
                    let minDistance = maxDistance;
                    
                    // Check utilities of the same type
                    DataStore.utilities[utilityType].forEach(utility => {
                        if (!utility.line || utility.lineType !== 'main') return;
                        
                        // Calculate distance to line
                        const distance = this.distanceToPolyline(latlng, utility.line.getLatLngs());
                        
                        if (distance < minDistance) {
                            minDistance = distance;
                            nearestMain = utility;
                            
                            // Also find the closest point on the main line for connection
                            nearestMain.connectionPoint = this.findClosestPointOnLine(latlng, utility.line.getLatLngs());
                        }
                    });
                    
                    return nearestMain;
                },

                // Add this to MapController to find exact connection point on a line
                findClosestPointOnLine: function(point, polyline) {
                    let minDistance = Infinity;
                    let closestPoint = null;
                    let segmentIndex = -1;
                    
                    for (let i = 0; i < polyline.length - 1; i++) {
                        const p1 = polyline[i];
                        const p2 = polyline[i + 1];
                        
                        // Calculate closest point using vector projection
                        const distance = this.distanceToSegment(point, p1, p2);
                        
                        if (distance < minDistance) {
                            minDistance = distance;
                            
                            // Calculate the actual point on the line
                            closestPoint = this.projectPointOnSegment(point, p1, p2);
                            segmentIndex = i;
                        }
                    }
                    
                    return {
                        point: closestPoint,
                        distance: minDistance,
                        segmentIndex: segmentIndex
                    };
                },

                // Add this to MapController to project a point onto a line segment
                projectPointOnSegment: function(point, segmentStart, segmentEnd) {
                    const p = L.latLng(point);
                    const p1 = L.latLng(segmentStart);
                    const p2 = L.latLng(segmentEnd);
                    
                    // Calculate the closest point on the segment
                    const x = p.lng;
                    const y = p.lat;
                    const x1 = p1.lng;
                    const y1 = p1.lat;
                    const x2 = p2.lng;
                    const y2 = p2.lat;
                    
                    const A = x - x1;
                    const B = y - y1;
                    const C = x2 - x1;
                    const D = y2 - y1;
                    
                    const dot = A * C + B * D;
                    const lenSq = C * C + D * D;
                    let param = -1;
                    
                    if (lenSq !== 0) {
                        param = dot / lenSq;
                    }
                    
                    let xx, yy;
                    
                    if (param < 0) {
                        xx = x1;
                        yy = y1;
                    } else if (param > 1) {
                        xx = x2;
                        yy = y2;
                    } else {
                        xx = x1 + param * C;
                        yy = y1 + param * D;
                    }
                    
                    return L.latLng(yy, xx);
                },

                // Add new method to add a connector marker at the connection point 
                addConnectorMarker: function(latlng, utilityType) {
                    const markerHtml = `<svg width="12" height="12" viewBox="0 0 12 12">
                        <circle cx="6" cy="6" r="5" class="connector-point ${utilityType}" />
                    </svg>`;
                    
                    const icon = L.divIcon({
                        html: markerHtml,
                        className: '',
                        iconSize: [12, 12],
                        iconAnchor: [6, 6]
                    });
                    
                    return L.marker(latlng, {
                        icon: icon,
                        interactive: false
                    }).addTo(this.map);
                },

                // Add utility marker to the map
                addUtilityMarker: function(latlng, utilityType, utilityId, lineType) {
                    // Get icon for utility type
                    const icons = {
                        water: 'tint',
                        gas: 'fire',
                        electric: 'bolt',
                        sewer: 'toilet',
                        telecom: 'phone'
                    };
                    
                    // Create custom HTML icon with main indicator if needed
                    const markerHtml = `
                        <div class="utility-marker ${utilityType} ${lineType}">
                            <i class="fas fa-${icons[utilityType]}"></i>
                        </div>
                    `;
                    
                    const icon = L.divIcon({
                        html: markerHtml,
                        className: '',
                        iconSize: [36, 36],
                        iconAnchor: [18, 36]
                    });
                    
                    // Create marker
                    const marker = L.marker(latlng, {
                        icon: icon,
                        draggable: false
                    });
                    
                    // Store reference to utility ID
                    marker.utilityId = utilityId;
                    
                    // Add to appropriate layer
                    marker.addTo(this.utilityLayers[utilityType]);
                    
                    // Return the created marker
                    return marker;
                },

                // Add structure marker to the map
                addStructureMarker: function(structure) {
                    if (!structure || !structure.latlng) return;
                    
                    // Get icon for structure type
                    const icons = {
                        valve: 'tint-slash',
                        meter: 'tachometer-alt',
                        hydrant: 'fire-extinguisher',
                        regulator: 'compress-alt',
                        transformer: 'car-battery',
                        junction: 'box',
                        manhole: 'circle',
                        catchbasin: 'water',
                        handhole: 'box-open'
                    };
                    
                    // Create custom HTML icon
                    const markerHtml = `
                        <div class="structure-marker ${structure.type}">
                            <i class="fas fa-${icons[structure.structureType] || 'question'}"></i>
                        </div>
                    `;
                    
                    const icon = L.divIcon({
                        html: markerHtml,
                        className: '',
                        iconSize: [40, 40],
                        iconAnchor: [20, 20]
                    });
                    
                    // Create marker
                    const marker = L.marker(structure.latlng, {
                        icon: icon,
                        draggable: false
                    });
                    
                    // Store reference to structure ID
                    marker.structureId = structure.id;
                    
                    // Add to appropriate layer
                    marker.addTo(this.structureLayers[structure.type]);
                    
                    // Store reference to the marker
                    structure.marker = marker;
                    
                    // Return the created marker
                    return marker;
                },

                // Add an annotation to the map
                addAnnotation: function(annotation) {
                    if (!annotation || !annotation.latlng || !annotation.text) return;
                    
                    // Create custom HTML icon
                    const markerHtml = `
                        <div class="annotation-marker">
                            ${annotation.text}
                        </div>
                    `;
                    
                    const icon = L.divIcon({
                        html: markerHtml,
                        className: '',
                        iconSize: [120, 30],
                        iconAnchor: [60, 15]
                    });
                    
                    // Create marker
                    const marker = L.marker(annotation.latlng, {
                        icon: icon,
                        draggable: true
                    });
                    
                    // Store reference to annotation ID
                    marker.annotationId = annotation.id;
                    
                    // Add to annotation layer
                    marker.addTo(this.annotationLayer);
                    
                    // Store reference to the marker
                    annotation.marker = marker;
                    
                    // Return the created marker
                    return marker;
                },

                // Show temporary drawing line during mapping
                showTempLine: function(points) {
                    // Remove existing temp line if any
                    if (AppState.tempLine) {
                        this.map.removeLayer(AppState.tempLine);
                        AppState.tempLine = null;
                    }
                    
                    if (!points || points.length < 2) return;
                    
                    // Get color based on selected utility type
                    const colors = {
                        water: 'var(--water-color)',
                        gas: 'var(--gas-color)',
                        electric: 'var(--electric-color)',
                        sewer: 'var(--sewer-color)',
                        telecom: 'var(--telecom-color)'
                    };
                    
                    // Create line options based on line type
                    const lineOptions = {
                        color: colors[AppState.activeUtilityType],
                        weight: AppState.activeLineType === 'main' ? 6 : 4,
                        opacity: 0.7,
                        lineJoin: 'round'
                    };
                    
                    // Add dash style for service lines
                    if (AppState.activeLineType === 'service') {
                        lineOptions.dashArray = '8, 8';
                        lineOptions.lineCap = 'butt';
                    } else {
                        lineOptions.lineCap = 'round';
                    }
                    
                    // Create temporary polyline
                    AppState.tempLine = L.polyline(points, lineOptions).addTo(this.map);
                    
                    // Show current line type in the status bar
                    const lineTypeText = AppState.activeLineType === 'main' ? 'Main Line' : 'Service Line';
                    UI.showStatusBar(`Drawing ${AppState.activeUtilityType} ${lineTypeText}. Click to add more points or use Finish Drawing button.`);
                    
                    // If this is a service line, check for nearby mains to connect to
                    if (AppState.activeLineType === 'service' && points.length >= 2) {
                        const lastPoint = points[points.length - 1];
                        const nearbyMain = this.findNearbyMains(lastPoint, AppState.activeUtilityType, 30);
                        
                        // If a main line is found nearby
                        if (nearbyMain && nearbyMain.connectionPoint) {
                            // Store the potential connection
                            AppState.potentialConnection = {
                                mainLine: nearbyMain,
                                connectionPoint: nearbyMain.connectionPoint.point
                            };
                            
                            // Show connection indicator
                            UI.showConnectionIndicator(nearbyMain.connectionPoint.point, AppState.activeUtilityType);
                            
                            // Add visual indicator at connection point
                            if (AppState.connectionPointMarker) {
                                this.map.removeLayer(AppState.connectionPointMarker);
                            }
                            
                            // Create pulsing marker for connection point
                            const pulseIcon = L.divIcon({
                                html: `<div class="connection-point-indicator" style="width:10px;height:10px;background-color:${colors[AppState.activeUtilityType]};border-radius:50%;"></div>`,
                                className: '',
                                iconSize: [10, 10],
                                iconAnchor: [5, 5]
                            });
                            
                            AppState.connectionPointMarker = L.marker(nearbyMain.connectionPoint.point, {
                                icon: pulseIcon,
                                interactive: false
                            }).addTo(this.map);
                        } else {
                            // No nearby main, clear potential connection
                            AppState.potentialConnection = null;
                            UI.hideConnectionIndicator();
                            
                            // Remove connection point marker if it exists
                            if (AppState.connectionPointMarker) {
                                this.map.removeLayer(AppState.connectionPointMarker);
                                AppState.connectionPointMarker = null;
                            }
                        }
                    }
                },
            };
            
            /*********************************
            * UI CONTROLLER
            *********************************/
            const UI = {
                init: function() {
                    this.setupEventListeners();
                    this.updateButtons();
                    
                    // Initialize element positions
                    setTimeout(() => {
                        this.updateUIPositions();
                    }, 500);
                    
                    // Show/hide line type selector based on initial mode
                    if (AppState.mode === 'mapping') {
                        this.showLineTypeSelector();
                    } else {
                        this.hideLineTypeSelector();
                    }
                },
                
                // Set up UI event listeners
                setupEventListeners: function() {
                    // Mode toggle
                    document.querySelectorAll('#mode-toggle .mode-button').forEach(btn => {
                        btn.addEventListener('click', function() {
                            const mode = this.getAttribute('data-mode');
                            EventHandlers.setMode(mode);
                        });
                    });
                    
                    // Utility type buttons
                    document.querySelectorAll('#utility-toolbar .utility-button').forEach(btn => {
                        btn.addEventListener('click', function() {
                            const utilityType = this.getAttribute('data-utility');
                            EventHandlers.setUtilityType(utilityType);
                        });
                    });
                    
                    // Navigation bar
                    document.querySelectorAll('#nav-bar .nav-button').forEach(btn => {
                        btn.addEventListener('click', function() {
                            const screen = this.getAttribute('data-screen');
                            EventHandlers.setActiveScreen(screen);
                        });
                    });
                    
                    // Map controls
                    document.getElementById('zoom-in-btn').addEventListener('click', () => {
                        MapController.map.zoomIn();
                    });
                    
                    document.getElementById('zoom-out-btn').addEventListener('click', () => {
                        MapController.map.zoomOut();
                    });
                    
                    document.getElementById('locate-btn').addEventListener('click', () => {
                        MapController.getUserLocation();
                    });
                    
                    document.getElementById('layers-btn').addEventListener('click', () => {
                        this.toggleLayersPanel();
                    });
                    
                    document.getElementById('measure-btn').addEventListener('click', () => {
                        EventHandlers.toggleMeasurementMode();
                    });
                    
                    // Action buttons
                    document.getElementById('add-utility-btn').addEventListener('click', () => {
                        if (AppState.mode === 'discovery') {
                            this.showAddUtilityModal();
                        } else {
                            EventHandlers.startUtilityMapping();
                        }
                    });
                    
                    // Menu button
                    document.getElementById('menu-button').addEventListener('click', () => {
                        this.showMainMenu();
                    });
                    
                    // Close buttons for modals
                    document.querySelectorAll('.modal-close').forEach(btn => {
                        btn.addEventListener('click', () => {
                            this.closeAllModals();
                        });
                    });
                    
                    // Add utility modal
                    document.getElementById('close-add-utility').addEventListener('click', () => {
                        this.hideAddUtilityModal();
                    });
                    
                    document.getElementById('cancel-add-utility').addEventListener('click', () => {
                        this.hideAddUtilityModal();
                    });
                    
                    document.getElementById('confirm-add-utility').addEventListener('click', () => {
                        EventHandlers.handleAddUtility();
                    });
                    
                    // Utility type selection in modal
                    document.querySelectorAll('#add-utility-modal .utility-option').forEach(option => {
                        option.addEventListener('click', function() {
                            // Deselect all options
                            document.querySelectorAll('#add-utility-modal .utility-option').forEach(opt => {
                                opt.classList.remove('selected');
                            });
                            
                            // Select this option
                            this.classList.add('selected');
                        });
                    });
                    
                    // Add structure modal
                    document.getElementById('close-add-structure').addEventListener('click', () => {
                        this.hideAddStructureModal();
                    });
                    
                    document.getElementById('cancel-add-structure').addEventListener('click', () => {
                        this.hideAddStructureModal();
                    });
                    
                    document.getElementById('confirm-add-structure').addEventListener('click', () => {
                        EventHandlers.handleAddStructure();
                    });
                    
                    // Structure type selection in modal
                    document.querySelectorAll('#add-structure-modal .structure-option').forEach(option => {
                        option.addEventListener('click', function() {
                            // Deselect all options
                            document.querySelectorAll('#add-structure-modal .structure-option').forEach(opt => {
                                opt.classList.remove('selected');
                            });
                            
                            // Select this option
                            this.classList.add('selected');
                        });
                    });
                    
                    // Layer panel
                    document.getElementById('close-layers').addEventListener('click', () => {
                        this.hideLayersPanel();
                    });
                    
                    // Layer toggles
                    document.querySelectorAll('#layers-panel input[type="checkbox"]').forEach(checkbox => {
                        checkbox.addEventListener('change', () => {
                            MapController.filterLayers();
                        });
                    });
                    
                    // Main menu panel
                    document.getElementById('close-main-menu').addEventListener('click', () => {
                        this.hideMainMenu();
                    });
                    
                    // Menu actions
                    document.getElementById('menu-add-utility').addEventListener('click', () => {
                        this.hideMainMenu();
                        this.showAddUtilityModal();
                    });
                    
                    document.getElementById('menu-add-structure').addEventListener('click', () => {
                        this.hideMainMenu();
                        this.showAddStructureModal();
                    });
                    
                    document.getElementById('menu-toggle-layers').addEventListener('click', () => {
                        this.hideMainMenu();
                        this.toggleLayersPanel();
                    });
                    
                    document.getElementById('menu-export').addEventListener('click', () => {
                        this.hideMainMenu();
                        DataStore.exportData();
                    });
                    
                    document.getElementById('menu-import').addEventListener('click', () => {
                        this.hideMainMenu();
                        this.importData();
                    });
                    
                    // Context menu actions
                    document.getElementById('edit-item').addEventListener('click', () => {
                        if (AppState.selectedElement) {
                            if (AppState.selectedElement.type === 'utility') {
                                this.showEditUtilityModal(AppState.selectedElement.element);
                            } else if (AppState.selectedElement.type === 'structure') {
                                this.showEditStructureModal(AppState.selectedElement.element);
                            }
                        }
                        this.closeContextMenu();
                    });
                    
                    document.getElementById('connect-item').addEventListener('click', () => {
                        if (AppState.selectedElement) {
                            this.showConnectUtilityModal(AppState.selectedElement.element);
                        }
                        this.closeContextMenu();
                    });
                    
                    document.getElementById('measure-item').addEventListener('click', () => {
                        if (AppState.selectedElement) {
                            EventHandlers.startMeasuringFromElement(AppState.selectedElement.element);
                        }
                        this.closeContextMenu();
                    });
                    
                    document.getElementById('reposition-item').addEventListener('click', () => {
                        if (AppState.selectedElement && AppState.selectedElement.type === 'utility') {
                            MapController.enableRepositioning(AppState.selectedElement.element);
                        }
                        this.closeContextMenu();
                    });
                    
                    document.getElementById('delete-item').addEventListener('click', () => {
                        if (AppState.selectedElement) {
                            this.showDeleteConfirmation();
                        }
                        this.closeContextMenu();
                    });
                    
                    // Utility info card
                    document.getElementById('info-close-btn').addEventListener('click', () => {
                        this.hideUtilityInfoCard();
                    });
                    
                    document.getElementById('edit-utility-btn').addEventListener('click', () => {
                        if (AppState.selectedElement) {
                            this.showEditUtilityModal(AppState.selectedElement.element);
                        }
                        this.hideUtilityInfoCard();
                    });
                    
                    document.getElementById('reposition-utility-btn').addEventListener('click', () => {
                        if (AppState.selectedElement && AppState.selectedElement.type === 'utility') {
                            MapController.enableRepositioning(AppState.selectedElement.element);
                        }
                        this.hideUtilityInfoCard();
                    });
                    
                    // Confirm delete dialog
                    document.getElementById('cancel-delete').addEventListener('click', () => {
                        this.hideDeleteConfirmation();
                    });
                    
                    document.getElementById('confirm-delete').addEventListener('click', () => {
                        EventHandlers.deleteSelectedElement();
                        this.hideDeleteConfirmation();
                    });
                    
                    // Annotation modal
                    document.getElementById('close-annotation').addEventListener('click', () => {
                        this.hideAddAnnotationModal();
                    });
                    
                    document.getElementById('cancel-annotation').addEventListener('click', () => {
                        this.hideAddAnnotationModal();
                    });
                    
                    document.getElementById('confirm-annotation').addEventListener('click', () => {
                        EventHandlers.addAnnotation();
                    });
                    
                    // Measurement toolbar
                    document.getElementById('measurement-toolbar').querySelectorAll('.measurement-button').forEach(btn => {
                        btn.addEventListener('click', function() {
                            const tool = this.getAttribute('data-tool');
                            EventHandlers.handleMeasurementTool(tool);
                        });
                    });
                    
                    // Repositioning panel
                    document.getElementById('cancel-reposition-btn').addEventListener('click', () => {
                        MapController.disableRepositioning(false);
                    });
                    
                    document.getElementById('save-reposition-btn').addEventListener('click', () => {
                        MapController.disableRepositioning(true);
                    });
                    
                    // Connect utility modal
                    document.getElementById('close-connect').addEventListener('click', () => {
                        this.hideConnectUtilityModal();
                    });
                    
                    document.getElementById('cancel-connect').addEventListener('click', () => {
                        this.hideConnectUtilityModal();
                    });
                    
                    document.getElementById('confirm-connect').addEventListener('click', () => {
                        EventHandlers.connectUtility();
                    });

                    // Add listener for confirm drawing button
                    document.getElementById('confirm-drawing-btn').addEventListener('click', () => {
                        if (AppState.isDrawing && AppState.drawingPoints.length >= 2) {
                            EventHandlers.finishUtilityDrawing();
                        }
                    });

                    // Line type selector buttons
                    document.querySelectorAll('#line-type-selector .line-type-button').forEach(btn => {
                        btn.addEventListener('click', function() {
                            const lineType = this.getAttribute('data-type');
                            EventHandlers.setLineType(lineType);
                        });
                    });

                    // Update line type buttons
                    document.querySelectorAll('#line-type-selector .line-type-button').forEach(btn => {
                        btn.classList.remove('active');
                    });
                    document.querySelector(`#line-type-selector .line-type-button[data-type="${AppState.activeLineType}"]`).classList.add('active');
                },
                
                // Update UI based on current app state
                updateButtons: function() {
                    // Update mode buttons
                    document.querySelectorAll('#mode-toggle .mode-button').forEach(btn => {
                        btn.classList.remove('active');
                    });
                    document.querySelector(`#mode-toggle .mode-button[data-mode="${AppState.mode}"]`).classList.add('active');
                    
                    // Update utility type buttons
                    document.querySelectorAll('#utility-toolbar .utility-button').forEach(btn => {
                        btn.classList.remove('active');
                    });
                    document.querySelector(`#utility-toolbar .utility-button[data-utility="${AppState.activeUtilityType}"]`).classList.add('active');
                    
                    // Update line type buttons
                    document.querySelectorAll('#line-type-selector .line-type-button').forEach(btn => {
                        btn.classList.remove('active');
                    });
                    document.querySelector(`#line-type-selector .line-type-button[data-type="${AppState.activeLineType}"]`).classList.add('active');
                    
                    // Update measurement button
                    if (AppState.isMeasuring) {
                        document.getElementById('measure-btn').classList.add('active');
                    } else {
                        document.getElementById('measure-btn').classList.remove('active');
                    }
                    
                    // Update floating action button based on mode
                    const addBtn = document.getElementById('add-utility-btn');
                    if (AppState.mode === 'discovery') {
                        addBtn.innerHTML = '<i class="fas fa-plus"></i>';
                        addBtn.title = 'Add Utility';
                    } else {
                        addBtn.innerHTML = '<i class="fas fa-draw-polygon"></i>';
                        addBtn.title = 'Draw Utility';
                    }
                },
                
                // Show status bar with message
                showStatusBar: function(message) {
                    const statusBar = document.getElementById('status-bar');
                    document.getElementById('status-text').textContent = message;
                    statusBar.classList.add('visible');
                },
                
                // Hide status bar
                hideStatusBar: function() {
                    const statusBar = document.getElementById('status-bar');
                    statusBar.classList.remove('visible');
                },
                
                // Show a toast notification
                showToast: function(message, type = 'info') {
                    const container = document.getElementById('notification-container');
                    
                    // Create toast element
                    const toast = document.createElement('div');
                    toast.className = `toast ${type}`;
                    
                    // Set icon based on type
                    let icon = 'info-circle';
                    if (type === 'success') icon = 'check-circle';
                    if (type === 'error') icon = 'exclamation-circle';
                    if (type === 'warning') icon = 'exclamation-triangle';
                    
                    toast.innerHTML = `
                        <div class="toast-icon"><i class="fas fa-${icon}"></i></div>
                        <div class="toast-content">${message}</div>
                        <button class="toast-close"><i class="fas fa-times"></i></button>
                    `;
                    
                    // Add to container
                    container.appendChild(toast);
                    
                    // Add close event
                    toast.querySelector('.toast-close').addEventListener('click', () => {
                        toast.classList.remove('visible');
                        setTimeout(() => {
                            container.removeChild(toast);
                        }, 300);
                    });
                    
                    // Show toast with animation
                    setTimeout(() => {
                        toast.classList.add('visible');
                    }, 10);
                    
                    // Auto-hide after timeout
                    setTimeout(() => {
                        if (container.contains(toast)) {
                            toast.classList.remove('visible');
                            setTimeout(() => {
                                if (container.contains(toast)) {
                                    container.removeChild(toast);
                                }
                            }, 300);
                        }
                    }, 5000);
                },
                
                // Show context menu
                showContextMenu: function(e, element) {
                    const contextMenu = document.getElementById('context-menu');
                    
                    // Position menu at click coordinates
                    const x = e.containerPoint.x;
                    const y = e.containerPoint.y;
                    
                    contextMenu.style.left = `${x}px`;
                    contextMenu.style.top = `${y}px`;
                    
                    // Store selected element
                    AppState.selectedElement = element;
                    
                    // Update menu items based on element type
                    if (element.type === 'utility') {
                        document.getElementById('connect-item').style.display = 'flex';
                        document.getElementById('measure-item').style.display = 'flex';
                        document.getElementById('reposition-item').style.display = 'flex';
                    } else {
                        document.getElementById('connect-item').style.display = 'none';
                        document.getElementById('measure-item').style.display = 'none';
                        document.getElementById('reposition-item').style.display = 'none';
                    }
                    
                    // Show menu
                    contextMenu.classList.add('visible');
                },
                
                // Close context menu
                closeContextMenu: function() {
                    const contextMenu = document.getElementById('context-menu');
                    contextMenu.classList.remove('visible');
                },
                
                // Show utility info card
                showUtilityInfoCard: function(utility, position) {
                    const infoCard = document.getElementById('utility-info-card');
                    
                    // Set position
                    infoCard.style.left = `${position.x}px`;
                    infoCard.style.top = `${position.y}px`;
                    
                    // Fill in utility details
                    const utilityTypeNames = {
                        water: 'Water',
                        gas: 'Gas',
                        electric: 'Electric',
                        sewer: 'Sewer',
                        telecom: 'Telecom'
                    };
                    
                    const lineTypeNames = {
                        main: 'Main Line',
                        service: 'Service Line'
                    };
                    
                    document.getElementById('info-title').textContent = `${utilityTypeNames[utility.type]} ${lineTypeNames[utility.lineType]}`;
                    document.getElementById('info-type').textContent = utilityTypeNames[utility.type];
                    document.getElementById('info-line-type').textContent = lineTypeNames[utility.lineType];
                    document.getElementById('info-size').textContent = `${utility.size} inches`;
                    document.getElementById('info-depth').textContent = `${utility.depth} feet`;
                    document.getElementById('info-material').textContent = utility.material || 'Unknown';
                    document.getElementById('info-condition').textContent = utility.condition || 'Unknown';
                    
                    // Format date
                    const date = utility.date ? new Date(utility.date) : new Date();
                    document.getElementById('info-date').textContent = date.toLocaleString();
                    
                    // Display image if available
                    const imageElement = document.getElementById('info-image');
                    if (utility.imageData) {
                        imageElement.src = utility.imageData;
                        imageElement.style.display = 'block';
                    } else {
                        imageElement.style.display = 'none';
                    }
                    
                    // Store selected element
                    AppState.selectedElement = {
                        type: 'utility',
                        element: utility
                    };
                    
                    // Show card
                    infoCard.classList.add('visible');
                },
                
                // Hide utility info card
                hideUtilityInfoCard: function() {
                    const infoCard = document.getElementById('utility-info-card');
                    infoCard.classList.remove('visible');
                },
                
                // Show add utility modal
                showAddUtilityModal: function() {
                    const modal = document.getElementById('add-utility-modal');
                    
                    // Reset form values
                    document.querySelectorAll('#add-utility-modal .utility-option').forEach(opt => {
                        opt.classList.remove('selected');
                    });
                    
                    // Select current utility type
                    document.querySelector(`#add-utility-modal .utility-option[data-type="${AppState.activeUtilityType}"]`).classList.add('selected');
                    
                    // Set line type to current
                    if (AppState.activeLineType === 'main') {
                        document.getElementById('main-type').checked = true;
                    } else {
                        document.getElementById('service-type').checked = true;
                    }
                    
                    // Reset other form fields
                    document.getElementById('utility-size').value = '4';
                    document.getElementById('utility-depth').value = '3';
                    document.getElementById('utility-material').value = 'PVC';
                    document.getElementById('utility-condition').value = 'Good';
                    document.getElementById('utility-photo').value = '';
                    document.getElementById('utility-notes').value = '';
                    
                    // Show modal
                    modal.classList.add('visible');
                    modal.querySelector('.modal-container').style.opacity = '0';
                    
                    setTimeout(() => {
                        modal.querySelector('.modal-container').style.opacity = '1';
                    }, 10);
                },
                
                // Hide add utility modal
                hideAddUtilityModal: function() {
                    const modal = document.getElementById('add-utility-modal');
                    modal.querySelector('.modal-container').style.opacity = '0';
                    
                    setTimeout(() => {
                        modal.classList.remove('visible');
                    }, 300);
                },
                
                // Show add structure modal
                showAddStructureModal: function() {
                    const modal = document.getElementById('add-structure-modal');
                    
                    // Reset form values
                    document.querySelectorAll('#add-structure-modal .structure-option').forEach(opt => {
                        opt.classList.remove('selected');
                    });
                    
                    // Reset form fields
                    document.getElementById('structure-size').value = '24';
                    document.getElementById('structure-depth').value = '3';
                    document.getElementById('structure-material').value = 'Concrete';
                    document.getElementById('structure-condition').value = 'Good';
                    document.getElementById('structure-photo').value = '';
                    document.getElementById('structure-notes').value = '';
                    
                    // Show modal
                    modal.classList.add('visible');
                    modal.querySelector('.modal-container').style.opacity = '0';
                    
                    setTimeout(() => {
                        modal.querySelector('.modal-container').style.opacity = '1';
                    }, 10);
                },
                
                // Hide add structure modal
                hideAddStructureModal: function() {
                    const modal = document.getElementById('add-structure-modal');
                    modal.querySelector('.modal-container').style.opacity = '0';
                    
                    setTimeout(() => {
                        modal.classList.remove('visible');
                    }, 300);
                },
                
                // Toggle layers panel
                toggleLayersPanel: function() {
                    const panel = document.getElementById('layers-panel');
                    
                    if (panel.classList.contains('visible')) {
                        this.hideLayersPanel();
                    } else {
                        this.showLayersPanel();
                    }
                },
                
                // Show layers panel
                showLayersPanel: function() {
                    const panel = document.getElementById('layers-panel');
                    panel.classList.add('visible');
                },
                
                // Hide layers panel
                hideLayersPanel: function() {
                    const panel = document.getElementById('layers-panel');
                    panel.classList.remove('visible');
                },
                
                // Show main menu
                showMainMenu: function() {
                    const panel = document.getElementById('main-menu-panel');
                    panel.classList.add('visible');
                },
                
                // Hide main menu
                hideMainMenu: function() {
                    const panel = document.getElementById('main-menu-panel');
                    panel.classList.remove('visible');
                },
                
                // Show measurement toolbar
                showMeasurementToolbar: function() {
                    const toolbar = document.getElementById('measurement-toolbar');
                    toolbar.classList.add('visible');
                    
                    // Set the first button as active
                    toolbar.querySelectorAll('.measurement-button').forEach(btn => {
                        btn.classList.remove('active');
                    });
                    toolbar.querySelector('.measurement-button[data-tool="measure-distance"]').classList.add('active');
                },
                
                // Hide measurement toolbar
                hideMeasurementToolbar: function() {
                    const toolbar = document.getElementById('measurement-toolbar');
                    toolbar.classList.remove('visible');
                },
                
                // Show add annotation modal
                showAddAnnotationModal: function() {
                    const modal = document.getElementById('add-annotation-modal');
                    
                    // Reset form
                    document.getElementById('annotation-text').value = '';
                    
                    // Show modal
                    modal.classList.add('visible');
                    modal.querySelector('.modal-container').style.opacity = '0';
                    
                    setTimeout(() => {
                        modal.querySelector('.modal-container').style.opacity = '1';
                    }, 10);
                },
                
                // Hide add annotation modal
                hideAddAnnotationModal: function() {
                    const modal = document.getElementById('add-annotation-modal');
                    modal.querySelector('.modal-container').style.opacity = '0';
                    
                    setTimeout(() => {
                        modal.classList.remove('visible');
                    }, 300);
                },
                
                // Show delete confirmation
                showDeleteConfirmation: function() {
                    const modal = document.getElementById('confirm-delete-modal');
                    
                    // Update message based on element type
                    let message = 'Are you sure you want to delete this item? This action cannot be undone.';
                    
                    if (AppState.selectedElement) {
                        if (AppState.selectedElement.type === 'utility') {
                            message = 'Are you sure you want to delete this utility? This action cannot be undone.';
                        } else if (AppState.selectedElement.type === 'structure') {
                            message = 'Are you sure you want to delete this structure? This action cannot be undone.';
                        }
                    }
                    
                    document.querySelector('.confirm-dialog-message').textContent = message;
                    
                    // Show modal
                    modal.classList.add('visible');
                    modal.querySelector('.confirm-dialog').classList.add('animate-scale');
                },
                
                // Hide delete confirmation
                hideDeleteConfirmation: function() {
                    const modal = document.getElementById('confirm-delete-modal');
                    modal.querySelector('.confirm-dialog').classList.remove('animate-scale');
                    
                    setTimeout(() => {
                        modal.classList.remove('visible');
                    }, 300);
                },
                
                // Show repositioning panel
                showRepositionPanel: function() {
                    const panel = document.getElementById('reposition-panel');
                    panel.classList.add('visible');
                },
                
                // Hide repositioning panel
                hideRepositionPanel: function() {
                    const panel = document.getElementById('reposition-panel');
                    panel.classList.remove('visible');
                },
                
                // Show connect utility modal
                showConnectUtilityModal: function(utility) {
                    const modal = document.getElementById('connect-utility-modal');
                    
                    // Reset form
                    document.getElementById('connection-type').value = 'tap';
                    document.getElementById('connection-notes').value = '';
                    
                    // Populate target dropdown
                    const dropdown = document.getElementById('connection-target');
                    dropdown.innerHTML = ''; // Clear existing options
                    
                    // Find potential connection targets
                    const targets = [];
                    
                    // Same utility type
                    DataStore.utilities[utility.type].forEach(u => {
                        if (u.id !== utility.id) {
                            // Add main lines as potential targets
                            if (u.lineType === 'main') {
                                const option = document.createElement('option');
                                option.value = u.id;
                                option.textContent = `${u.type.charAt(0).toUpperCase() + u.type.slice(1)} Main`;
                                dropdown.appendChild(option);
                                targets.push(u);
                            }
                        }
                    });
                    
                    // Add structures of the same type
                    DataStore.structures[utility.type].forEach(s => {
                        const option = document.createElement('option');
                        option.value = s.id;
                        option.textContent = `${s.structureType.charAt(0).toUpperCase() + s.structureType.slice(1)}`;
                        dropdown.appendChild(option);
                        targets.push(s);
                    });
                    
                    // Show or hide target group based on if we have targets
                    document.getElementById('connection-target-group').style.display = targets.length > 0 ? 'block' : 'none';
                    
                    // Store selected utility
                    AppState.selectedElement = {
                        type: 'utility',
                        element: utility
                    };
                    
                    // Show modal
                    modal.classList.add('visible');
                    modal.querySelector('.modal-container').style.opacity = '0';
                    
                    setTimeout(() => {
                        modal.querySelector('.modal-container').style.opacity = '1';
                    }, 10);
                },
                
                // Hide connect utility modal
                hideConnectUtilityModal: function() {
                    const modal = document.getElementById('connect-utility-modal');
                    modal.querySelector('.modal-container').style.opacity = '0';
                    
                    setTimeout(() => {
                        modal.classList.remove('visible');
                    }, 300);
                },
                
                // Import data from file
                importData: function() {
                    // Create file input element
                    const input = document.createElement('input');
                    input.type = 'file';
                    input.accept = 'application/json';
                    
                    // Handle file selection
                    input.onchange = function() {
                        if (!input.files || !input.files[0]) return;
                        
                        const file = input.files[0];
                        const reader = new FileReader();
                        
                        reader.onload = function(e) {
                            const jsonString = e.target.result;
                            DataStore.importData(jsonString);
                            
                            // Render the imported data
                            MapController.renderAllData();
                        };
                        
                        reader.readAsText(file);
                    };
                    
                    // Trigger file selection dialog
                    input.click();
                },
                
                // Close all modals
                closeAllModals: function() {
                    document.querySelectorAll('.modal-overlay').forEach(modal => {
                        modal.classList.remove('visible');
                    });
                },

                // Show confirm drawing button
                showConfirmDrawingButton: function() {
                    const btn = document.getElementById('confirm-drawing-btn');
                    btn.classList.add('visible');
                },
                
                // Hide confirm drawing button
                hideConfirmDrawingButton: function() {
                    const btn = document.getElementById('confirm-drawing-btn');
                    btn.classList.remove('visible');
                },
                
                // Show zoom warning
                showZoomWarning: function() {
                    const warning = document.getElementById('zoom-warning');
                    warning.classList.add('visible');
                    
                    // Auto-hide after 5 seconds
                    setTimeout(() => {
                        this.hideZoomWarning();
                    }, 5000);
                },
                
                // Hide zoom warning
                hideZoomWarning: function() {
                    const warning = document.getElementById('zoom-warning');
                    warning.classList.remove('visible');
                },
                
                // Update UI positions based on current view
                updateUIPositions: function() {
                    // Update position of floating elements based on current view
                    const navBar = document.getElementById('nav-bar');
                    const navHeight = navBar ? navBar.offsetHeight : 60;
                    
                    // Update confirm button position
                    const confirmBtn = document.getElementById('confirm-drawing-btn');
                    if (confirmBtn) {
                        confirmBtn.style.bottom = `${navHeight + 60}px`;
                    }
                    
                    // Update reposition panel position
                    const repositionPanel = document.getElementById('reposition-panel');
                    if (repositionPanel) {
                        repositionPanel.style.bottom = `${navHeight + 20}px`;
                    }
                    
                    // Update mode toggle position to avoid overlap
                    const modeToggle = document.getElementById('mode-toggle');
                    if (modeToggle) {
                        modeToggle.style.bottom = `${navHeight + 20}px`;
                    }
                    
                    // Adjust action buttons position
                    const actionButtons = document.getElementById('action-buttons');
                    if (actionButtons) {
                        actionButtons.style.bottom = `${navHeight + 20}px`;
                        
                        // Ensure action buttons don't overlap with mode toggle
                        if (modeToggle && modeToggle.offsetParent !== null) {
                            // Get mode toggle position
                            const toggleRect = modeToggle.getBoundingClientRect();
                            const actionRect = actionButtons.getBoundingClientRect();
                            
                            // If overlapping horizontally, adjust position
                            if (Math.abs(toggleRect.left + toggleRect.width/2 - actionRect.left) < 80) {
                                // Use a fixed value instead of CSS variable in JS
                                const minMargin = 16; // equivalent to var(--space-md)
                                actionButtons.style.right = `${Math.max(minMargin, (window.innerWidth - toggleRect.left) + 20)}px`;
                            }
                        }
                    }
                    
                    // Position utility toolbar to avoid overlap with other controls
                    const toolbar = document.querySelector('.utility-toolbar');
                    const mapControls = document.querySelector('.map-controls');
                    const layerControl = document.querySelector('.leaflet-control-layers');
                    
                    if (toolbar && mapControls && layerControl) {
                        // Check if layer control is expanded
                        const isExpanded = layerControl.classList.contains('leaflet-control-layers-expanded');
                        
                        if (isExpanded) {
                            // Move toolbar down to avoid overlap
                            const defaultTop = 80; // equivalent to calc(var(--space-lg) + 50px)
                            toolbar.style.top = `${Math.max(defaultTop, layerControl.getBoundingClientRect().bottom + 10)}px`;
                        }
                    }
                    
                    // Check for other UI elements that might need positioning adjustments
                    this.adjustOverlappingElements();
                    
                    // Position line type selector
                    const lineTypeSelector = document.getElementById('line-type-selector');
                    const utilityToolbar = document.querySelector('.utility-toolbar');
                    
                    if (lineTypeSelector && utilityToolbar) {
                        const toolbarRect = utilityToolbar.getBoundingClientRect();
                        lineTypeSelector.style.top = `${toolbarRect.bottom + 10}px`;
                    }
                    
                    // Position connection indicator when it's visible
                    const connectionIndicator = document.getElementById('connection-indicator');
                    if (connectionIndicator && connectionIndicator.classList.contains('visible') && AppState.potentialConnection) {
                        const point = MapController.map.latLngToContainerPoint(AppState.potentialConnection.connectionPoint);
                        connectionIndicator.style.left = `${point.x + 20}px`;
                        connectionIndicator.style.top = `${point.y - 20}px`;
                    }
                },
                
                // Method to check for and fix any overlapping elements
                adjustOverlappingElements: function() {
                    // Get all major UI elements that could overlap
                    const elements = [
                        document.querySelector('.utility-toolbar'),
                        document.querySelector('.map-controls'),
                        document.querySelector('.tool-options'),
                        document.querySelector('.leaflet-control-layers'),
                        document.querySelector('.zoom-warning'),
                        document.querySelector('.status-bar'),
                        document.getElementById('mode-toggle'),
                        document.getElementById('action-buttons')
                    ].filter(el => el && el.offsetParent !== null); // Only visible elements
                    
                    // Check current positions and adjust if needed
                    // This is a simplistic approach - in a real app you'd do more sophisticated collision detection
                    const positions = {};
                    elements.forEach(el => {
                        const rect = el.getBoundingClientRect();
                        const key = `${Math.floor(rect.top / 50)}-${Math.floor(rect.left / 50)}`;
                        
                        if (positions[key]) {
                            // Potential overlap detected, adjust position
                            if (el.classList.contains('tool-options') || el.classList.contains('map-controls')) {
                                // Adjust vertical position slightly
                                const currentTop = parseInt(el.style.top || '0');
                                el.style.top = `${currentTop + 10}px`;
                            }
                        } else {
                            positions[key] = el;
                        }
                    });
                },

                // Show line type selector
                showLineTypeSelector: function() {
                    const selector = document.getElementById('line-type-selector');
                    selector.classList.add('visible');
                },

                // Hide line type selector
                hideLineTypeSelector: function() {
                    const selector = document.getElementById('line-type-selector');
                    selector.classList.remove('visible');
                },

                // Add to UI object to handle connection indicators
                showConnectionIndicator: function(latlng, utilityType) {
                    const indicator = document.getElementById('connection-indicator');
                    const icon = document.getElementById('connection-indicator-icon');
                    
                    // Position indicator at connection point
                    const point = MapController.map.latLngToContainerPoint(latlng);
                    indicator.style.left = `${point.x + 20}px`;
                    indicator.style.top = `${point.y - 20}px`;
                    
                    // Update indicator styling based on utility type
                    icon.className = `connection-indicator-icon ${utilityType}`;
                    document.getElementById('connection-indicator-text').textContent = `Connect to ${utilityType} Main`;
                    
                    // Show indicator
                    indicator.classList.add('visible');
                },

                hideConnectionIndicator: function() {
                    const indicator = document.getElementById('connection-indicator');
                    indicator.classList.remove('visible');
                },

                // Add method to update connection indicator position
                updateConnectionIndicatorPosition: function(latlng) {
                    const indicator = document.getElementById('connection-indicator');
                    if (indicator && indicator.classList.contains('visible')) {
                        const point = MapController.map.latLngToContainerPoint(latlng);
                        indicator.style.left = `${point.x + 20}px`;
                        indicator.style.top = `${point.y - 20}px`;
                    }
                },
            };
            
            /*********************************
            * EVENT HANDLERS
            *********************************/
            const EventHandlers = {
                // Handle map click event
                handleMapClick: function(e) {
                    // Close context menu and info card if open
                    UI.closeContextMenu();
                    UI.hideUtilityInfoCard();
                    
                    // Handle based on current mode and state
                    if (AppState.isMeasuring) {
                        this.handleMeasurementClick(e);
                        return;
                    }
                    
                    if (AppState.isDrawing) {
                        this.handleDrawingClick(e);
                        return;
                    }
                    
                    // Check if we're in discovery mode with a utility type selected
                    if (AppState.mode === 'discovery' && AppState.activeUtilityType) {
                        // Check current zoom level for accuracy
                        const currentZoom = MapController.map.getZoom();
                        if (currentZoom < 18) {
                            UI.showToast('For better accuracy, zoom in closer before adding utilities', 'warning');
                        }
                        
                        // Store click location for the add utility modal
                        AppState.tempLocation = e.latlng;
                    }
                },
                
                // Handle map right-click (context menu)
                handleMapContextMenu: function(e) {
                    // Find element under click
                    const utility = MapController.findNearestUtility(e.latlng, 20);
                    const structure = MapController.findNearestStructure(e.latlng, 20);
                    
                    // Determine closest element
                    let closestElement = null;
                    
                    if (utility && structure) {
                        // Calculate distances to compare
                        const distToUtility = MapController.distanceToPolyline(e.latlng, utility.line.getLatLngs());
                        const distToStructure = MapController.map.distance(e.latlng, structure.latlng);
                        
                        if (distToUtility < distToStructure) {
                            closestElement = {
                                type: 'utility',
                                element: utility
                            };
                        } else {
                            closestElement = {
                                type: 'structure',
                                element: structure
                            };
                        }
                    } else if (utility) {
                        closestElement = {
                            type: 'utility',
                            element: utility
                        };
                    } else if (structure) {
                        closestElement = {
                            type: 'structure',
                            element: structure
                        };
                    }
                    
                    // If we found an element, show context menu
                    if (closestElement) {
                        UI.showContextMenu(e, closestElement);
                    }
                },
                
                // Handle map mouse move
                handleMapMouseMove: function(e) {
                    // Update temp line during drawing
                    if (AppState.isDrawing && AppState.drawingPoints.length > 0) {
                        const points = [...AppState.drawingPoints, e.latlng];
                        MapController.showTempLine(points);
                    }
                    
                    // Update measurement line preview
                    if (AppState.isMeasuring && AppState.measurePoints.length === 1) {
                        if (AppState.measureLine) {
                            MapController.map.removeLayer(AppState.measureLine);
                        }
                        
                        AppState.measureLine = L.polyline(
                            [AppState.measurePoints[0], e.latlng],
                            {
                                color: 'var(--primary)',
                                weight: 2,
                                opacity: 0.6,
                                dashArray: '5, 5'
                            }
                        ).addTo(MapController.map);
                    }
                    
                    // Update connection indicator position if active
                    if (AppState.isDrawing && AppState.activeLineType === 'service' && AppState.potentialConnection) {
                        UI.updateConnectionIndicatorPosition(AppState.potentialConnection.connectionPoint);
                    }
                },
                
                // Set active mode (discovery/mapping)
                setMode: function(mode) {
                    if (mode === AppState.mode) return;
                    
                    // Update state
                    AppState.mode = mode;
                    
                    // Cancel any active drawing or measurement
                    this.cancelDrawing();
                    this.cancelMeasurement();
                    
                    // Update UI
                    UI.updateButtons();
                    
                    // Show toast
                    if (mode === 'discovery') {
                        UI.showToast('Switched to Discovery Mode', 'info');
                        UI.showStatusBar('Discovery Mode: Mark utilities as you find them');
                    } else {
                        UI.showToast('Switched to Mapping Mode', 'info');
                        UI.showStatusBar('Mapping Mode: Draw complete utility lines');
                    }
                    
                    setTimeout(() => UI.hideStatusBar(), 3000);

                    // Show or hide line type selector based on mode
                    if (mode === 'mapping') {
                        UI.showLineTypeSelector();
                    } else {
                        UI.hideLineTypeSelector();
                    }
                },
                
                // Set active utility type
                setUtilityType: function(type) {
                    // Update state
                    AppState.activeUtilityType = type;
                    
                    // Update UI
                    UI.updateButtons();
                    
                    // Show toast
                    UI.showToast(`Selected ${type} utility type`, 'info');
                },
                
                // Set active screen
                setActiveScreen: function(screen) {
                    // Update navigation buttons
                    document.querySelectorAll('#nav-bar .nav-button').forEach(btn => {
                        btn.classList.remove('active');
                    });
                    document.querySelector(`#nav-bar .nav-button[data-screen="${screen}"]`).classList.add('active');
                    
                    // Handle screen transitions
                    if (screen === 'home') {
                        // Nothing to do, we're always showing the map
                    } else if (screen === 'utilities') {
                        // TODO: Add utilities list view
                        UI.showToast('Utilities list view coming soon', 'info');
                    } else if (screen === 'settings') {
                        // TODO: Add settings view
                        UI.showToast('Settings view coming soon', 'info');
                    }
                },
                
                // Handle utility drawing click
                handleDrawingClick: function(e) {
                    // Add point to drawing
                    AppState.drawingPoints.push(e.latlng);
                    
                    // Update status
                    const count = AppState.drawingPoints.length;
                    UI.showStatusBar(`Point ${count} added. Click to add more points or use the Finish Drawing button`);
                    
                    // Show confirm button after at least 2 points
                    if (count >= 2) {
                        UI.showConfirmDrawingButton();
                    }
                },
                
                // Start utility mapping
                startUtilityMapping: function() {
                    // Must be in mapping mode
                    if (AppState.mode !== 'mapping') {
                        this.setMode('mapping');
                    }
                    
                    // Start drawing
                    AppState.isDrawing = true;
                    AppState.drawingPoints = [];
                    
                    // Update status
                    UI.showStatusBar('Click on the map to start drawing a utility line. Use the Finish button when done.');
                    
                    // Update UI
                    document.body.style.cursor = 'crosshair';
                },
                
                // Finish utility drawing
                finishUtilityDrawing: function() {
                    // Check if we have enough points
                    if (AppState.drawingPoints.length < 2) {
                        UI.showToast('Not enough points to create a utility line', 'warning');
                        this.cancelDrawing();
                        return;
                    }
                    
                    // Create utility object
                    const utility = {
                        id: DataStore.generateId('utility'),
                        type: AppState.activeUtilityType,
                        lineType: AppState.activeLineType,
                        points: [...AppState.drawingPoints],
                        size: 4, // Default size
                        depth: 3, // Default depth
                        material: 'PVC', // Default material
                        condition: 'Good', // Default condition
                        date: new Date().toISOString(),
                        notes: '',
                        connections: []
                    };
                    
                    // Handle connection to main if available
                    if (AppState.activeLineType === 'service' && AppState.potentialConnection) {
                        const mainLine = AppState.potentialConnection.mainLine;
                        const connectionPoint = AppState.potentialConnection.connectionPoint;
                        
                        // Update the last point to connect precisely to the main
                        utility.points[utility.points.length - 1] = connectionPoint;
                        
                        // Record the connection in both utilities
                        utility.connections.push({
                            type: 'main',
                            targetId: mainLine.id,
                            point: connectionPoint,
                            date: new Date().toISOString()
                        });
                        
                        mainLine.connections.push({
                            type: 'service',
                            targetId: utility.id,
                            point: connectionPoint,
                            date: new Date().toISOString()
                        });
                        
                        // Add a connector marker at the connection point
                        const connector = MapController.addConnectorMarker(connectionPoint, utility.type);
                        
                        // Store reference to the connector
                        utility.connector = connector;
                        
                        UI.showToast('Service connected to main line', 'success');
                    } else {
                        // No connection, just a regular utility line
                        UI.showToast('Utility line added successfully', 'success');
                    }
                    
                    // Add to data store
                    DataStore.utilities[AppState.activeUtilityType].push(utility);
                    
                    // Add to map
                    MapController.addUtilityLine(utility);
                    
                    // Clean up drawing state
                    this.cancelDrawing();
                    
                    // Save data
                    DataStore.saveData();
                },
                
                // Cancel drawing
                cancelDrawing: function() {
                    // Reset drawing state
                    AppState.isDrawing = false;
                    AppState.drawingPoints = [];
                    AppState.potentialConnection = null;
                    
                    // Remove temp line if exists
                    if (AppState.tempLine) {
                        MapController.map.removeLayer(AppState.tempLine);
                        AppState.tempLine = null;
                    }
                    
                    // Remove connection point marker if exists
                    if (AppState.connectionPointMarker) {
                        MapController.map.removeLayer(AppState.connectionPointMarker);
                        AppState.connectionPointMarker = null;
                    }
                    
                    // Update UI
                    document.body.style.cursor = '';
                    UI.hideStatusBar();
                    UI.hideConfirmDrawingButton();
                    UI.hideConnectionIndicator();
                },
                
                // Handle add utility form submission
                handleAddUtility: function() {
                    // Get selected utility type
                    const selectedTypeEl = document.querySelector('#add-utility-modal .utility-option.selected');
                    if (!selectedTypeEl) {
                        UI.showToast('Please select a utility type', 'warning');
                        return;
                    }
                    
                    const utilityType = selectedTypeEl.getAttribute('data-type');
                    
                    // Get line type
                    const lineType = document.querySelector('input[name="line-type"]:checked').value;
                    
                    // Get other form values
                    const size = parseFloat(document.getElementById('utility-size').value) || 4;
                    const depth = parseFloat(document.getElementById('utility-depth').value) || 3;
                    const material = document.getElementById('utility-material').value;
                    const condition = document.getElementById('utility-condition').value;
                    const notes = document.getElementById('utility-notes').value;
                    
                    // Process photo if uploaded
                    const photoInput = document.getElementById('utility-photo');
                    let imageData = null;
                    
                    if (photoInput.files && photoInput.files[0]) {
                        const reader = new FileReader();
                        reader.onload = function(e) {
                            imageData = e.target.result;
                            
                            // Create and add utility with image
                            createUtility(imageData);
                        };
                        reader.readAsDataURL(photoInput.files[0]);
                    } else {
                        // Create utility without image
                        createUtility(null);
                    }
                    
                    function createUtility(imageData) {
                        // Must have a location
                        if (!AppState.tempLocation) {
                            UI.showToast('No location selected', 'error');
                            return;
                        }
                        
                        // For discovery mode, we add a short segment
                        const startPoint = AppState.tempLocation;
                        
                        // Create a second point 10 meters in the direction of 0 degrees (north)
                        // This will be updated later when the direction is known
                        const endPoint = L.latLng(
                            startPoint.lat + 0.0001, // Approximately 10 meters north
                            startPoint.lng
                        );
                        
                        // Create utility object
                        const utility = {
                            id: DataStore.generateId('utility'),
                            type: utilityType,
                            lineType: lineType,
                            points: [startPoint, endPoint],
                            size: size,
                            depth: depth,
                            material: material,
                            condition: condition,
                            date: new Date().toISOString(),
                            notes: notes,
                            imageData: imageData,
                            connections: []
                        };
                        
                        // Add to data store
                        DataStore.utilities[utilityType].push(utility);
                        
                        // Add to map
                        MapController.addUtilityLine(utility);
                        
                        // Hide modal
                        UI.hideAddUtilityModal();
                        
                        // Show success message
                        UI.showToast('Utility added successfully', 'success');
                        
                        // Clear temp location
                        AppState.tempLocation = null;
                        
                        // Save data
                        DataStore.saveData();
                    }
                },
                
                // Handle add structure form submission
                handleAddStructure: function() {
                    // Get selected structure type
                    const selectedEl = document.querySelector('#add-structure-modal .structure-option.selected');
                    if (!selectedEl) {
                        UI.showToast('Please select a structure type', 'warning');
                        return;
                    }
                    
                    const structureType = selectedEl.getAttribute('data-structure');
                    const utilityType = selectedEl.getAttribute('data-utility');
                    
                    // Get form values
                    const size = parseFloat(document.getElementById('structure-size').value) || 24;
                    const depth = parseFloat(document.getElementById('structure-depth').value) || 3;
                    const material = document.getElementById('structure-material').value;
                    const condition = document.getElementById('structure-condition').value;
                    const notes = document.getElementById('structure-notes').value;
                    
                    // Process photo if uploaded
                    const photoInput = document.getElementById('structure-photo');
                    let imageData = null;
                    
                    if (photoInput.files && photoInput.files[0]) {
                        const reader = new FileReader();
                        reader.onload = function(e) {
                            imageData = e.target.result;
                            
                            // Create and add structure with image
                            createStructure(imageData);
                        };
                        reader.readAsDataURL(photoInput.files[0]);
                    } else {
                        // Create structure without image
                        createStructure(null);
                    }
                    
                    function createStructure(imageData) {
                        // Must have a location
                        if (!AppState.tempLocation) {
                            UI.showToast('No location selected', 'error');
                            return;
                        }
                        
                        // Create structure object
                        const structure = {
                            id: DataStore.generateId('structure'),
                            type: utilityType,
                            structureType: structureType,
                            latlng: AppState.tempLocation,
                            size: size,
                            depth: depth,
                            material: material,
                            condition: condition,
                            date: new Date().toISOString(),
                            notes: notes,
                            imageData: imageData,
                            connections: []
                        };
                        
                        // Add to data store
                        DataStore.structures[utilityType].push(structure);
                        
                        // Add to map
                        MapController.addStructureMarker(structure);
                        
                        // Hide modal
                        UI.hideAddStructureModal();
                        
                        // Show success message
                        UI.showToast('Structure added successfully', 'success');
                        
                        // Clear temp location
                        AppState.tempLocation = null;
                        
                        // Save data
                        DataStore.saveData();
                    }
                },
                
                // Delete the currently selected element
                deleteSelectedElement: function() {
                    if (!AppState.selectedElement) return;
                    
                    if (AppState.selectedElement.type === 'utility') {
                        const utility = AppState.selectedElement.element;
                        
                        // Remove from map
                        if (utility.line) {
                            MapController.utilityLayers[utility.type].removeLayer(utility.line);
                        }
                        
                        if (utility.marker) {
                            MapController.utilityLayers[utility.type].removeLayer(utility.marker);
                        }
                        
                        // Remove from data store
                        const utilities = DataStore.utilities[utility.type];
                        const index = utilities.findIndex(u => u.id === utility.id);
                        
                        if (index >= 0) {
                            utilities.splice(index, 1);
                        }
                        
                        UI.showToast('Utility deleted', 'success');
                    } 
                    else if (AppState.selectedElement.type === 'structure') {
                        const structure = AppState.selectedElement.element;
                        
                        // Remove from map
                        if (structure.marker) {
                            MapController.structureLayers[structure.type].removeLayer(structure.marker);
                        }
                        
                        // Remove from data store
                        const structures = DataStore.structures[structure.type];
                        const index = structures.findIndex(s => s.id === structure.id);
                        
                        if (index >= 0) {
                            structures.splice(index, 1);
                        }
                        
                        UI.showToast('Structure deleted', 'success');
                    }
                    
                    // Clear selected element
                    AppState.selectedElement = null;
                    
                    // Save data
                    DataStore.saveData();
                },
                
                // Toggle measurement mode
                toggleMeasurementMode: function() {
                    if (AppState.isMeasuring) {
                        this.cancelMeasurement();
                    } else {
                        this.startMeasurement();
                    }
                },
                
                // Start measurement mode
                startMeasurement: function() {
                    // Cancel any active drawing
                    this.cancelDrawing();
                    
                    // Set measurement state
                    AppState.isMeasuring = true;
                    AppState.measurePoints = [];
                    
                    // Update UI
                    document.getElementById('measure-btn').classList.add('active');
                    UI.showMeasurementToolbar();
                    UI.showStatusBar('Click on the map to start measuring');
                    
                    // Change cursor
                    document.body.style.cursor = 'crosshair';
                },
                
                // Cancel measurement mode
                cancelMeasurement: function() {
                    // Reset measurement state
                    AppState.isMeasuring = false;
                    AppState.measurePoints = [];
                    
                    // Remove temp line if exists
                    if (AppState.measureLine) {
                        MapController.map.removeLayer(AppState.measureLine);
                        AppState.measureLine = null;
                    }
                    
                    // Update UI
                    document.getElementById('measure-btn').classList.remove('active');
                    UI.hideMeasurementToolbar();
                    UI.hideStatusBar();
                    
                    // Reset cursor
                    document.body.style.cursor = '';
                },
                
                // Handle click in measurement mode
                handleMeasurementClick: function(e) {
                    if (!AppState.isMeasuring) return;
                    
                    // Get active measurement tool
                    const activeTool = document.querySelector('#measurement-toolbar .measurement-button.active');
                    if (!activeTool) return;
                    
                    const toolType = activeTool.getAttribute('data-tool');
                    
                    if (toolType === 'measure-distance') {
                        // Distance measurement
                        if (AppState.measurePoints.length === 0) {
                            // First point
                            AppState.measurePoints.push(e.latlng);
                            UI.showStatusBar('Click on second point to complete measurement');
                        } else if (AppState.measurePoints.length === 1) {
                            // Second point - complete measurement
                            AppState.measurePoints.push(e.latlng);
                            
                            // Create measurement line
                            MapController.addMeasurementLine(AppState.measurePoints);
                            
                            // Reset for next measurement
                            AppState.measurePoints = [];
                            
                            // Clean up temp line
                            if (AppState.measureLine) {
                                MapController.map.removeLayer(AppState.measureLine);
                                AppState.measureLine = null;
                            }
                            
                            UI.showStatusBar('Measurement added. Click to start a new measurement.');
                        }
                    } else if (toolType === 'add-note') {
                        // Add annotation
                        AppState.tempLocation = e.latlng;
                        UI.showAddAnnotationModal();
                    }
                },
                
                // Start measuring from a selected element
                startMeasuringFromElement: function(element) {
                    // Enable measurement mode
                    this.startMeasurement();
                    
                    // Get starting point
                    let startPoint = null;
                    
                    if (element.type === 'utility') {
                        // For utilities, use the first point
                        startPoint = element.points[0];
                    } else if (element.type === 'structure') {
                        // For structures, use their position
                        startPoint = element.latlng;
                    }
                    
                    if (startPoint) {
                        // Add as first measurement point
                        AppState.measurePoints = [startPoint];
                        UI.showStatusBar('Now click on the target point to complete measurement');
                    }
                },
                
                // Handle measurement toolbar button click
                handleMeasurementTool: function(tool) {
                    // Update button states
                    document.querySelectorAll('#measurement-toolbar .measurement-button').forEach(btn => {
                        btn.classList.remove('active');
                    });
                    
                    document.querySelector(`#measurement-toolbar .measurement-button[data-tool="${tool}"]`).classList.add('active');
                    
                    // Handle tool actions
                    if (tool === 'measure-distance') {
                        // Reset measurement points
                        AppState.measurePoints = [];
                        UI.showStatusBar('Click on the map to start measuring');
                    } else if (tool === 'add-note') {
                        // Nothing to do, just wait for click
                        UI.showStatusBar('Click on the map to add a note');
                    } else if (tool === 'clear-measurements') {
                        // Clear all measurements
                        MapController.clearMeasurements();
                        UI.showToast('Measurements cleared', 'info');
                        
                        // Reset to measure distance
                        this.handleMeasurementTool('measure-distance');
                    } else if (tool === 'exit-measure') {
                        // Exit measurement mode
                        this.cancelMeasurement();
                    }
                },
                
                // Add annotation at current temp location
                addAnnotation: function() {
                    // Get annotation text
                    const text = document.getElementById('annotation-text').value.trim();
                    
                    if (!text) {
                        UI.showToast('Please enter annotation text', 'warning');
                        return;
                    }
                    
                    if (!AppState.tempLocation) {
                        UI.showToast('No location selected', 'error');
                        UI.hideAddAnnotationModal();
                        return;
                    }
                    
                    // Create annotation object
                    const annotation = {
                        id: DataStore.generateId('annotation'),
                        text: text,
                        latlng: AppState.tempLocation,
                        date: new Date().toISOString()
                    };
                    
                    // Add to data store
                    DataStore.annotations.push(annotation);
                    
                    // Add to map
                    MapController.addAnnotation(annotation);
                    
                    // Hide modal
                    UI.hideAddAnnotationModal();
                    
                    // Show success message
                    UI.showToast('Annotation added', 'success');
                    
                    // Clear temp location
                    AppState.tempLocation = null;
                    
                    // Save data
                    DataStore.saveData();
                },
                
                // Connect utility with another utility or structure
                connectUtility: function() {
                    if (!AppState.selectedElement || AppState.selectedElement.type !== 'utility') {
                        UI.hideConnectUtilityModal();
                        return;
                    }
                    
                    const utility = AppState.selectedElement.element;
                    
                    // Get connection type
                    const connectionType = document.getElementById('connection-type').value;
                    
                    // Get connection target (if available)
                    const targetId = document.getElementById('connection-target').value;
                    let target = null;
                    
                    if (targetId) {
                        // Try to find target in utilities first
                        target = DataStore.getUtilityById(targetId);
                        
                        // If not found, check structures
                        if (!target) {
                            target = DataStore.getStructureById(targetId);
                        }
                    }
                    
                    // Get notes
                    const notes = document.getElementById('connection-notes').value;
                    
                    // Create connection based on type
                    if (connectionType === 'tap' && target) {
                        // Tap into a main line
                        this.createTapConnection(utility, target, notes);
                    } else if (connectionType === 'extend' && target) {
                        // Extend from an existing line
                        this.createExtendConnection(utility, target, notes);
                    } else if (connectionType === 'connect-structure' && target) {
                        // Connect to a structure
                        this.createStructureConnection(utility, target, notes);
                    }
                    
                    // Hide modal
                    UI.hideConnectUtilityModal();
                    
                    // Save data
                    DataStore.saveData();
                },
                
                // Create a tap connection from a service to a main
                createTapConnection: function(service, main, notes) {
                    if (!service || !main) return;
                    
                    // Verify main is a main line
                    if (main.lineType !== 'main') {
                        UI.showToast('Target must be a main line for tap connection', 'warning');
                        return;
                    }
                    
                    // Find closest point on main to service start point
                    const servicePoint = service.points[0];
                    const mainPoints = main.line.getLatLngs();
                    
                    let closestDistance = Infinity;
                    let closestPoint = null;
                    let segmentIndex = 0;
                    
                    for (let i = 0; i < mainPoints.length - 1; i++) {
                        const dist = MapController.distanceToSegment(
                            servicePoint,
                            mainPoints[i],
                            mainPoints[i + 1]
                        );
                        
                        if (dist < closestDistance) {
                            closestDistance = dist;
                            
                            // Calculate closest point on the segment
                            const p = L.latLng(servicePoint);
                            const p1 = L.latLng(mainPoints[i]);
                            const p2 = L.latLng(mainPoints[i + 1]);
                            
                            // Project point onto segment
                            const x = p.lng;
                            const y = p.lat;
                            const x1 = p1.lng;
                            const y1 = p1.lat;
                            const x2 = p2.lng;
                            const y2 = p2.lat;
                            
                            const A = x - x1;
                            const B = y - y1;
                            const C = x2 - x1;
                            const D = y2 - y1;
                            
                            const dot = A * C + B * D;
                            const lenSq = C * C + D * D;
                            let param = -1;
                            
                            if (lenSq !== 0) {
                                param = dot / lenSq;
                            }
                            
                            let xx, yy;
                            
                            if (param < 0) {
                                xx = x1;
                                yy = y1;
                            } else if (param > 1) {
                                xx = x2;
                                yy = y2;
                            } else {
                                xx = x1 + param * C;
                                yy = y1 + param * D;
                            }
                            
                            closestPoint = L.latLng(yy, xx);
                            segmentIndex = i;
                        }
                    }
                    
                    if (!closestPoint) {
                        UI.showToast('Could not find tap point on main', 'error');
                        return;
                    }
                    
                    // Record the connection
                    service.connections.push({
                        type: 'tap',
                        targetId: main.id,
                        point: closestPoint,
                        notes: notes,
                        date: new Date().toISOString()
                    });
                    
                    main.connections.push({
                        type: 'tapped',
                        targetId: service.id,
                        point: closestPoint,
                        notes: notes,
                        date: new Date().toISOString()
                    });
                    
                    // Update service line points to connect to the tap point
                    service.points[0] = closestPoint;
                    service.line.setLatLngs(service.points);
                    
                    // Update service marker position
                    if (service.marker) {
                        service.marker.setLatLng(closestPoint);
                    }
                    
                    // Show success message
                    UI.showToast('Service connected to main', 'success');
                },
                
                // Create an extend connection between two utilities
                createExtendConnection: function(utility1, utility2, notes) {
                    if (!utility1 || !utility2) return;
                    
                    // Find the closest endpoints between the two utilities
                    const u1Points = utility1.points;
                    const u2Points = utility2.points;
                    
                    const u1Start = u1Points[0];
                    const u1End = u1Points[u1Points.length - 1];
                    const u2Start = u2Points[0];
                    const u2End = u2Points[u2Points.length - 1];
                    
                    // Calculate distances between all endpoint combinations
                    const distances = [
                        { from: u1End, to: u2Start, fromIndex: u1Points.length - 1, toIndex: 0, dist: MapController.map.distance(u1End, u2Start) },
                        { from: u1End, to: u2End, fromIndex: u1Points.length - 1, toIndex: u2Points.length - 1, dist: MapController.map.distance(u1End, u2End) },
                        { from: u1Start, to: u2Start, fromIndex: 0, toIndex: 0, dist: MapController.map.distance(u1Start, u2Start) },
                        { from: u1Start, to: u2End, fromIndex: 0, toIndex: u2Points.length - 1, dist: MapController.map.distance(u1Start, u2End) }
                    ];
                    
                    // Sort by distance
                    distances.sort((a, b) => a.dist - b.dist);
                    
                    // Get closest pair
                    const closest = distances[0];
                    
                    // Record the connection for both utilities
                    utility1.connections.push({
                        type: 'extend',
                        targetId: utility2.id,
                        point: closest.from,
                        notes: notes,
                        date: new Date().toISOString()
                    });
                    
                    utility2.connections.push({
                        type: 'extend',
                        targetId: utility1.id,
                        point: closest.to,
                        notes: notes,
                        date: new Date().toISOString()
                    });
                    
                    // Show success message
                    UI.showToast('Utilities connected', 'success');
                },
                
                // Create a connection from a utility to a structure
                createStructureConnection: function(utility, structure, notes) {
                    if (!utility || !structure) return;
                    
                    // Find the closest endpoint of the utility to the structure
                    const utilityPoints = utility.points;
                    const structureLatLng = structure.latlng;
                    
                    const startDist = MapController.map.distance(utilityPoints[0], structureLatLng);
                    const endDist = MapController.map.distance(utilityPoints[utilityPoints.length - 1], structureLatLng);
                    
                    let connectionPoint;
                    if (startDist < endDist) {
                        connectionPoint = utilityPoints[0];
                        
                        // Update utility line points to connect to the structure
                        utility.points[0] = structureLatLng;
                        utility.line.setLatLngs(utility.points);
                        
                        // Update utility marker position
                        if (utility.marker) {
                            utility.marker.setLatLng(structureLatLng);
                        }
                    } else {
                        connectionPoint = utilityPoints[utilityPoints.length - 1];
                        
                        // Update utility line points to connect to the structure
                        utility.points[utilityPoints.length - 1] = structureLatLng;
                        utility.line.setLatLngs(utility.points);
                    }
                    
                    // Record the connection
                    utility.connections.push({
                        type: 'structure',
                        targetId: structure.id,
                        point: structureLatLng,
                        notes: notes,
                        date: new Date().toISOString()
                    });
                    
                    structure.connections.push({
                        type: 'utility',
                        targetId: utility.id,
                        point: structureLatLng,
                        notes: notes,
                        date: new Date().toISOString()
                    });
                    
                    // Show success message
                    UI.showToast('Utility connected to structure', 'success');
                },

                // Set active line type
                setLineType: function(type) {
                    // Update state
                    AppState.activeLineType = type;
                    
                    // Update UI
                    UI.updateButtons();
                    
                    // Show toast
                    UI.showToast(`Selected ${type} line type`, 'info');
                }
            };
            
            /*********************************
            * APPLICATION INITIALIZATION
            *********************************/
            return {
                init: function() {
                    // Load data from local storage
                    DataStore.loadData();
                    
                    // Initialize the map
                    MapController.init();
                    
                    // Initialize UI
                    UI.init();
                    
                    // Render all data on the map
                    MapController.renderAllData();
                }
            };
        })();
    </script>

    <!-- Watch for window size changes to better place UI elements -->
    <script>
        window.addEventListener('resize', function() {
            if (AppState.isDrawing && AppState.drawingPoints.length >= 2) {
                UI.updateConfirmButtonPosition();
            }
            
            if (AppState.repositioningUtility) {
                UI.updateRepositionPanelPosition();
            }
        });

        // Update position of floating buttons based on window size and navbar position
        UI.updateConfirmButtonPosition = function() {
            const navBar = document.getElementById('nav-bar');
            const button = document.getElementById('confirm-drawing-btn');
            const navHeight = navBar.offsetHeight;
            
            button.style.bottom = `${navHeight + 60}px`;
        };

        UI.updateRepositionPanelPosition = function() {
            const navBar = document.getElementById('nav-bar');
            const panel = document.getElementById('reposition-panel');
            const navHeight = navBar.offsetHeight;
            
            panel.style.bottom = `${navHeight + 20}px`;
        };

        // Ensure drawing can be canceled with escape key
        document.addEventListener('keydown', function(e) {
            if (e.key === 'Escape') {
                if (AppState.isDrawing) {
                    EventHandlers.cancelDrawing();
                    UI.showToast('Drawing canceled', 'info');
                }
                
                if (AppState.repositioningUtility) {
                    MapController.disableRepositioning(false);
                }
                
                if (AppState.isMeasuring) {
                    EventHandlers.cancelMeasurement();
                }
            }
            
            // Enter key to finish drawing
            if (e.key === 'Enter') {
                if (AppState.isDrawing && AppState.drawingPoints.length >= 2) {
                    EventHandlers.finishUtilityDrawing();
                }
                
                if (AppState.repositioningUtility) {
                    MapController.disableRepositioning(true);
                }
            }
        });
    </script>

    <!-- Add these at the end of the file, just before the closing body tag -->

    <!-- Call updateUIPositions when window is resized -->
    <script>
        window.addEventListener('resize', function() {
            UI.updateUIPositions();
        });

        // Initialize UI positions when map finishes loading
        document.addEventListener('DOMContentLoaded', function() {
            setTimeout(() => {
                UI.updateUIPositions();
            }, 1000);
        });
    </script>

    <!-- Add event listener for the connection confirmation button -->
    <script>
        document.addEventListener('DOMContentLoaded', function() {
            const confirmConnectionBtn = document.getElementById('confirm-connection-btn');
            if (confirmConnectionBtn) {
                confirmConnectionBtn.addEventListener('click', function() {
                    if (AppState.isDrawing && AppState.potentialConnection) {
                        EventHandlers.finishUtilityDrawing();
                    }
                });
            }
        });
    </script>
</body>
</html>
